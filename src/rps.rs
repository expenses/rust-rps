/* automatically generated by rust-bindgen 0.65.1 */

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage> {
    storage: Storage,
}
impl<Storage> __BindgenBitfieldUnit<Storage> {
    #[inline]
    pub const fn new(storage: Storage) -> Self {
        Self { storage }
    }
}
impl<Storage> __BindgenBitfieldUnit<Storage>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        byte & mask == mask
    }
    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        if val {
            *byte |= mask;
        } else {
            *byte &= !mask;
        }
    }
    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_reverse_iterator {
    pub _address: u8,
}
pub type std_reverse_iterator_iterator_type = u8;
pub type std_reverse_iterator_iterator_category = u8;
pub type std_reverse_iterator_pointer = u8;
pub type std_reverse_iterator_value_type = u8;
pub type std_reverse_iterator_difference_type = u8;
pub type std_reverse_iterator_reference = u8;
pub type va_list = __builtin_va_list;
#[repr(i32)]
#[doc = " @brief Result and error codes used by operations of the RPS library.\n\n @ingroup Basic"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum RpsResult {
    #[doc = " Successful completion."]
    RPS_OK = 0,
    #[doc = " Failure due to an unspecified error."]
    RPS_ERROR_UNSPECIFIED = -1,
    #[doc = " Failure due to an unrecognized command."]
    RPS_ERROR_UNRECOGNIZED_COMMAND = -2,
    #[doc = " Failure due to invalid arguments."]
    RPS_ERROR_INVALID_ARGUMENTS = -3,
    #[doc = " Failure due to invalid data."]
    RPS_ERROR_INVALID_DATA = -4,
    #[doc = " Failure due to an invalid operation."]
    RPS_ERROR_INVALID_OPERATION = -5,
    #[doc = " Failure due to running out of memory."]
    RPS_ERROR_OUT_OF_MEMORY = -6,
    #[doc = " Failure due to not being able to find the specified file."]
    RPS_ERROR_FILE_NOT_FOUND = -7,
    #[doc = " Failure due to an invalid file format."]
    RPS_ERROR_INVALID_FILE_FORMAT = -8,
    #[doc = " Failure due to the file format version being too old."]
    RPS_ERROR_UNSUPPORTED_VERSION_TOO_OLD = -9,
    #[doc = " Failure due to the file format version being too new."]
    RPS_ERROR_UNSUPPORTED_VERSION_TOO_NEW = -10,
    #[doc = " Failure due to an unknown node."]
    RPS_ERROR_UNKNOWN_NODE = -11,
    #[doc = " Failure due to an index being out of its valid bounds."]
    RPS_ERROR_INDEX_OUT_OF_BOUNDS = -12,
    #[doc = " Failure due to a command being already finalized."]
    RPS_ERROR_COMMAND_ALREADY_FINAL = -13,
    #[doc = " Failure due to a data layout mismatch between runtime and shader."]
    RPS_ERROR_INTEROP_DATA_LAYOUT_MISMATCH = -14,
    #[doc = " Failure due to a key not being found."]
    RPS_ERROR_KEY_NOT_FOUND = -15,
    #[doc = " Failure due to a key value being duplicated where it is required to be unique."]
    RPS_ERROR_KEY_DUPLICATED = -16,
    #[doc = " Failure due to a feature not being implemented yet."]
    RPS_ERROR_NOT_IMPLEMENTED = -17,
    #[doc = " Failure due to an integer overflow."]
    RPS_ERROR_INTEGER_OVERFLOW = -18,
    #[doc = " Failure due to exclusive ranges overlapping."]
    RPS_ERROR_RANGE_OVERLAPPING = -19,
    #[doc = " Failure due to rpsRenderPipelineValidate finding an invalid pipeline configuration. More details are provided\n via output of the device print function."]
    RPS_ERROR_VALIDATION_FAILED = -20,
    #[doc = " Failure due to a compiled RPSL shader program being ill formed. Normally indicates a compiler error."]
    RPS_ERROR_INVALID_PROGRAM = -21,
    #[doc = " Failure due to an RPSL module being incompatible with the current runtime."]
    RPS_ERROR_UNSUPPORTED_MODULE_VERSION = -22,
    #[doc = " Failure due to a failed type safety check."]
    RPS_ERROR_TYPE_MISMATCH = -23,
    #[doc = " Failure due to a feature not being supported."]
    RPS_ERROR_NOT_SUPPORTED = -24,
    #[doc = " Failure due to failed a runtime API without direct mapping of the API error code."]
    RPS_ERROR_RUNTIME_API_ERROR = -25,
    #[doc = " Failure due to an RPS library internal error."]
    RPS_ERROR_INTERNAL_ERROR = -26,
    #[doc = " Number of unique RPS result codes."]
    RPS_RESULT_CODE_COUNT = 27,
}
extern "C" {
    #[doc = " @brief Gets the name string of a result code.\n\n @param result       Result code.\n\n @returns            Null terminated string with the result name."]
    pub fn rpsResultGetName(result: RpsResult) -> *const ::std::os::raw::c_char;
}
#[doc = " @brief Boolean value type."]
pub type RpsBool = i32;
#[doc = " @brief Type for holding up to 16 bitflags."]
pub type RpsFlags16 = u16;
#[doc = " @brief Type for holding up to 32 bitflags."]
pub type RpsFlags32 = u32;
#[doc = " @brief Type for holding up to 64 bitflags."]
pub type RpsFlags64 = u64;
#[doc = " @brief Type for general 32-bit index values."]
pub type RpsIndex32 = u32;
#[doc = " @brief Signature of functions for allocating memory.\n\n @param pContext                 Context for memory allocation.\n @param size                     Size of the desired allocation in bytes.\n @param alignment                Minimum alignment requirement of the desired allocation in bytes.\n\n @returns                        Pointer to the allocated memory."]
pub type PFN_rpsAlloc = ::std::option::Option<
    unsafe extern "C" fn(
        pContext: *mut ::std::os::raw::c_void,
        size: usize,
        alignment: usize,
    ) -> *mut ::std::os::raw::c_void,
>;
#[doc = " @brief Signature of functions for reallocating memory.\n\n @param pUserContext             Context for memory allocation.\n @param oldBuffer                Address of the memory allocation to be reallocated.\n                                 Must not be NULL for oldSize != 0.\n @param oldSize                  Size of the old memory allocation in bytes.\n @param newSize                  Desired size of the allocation in bytes.\n @param alignment                Minimum alignment requirement of the desired allocation in bytes.\n\n @returns                        Pointer to the (re-)allocated memory."]
pub type PFN_rpsRealloc = ::std::option::Option<
    unsafe extern "C" fn(
        pUserContext: *mut ::std::os::raw::c_void,
        oldBuffer: *mut ::std::os::raw::c_void,
        oldSize: usize,
        newSize: usize,
        alignment: usize,
    ) -> *mut ::std::os::raw::c_void,
>;
#[doc = " @brief Signature of functions for freeing allocated memory.\n\n @param pUserContext             Context for memory allocation.\n @param buffer                   Address of the memory allocation to be freed."]
pub type PFN_rpsFree = ::std::option::Option<
    unsafe extern "C" fn(
        pUserContext: *mut ::std::os::raw::c_void,
        buffer: *mut ::std::os::raw::c_void,
    ),
>;
#[doc = " @brief Memory allocator interface."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RpsAllocator {
    #[doc = "< Pointer to a function for allocating memory."]
    pub pfnAlloc: PFN_rpsAlloc,
    #[doc = "< Pointer to a function for releasing memory."]
    pub pfnFree: PFN_rpsFree,
    #[doc = "< Pointer to a function for reallocating memory."]
    pub pfnRealloc: PFN_rpsRealloc,
    #[doc = "< Context to be passed to the allocator functions."]
    pub pContext: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_RpsAllocator() {
    const UNINIT: ::std::mem::MaybeUninit<RpsAllocator> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<RpsAllocator>(),
        32usize,
        concat!("Size of: ", stringify!(RpsAllocator))
    );
    assert_eq!(
        ::std::mem::align_of::<RpsAllocator>(),
        8usize,
        concat!("Alignment of ", stringify!(RpsAllocator))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pfnAlloc) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RpsAllocator),
            "::",
            stringify!(pfnAlloc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pfnFree) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(RpsAllocator),
            "::",
            stringify!(pfnFree)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pfnRealloc) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(RpsAllocator),
            "::",
            stringify!(pfnRealloc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pContext) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(RpsAllocator),
            "::",
            stringify!(pContext)
        )
    );
}
#[doc = " @brief Requirements for a single memory allocation."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RpsAllocInfo {
    #[doc = "< Size of the allocation in bytes."]
    pub size: usize,
    #[doc = "< Minimum alignment requirement of the allocation in bytes."]
    pub alignment: usize,
}
#[test]
fn bindgen_test_layout_RpsAllocInfo() {
    const UNINIT: ::std::mem::MaybeUninit<RpsAllocInfo> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<RpsAllocInfo>(),
        16usize,
        concat!("Size of: ", stringify!(RpsAllocInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<RpsAllocInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(RpsAllocInfo))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RpsAllocInfo),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).alignment) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(RpsAllocInfo),
            "::",
            stringify!(alignment)
        )
    );
}
#[doc = " @brief Signature of functions for printing with variadic arguments.\n\n @param pContext                 Context for printing. See <c><i>RpsPrinter</i></c>.\n @param format                   Format string for the print operation matching the C99 specification for printf.\n @param ...                      List of arguments matching the requirements of the contents of <c><i>format</i></c>."]
pub type PFN_rpsPrintf = ::std::option::Option<
    unsafe extern "C" fn(
        pContext: *mut ::std::os::raw::c_void,
        format: *const ::std::os::raw::c_char,
        ...
    ),
>;
#[doc = " @brief Signature of functions for printing with a variable argument list.\n\n @param pContext                 Context for printing. See <c><i>RpsPrinter</i></c>.\n @param format                   Format string for the print operation matching the C99 specification for printf.\n @param vl                       Variable argument list matching the requirements of the contents of\n                                 <c><i>format</i></c>."]
pub type PFN_rpsVPrintf = ::std::option::Option<
    unsafe extern "C" fn(
        pContext: *mut ::std::os::raw::c_void,
        format: *const ::std::os::raw::c_char,
        vl: *mut __va_list_tag,
    ),
>;
#[doc = " @brief Printer interface."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RpsPrinter {
    #[doc = "< Pointer to a function for printing with variadic arguments."]
    pub pfnPrintf: PFN_rpsPrintf,
    #[doc = "< Pointer to a function for printing with a variable argument list."]
    pub pfnVPrintf: PFN_rpsVPrintf,
    #[doc = "< Context to be passed to the print functions."]
    pub pContext: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_RpsPrinter() {
    const UNINIT: ::std::mem::MaybeUninit<RpsPrinter> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<RpsPrinter>(),
        24usize,
        concat!("Size of: ", stringify!(RpsPrinter))
    );
    assert_eq!(
        ::std::mem::align_of::<RpsPrinter>(),
        8usize,
        concat!("Alignment of ", stringify!(RpsPrinter))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pfnPrintf) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RpsPrinter),
            "::",
            stringify!(pfnPrintf)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pfnVPrintf) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(RpsPrinter),
            "::",
            stringify!(pfnVPrintf)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pContext) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(RpsPrinter),
            "::",
            stringify!(pContext)
        )
    );
}
#[doc = " @brief Signature of functions for generating random integers uniformly distributed on the closed interval\n [minValue, maxValue].\n\n @param pContext                 Context for generating random numbers.\n @param minValue                 Minimum output value.\n @param maxValue                 Maximum output value.\n\n @returns                        Generated uniform random value."]
pub type PFN_rpsRandomUniformInt = ::std::option::Option<
    unsafe extern "C" fn(
        pContext: *mut ::std::os::raw::c_void,
        minValue: i32,
        maxValue: i32,
    ) -> i32,
>;
#[doc = " @brief Random number generator interface."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RpsRandomNumberGenerator {
    #[doc = "< Pointer to a function for generating random uniform integers."]
    pub pfnRandomUniformInt: PFN_rpsRandomUniformInt,
    #[doc = "< Context to be passed to the generator function."]
    pub pContext: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_RpsRandomNumberGenerator() {
    const UNINIT: ::std::mem::MaybeUninit<RpsRandomNumberGenerator> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<RpsRandomNumberGenerator>(),
        16usize,
        concat!("Size of: ", stringify!(RpsRandomNumberGenerator))
    );
    assert_eq!(
        ::std::mem::align_of::<RpsRandomNumberGenerator>(),
        8usize,
        concat!("Alignment of ", stringify!(RpsRandomNumberGenerator))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pfnRandomUniformInt) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RpsRandomNumberGenerator),
            "::",
            stringify!(pfnRandomUniformInt)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pContext) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(RpsRandomNumberGenerator),
            "::",
            stringify!(pContext)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RpsDevice_T {
    _unused: [u8; 0],
}
pub type RpsDevice = *mut RpsDevice_T;
#[doc = " @brief Signature of functions for destroying device objects.\n\n @param hDevice      Handle to the <c><i>RpsDevice</i></c> object to destroy."]
pub type PFN_rpsDeviceOnDestroy = ::std::option::Option<unsafe extern "C" fn(hDevice: RpsDevice)>;
#[doc = " @brief Creation parameters for an <c><i>RpsDevice</i></c>."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RpsDeviceCreateInfo {
    #[doc = "< Default allocator to be usable for all memory allocations which do"]
    pub allocator: RpsAllocator,
    #[doc = "< Default printer to be usable for all printing operations which do"]
    pub printer: RpsPrinter,
    #[doc = "< Allocation info for user controlled data which is part of the"]
    pub privateDataAllocInfo: RpsAllocInfo,
    #[doc = "< Pointer to a function for eventual destruction of the device."]
    pub pfnDeviceOnDestroy: PFN_rpsDeviceOnDestroy,
}
#[test]
fn bindgen_test_layout_RpsDeviceCreateInfo() {
    const UNINIT: ::std::mem::MaybeUninit<RpsDeviceCreateInfo> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<RpsDeviceCreateInfo>(),
        80usize,
        concat!("Size of: ", stringify!(RpsDeviceCreateInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<RpsDeviceCreateInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(RpsDeviceCreateInfo))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).allocator) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RpsDeviceCreateInfo),
            "::",
            stringify!(allocator)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).printer) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(RpsDeviceCreateInfo),
            "::",
            stringify!(printer)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).privateDataAllocInfo) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(RpsDeviceCreateInfo),
            "::",
            stringify!(privateDataAllocInfo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pfnDeviceOnDestroy) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(RpsDeviceCreateInfo),
            "::",
            stringify!(pfnDeviceOnDestroy)
        )
    );
}
extern "C" {
    #[doc = " @brief Creates a device object.\n\n @param pCreateInfo                  Pointer to creation parameters. Passing NULL initializes the device with default\n                                     parameters.\n @param pHDevice                     Pointer in which the device object is returned. Must not be NULL.\n\n @returns                            Result code of the operation. See <c><i>RpsResult</i></c> for more info."]
    pub fn rpsDeviceCreate(
        pCreateInfo: *const RpsDeviceCreateInfo,
        pHDevice: *mut RpsDevice,
    ) -> RpsResult;
}
#[doc = " @brief Signature of functions for creating device objects.\n\n @param pCreateInfo                  Pointer to creation parameters. Passing NULL initializes the device with\n                                     default parameters.\n @param pHDevice                     Pointer in which the device object is returned. Must not be NULL.\n\n @returns                            Result code of the operation. See <c><i>RpsResult</i></c> for more info."]
pub type PFN_rpsDeviceCreate = ::std::option::Option<
    unsafe extern "C" fn(
        pCreateInfo: *const RpsDeviceCreateInfo,
        pHDevice: *mut RpsDevice,
    ) -> RpsResult,
>;
extern "C" {
    #[doc = " @brief Destroys an RPS device object.\n\n @param hDevice                      Handle to the <c><i>RpsDevice</i></c>."]
    pub fn rpsDeviceDestroy(hDevice: RpsDevice);
}
extern "C" {
    #[doc = " @brief Accesses user data of an RPS device.\n\n This user is normally not the API user but RPS itself. The device private data is created at device allocation,\n based on privateDataAllocInfo and the device itself will never touch the data until it is destroyed.\n\n @param hDevice                      Handle to the <c><i>RpsDevice</i></c>.\n\n @returns                            Pointer to the user controlled data if a handle != RPS_NULL_HANDLE is passed,\n                                     NULL otherwise."]
    pub fn rpsDeviceGetPrivateData(hDevice: RpsDevice) -> *mut ::std::os::raw::c_void;
}
pub const RpsDiagLogLevel_RPS_DIAG_INFO: RpsDiagLogLevel = 0;
pub const RpsDiagLogLevel_RPS_DIAG_WARNING: RpsDiagLogLevel = 1;
pub const RpsDiagLogLevel_RPS_DIAG_ERROR: RpsDiagLogLevel = 2;
pub const RpsDiagLogLevel_RPS_DIAG_FATAL: RpsDiagLogLevel = 3;
pub const RpsDiagLogLevel_RPS_DIAG_COUNT: RpsDiagLogLevel = 4;
#[doc = " @brief Log levels for diagnostics."]
pub type RpsDiagLogLevel = ::std::os::raw::c_uint;
extern "C" {
    #[doc = " @brief Sets the global debug printer which is used for diagnostic purposes when no device context is available.\n\n @param pPrinter                     Pointer to the printer to set."]
    pub fn rpsSetGlobalDebugPrinter(pPrinter: *const RpsPrinter);
}
extern "C" {
    #[doc = " @brief Gets the global debug printer.\n\n @returns                            Pointer to the current debug printer."]
    pub fn rpsGetGlobalDebugPrinter() -> *const RpsPrinter;
}
extern "C" {
    #[doc = " @brief Sets the minimum diagnostic log level used by the global debug printer.\n\n @param minLogLevel                  Minimum log level to set."]
    pub fn rpsSetGlobalDebugPrinterLogLevel(minLogLevel: RpsDiagLogLevel);
}
#[doc = " @brief Parameters of a type used in the RPS library."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RpsTypeInfo {
    #[doc = "< Size of a single instance in bytes."]
    pub size: u16,
    #[doc = "< Unique identifier of the type."]
    pub id: u16,
}
#[test]
fn bindgen_test_layout_RpsTypeInfo() {
    const UNINIT: ::std::mem::MaybeUninit<RpsTypeInfo> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<RpsTypeInfo>(),
        4usize,
        concat!("Size of: ", stringify!(RpsTypeInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<RpsTypeInfo>(),
        2usize,
        concat!("Alignment of ", stringify!(RpsTypeInfo))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RpsTypeInfo),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).id) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(RpsTypeInfo),
            "::",
            stringify!(id)
        )
    );
}
#[doc = "< General type with specified size."]
pub const RpsBuiltInTypeIds_RPS_TYPE_OPAQUE: RpsBuiltInTypeIds = 0;
#[doc = "< 32-bit boolean type."]
pub const RpsBuiltInTypeIds_RPS_TYPE_BUILT_IN_BOOL: RpsBuiltInTypeIds = 1;
#[doc = "< 8-bit signed integer type."]
pub const RpsBuiltInTypeIds_RPS_TYPE_BUILT_IN_INT8: RpsBuiltInTypeIds = 2;
#[doc = "< 8-bit unsigned integer type."]
pub const RpsBuiltInTypeIds_RPS_TYPE_BUILT_IN_UINT8: RpsBuiltInTypeIds = 3;
#[doc = "< 16-bit signed integer type."]
pub const RpsBuiltInTypeIds_RPS_TYPE_BUILT_IN_INT16: RpsBuiltInTypeIds = 4;
#[doc = "< 16-bit unsigned integer type."]
pub const RpsBuiltInTypeIds_RPS_TYPE_BUILT_IN_UINT16: RpsBuiltInTypeIds = 5;
#[doc = "< 32-bit signed integer type."]
pub const RpsBuiltInTypeIds_RPS_TYPE_BUILT_IN_INT32: RpsBuiltInTypeIds = 6;
#[doc = "< 32-bit unsigned integer type."]
pub const RpsBuiltInTypeIds_RPS_TYPE_BUILT_IN_UINT32: RpsBuiltInTypeIds = 7;
#[doc = "< 64-bit signed integer type."]
pub const RpsBuiltInTypeIds_RPS_TYPE_BUILT_IN_INT64: RpsBuiltInTypeIds = 8;
#[doc = "< 64-bit unsigned integer type."]
pub const RpsBuiltInTypeIds_RPS_TYPE_BUILT_IN_UINT64: RpsBuiltInTypeIds = 9;
#[doc = "< 32-bit floating point type."]
pub const RpsBuiltInTypeIds_RPS_TYPE_BUILT_IN_FLOAT32: RpsBuiltInTypeIds = 10;
#[doc = "< 64-bit floating point type."]
pub const RpsBuiltInTypeIds_RPS_TYPE_BUILT_IN_FLOAT64: RpsBuiltInTypeIds = 11;
#[doc = "< Number of built-in types."]
pub const RpsBuiltInTypeIds_RPS_TYPE_BUILT_IN_MAX_VALUE: RpsBuiltInTypeIds = 12;
#[doc = "< Starting value of the type id range reserved for runtime defined types."]
pub const RpsBuiltInTypeIds_RPS_TYPE_RUNTIME_DEFINED_BEGIN: RpsBuiltInTypeIds = 64;
#[doc = "< Starting value of the type id range reserved for user defined types."]
pub const RpsBuiltInTypeIds_RPS_TYPE_USER_DEFINED_BEGIN: RpsBuiltInTypeIds = 256;
#[doc = " @brief Integer type ids for all built-in types, e.g. integers and floating point types."]
pub type RpsBuiltInTypeIds = ::std::os::raw::c_uint;
#[doc = " @brief Integer type ids for any kind of type."]
pub type RpsTypeId = u32;
#[doc = " @brief Type for render graph node declaration identifiers."]
pub type RpsNodeDeclId = u32;
#[doc = " @brief Type for function parameter identifiers."]
pub type RpsParamId = u32;
#[doc = " @brief Type for render graph node identifiers."]
pub type RpsNodeId = u32;
#[doc = " @brief Transparent handle type for a general render graph variable."]
pub type RpsVariable = *mut ::std::os::raw::c_void;
#[doc = " @brief Transparent handle type for a general, immutable render graph variable."]
pub type RpsConstant = *const ::std::os::raw::c_void;
#[doc = "< No subgraph properties."]
pub const RpsSubgraphFlagBits_RPS_SUBGRAPH_FLAG_NONE: RpsSubgraphFlagBits = 0;
#[doc = "< The subgraph is atomic, so external nodes may not be reorderd"]
pub const RpsSubgraphFlagBits_RPS_SUBGRAPH_FLAG_ATOMIC: RpsSubgraphFlagBits = 1;
#[doc = "< The subgraph is sequential, the relative order of its nodes should be"]
pub const RpsSubgraphFlagBits_RPS_SUBGRAPH_FLAG_SEQUENTIAL: RpsSubgraphFlagBits = 2;
#[doc = " @brief Bitflags for subgraph properties."]
pub type RpsSubgraphFlagBits = ::std::os::raw::c_uint;
#[doc = "  @brief Bitmask type for <c><i>RpsSubgraphFlagBits</i></c>."]
pub type RpsSubgraphFlags = RpsFlags32;
#[doc = " @brief Type for files represented by an RPSL internal integer identifier."]
pub type RpsSourceFileId = RpsIndex32;
#[doc = " @brief Parameters of a source code location."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RpsSourceLocation {
    #[doc = "< Identifier for a file."]
    pub file: RpsSourceFileId,
    #[doc = "< Line number within the file."]
    pub line: u32,
}
#[test]
fn bindgen_test_layout_RpsSourceLocation() {
    const UNINIT: ::std::mem::MaybeUninit<RpsSourceLocation> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<RpsSourceLocation>(),
        8usize,
        concat!("Size of: ", stringify!(RpsSourceLocation))
    );
    assert_eq!(
        ::std::mem::align_of::<RpsSourceLocation>(),
        4usize,
        concat!("Alignment of ", stringify!(RpsSourceLocation))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).file) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RpsSourceLocation),
            "::",
            stringify!(file)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).line) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(RpsSourceLocation),
            "::",
            stringify!(line)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RpsDebugInfo {
    _unused: [u8; 0],
}
#[doc = " Bitmask type for an internal entry flags type."]
pub type RpslEntryCallFlags = RpsFlags32;
#[doc = " @brief Signature of functions for executing RPSL callbacks.\n\n @param numArgs                      Number of arguments used for the callback.\n @param ppArgs                       Pointer to an array of <c><i>const void* const</i></c> with numArgs elements to use for the callback.\n @param flags                        Flags for the type of entry."]
pub type PFN_RpslEntry = ::std::option::Option<
    unsafe extern "C" fn(
        numArgs: u32,
        ppArgs: *const *const ::std::os::raw::c_void,
        flags: RpslEntryCallFlags,
    ),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RpsRpslEntry_T {
    _unused: [u8; 0],
}
#[doc = " @brief Type for RPSL entry point declarations.\n\n An RpslEntry is defined by an export function entry in RPSL and usually statically linked or dynamically loaded into\n the application. It contains the signature info and the function entry point. Users can use the subsequent macros to\n define such an entry point for usage in their application when binding nodes."]
pub type RpsRpslEntry = *const RpsRpslEntry_T;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ___rpsl_runtime_procs {
    _unused: [u8; 0],
}
#[doc = " @brief Signature of functions for initializing RPSL processes from a DLL.\n\n @param pProcs\n @param sizeofProcs\n\n returns"]
pub type PFN_rpslDynLibInit = ::std::option::Option<
    unsafe extern "C" fn(pProcs: *const ___rpsl_runtime_procs, sizeofProcs: u32) -> i32,
>;
extern "C" {
    #[doc = " @brief Initializes an RPSL DLL module.\n\n The user can create an RPSL DLL module by linking rpsl code with rps_rpsl_host_dll.c. After this DLL is loaded, the\n user must get the address of the `___rps_dyn_lib_init` entry point and call rpsRpslDynamicLibraryInit with this\n entry point address as the parameter. This initializes the RPSL runtime callbacks for the DLL.\n\n @param pfn_dynLibInit               Address of \"___rps_dyn_lib_init\" entry point of the RPSL DLL module.\n\n\n @returns                            Result code of the operation. See <c><i>RpsResult</i></c> for more info."]
    pub fn rpsRpslDynamicLibraryInit(pfn_dynLibInit: PFN_rpslDynLibInit) -> RpsResult;
}
extern "C" {
    #[doc = " @brief Generates an RPSL entry name.\n\n Generates the name from the given module and entry names, so that it matches the symbol name generated by the RPSL\n compiler for this entry. This name can be used to retrieve the RpslEntry address from a dynamically loaded library\n using e.g. GetProcAddress or dlsym.\n\n @param pBuf                         Pointer in which the name is returned. Must not be NULL.\n @param bufSize                      Size of the buffer in bytes.\n @param moduleName                   Null terminated string with the name of the module.\n @param entryName                    Null terminated string with the name of the entry point.\n\n @returns                            Pointer to the buffer if its size is large enough, otherwise NULL."]
    pub fn rpsMakeRpslEntryName(
        pBuf: *mut ::std::os::raw::c_char,
        bufSize: usize,
        moduleName: *const ::std::os::raw::c_char,
        entryName: *const ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RpsJITModule_T {
    _unused: [u8; 0],
}
pub type RpsJITModule = *mut RpsJITModule_T;
#[doc = " @brief Signature of functions for initializing the JIT compiler.\n\n @param argc                         Number of program arguments.\n @param args                         Pointer to an array of <c><i>const char*</i></c> with argc elements. Must not be NULL for argc != 0.\n\n @returns                            Result code of the operation. See <c><i>RpsResult</i></c> for more info."]
pub type PFN_RpsJITStartup = ::std::option::Option<
    unsafe extern "C" fn(argc: i32, args: *mut *const ::std::os::raw::c_char) -> i32,
>;
#[doc = " @brief Signature of functions for shutting down the JIT compiler."]
pub type PFN_RpsJITShutdown = ::std::option::Option<unsafe extern "C" fn()>;
#[doc = " @brief Signature of functions for loading RPSL modules with the JIT compiler.\n\n @param name                         Null terminated string with the name of the module.\n @param pJITModule                   Pointer in which a handle to the loaded module is returned.\n\n @returns                            Result code of the operation. See <c><i>RpsResult</i></c> for more info."]
pub type PFN_RpsJITLoad = ::std::option::Option<
    unsafe extern "C" fn(name: *const ::std::os::raw::c_char, pJITModule: *mut RpsJITModule) -> i32,
>;
#[doc = " @brief Signature of functions for unloading a JIT loaded module.\n\n @param hJITModule                   Handle to the JIT module."]
pub type PFN_RpsJITUnload = ::std::option::Option<unsafe extern "C" fn(hJITModule: RpsJITModule)>;
#[doc = " @brief Signature of functions for getting an RPSL entry point from a module.\n\n @param hJITModule                   Handle to the RPSL module. Must not be RPS_NULL_HANDLE.\n @param symbolName                   Null terminated string with the name of the entry point.\n @param pEntryPoint                  Pointer to the entry point as a 64-bit unsigned integer.\n\n @returns                            Result code of the operation. See <c><i>RpsResult</i></c> for more info."]
pub type PFN_RpsJITGetEntryPoint = ::std::option::Option<
    unsafe extern "C" fn(
        hJITModule: RpsJITModule,
        symbolName: *const ::std::os::raw::c_char,
        pEntryPoint: *mut u64,
    ) -> i32,
>;
extern "C" {
    #[link_name = "\u{1}_Z10rpsDiagLog15RpsDiagLogLevelPKcz"]
    pub fn rpsDiagLog(logLevel: RpsDiagLogLevel, fmt: *const ::std::os::raw::c_char, ...);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rps_ArrayRef<T, SizeType> {
    pub m_pData: *mut T,
    pub m_Size: SizeType,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<T>>,
    pub _phantom_1: ::std::marker::PhantomData<::std::cell::UnsafeCell<SizeType>>,
}
pub type rps_ArrayRef_value_type<T> = T;
pub type rps_ArrayRef_iterator<T> = *mut T;
pub type rps_ArrayRef_const_iterator<T> = *const T;
pub type rps_ArrayRef_reverse_iterator = u8;
pub type rps_ArrayRef_const_reverse_iterator = u8;
#[repr(C)]
#[derive(Debug)]
pub struct rps_Vector<T, AllocatorT> {
    pub m_Allocator: AllocatorT,
    pub m_pArray: *mut T,
    pub m_Count: usize,
    pub m_Capacity: usize,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<T>>,
    pub _phantom_1: ::std::marker::PhantomData<::std::cell::UnsafeCell<AllocatorT>>,
}
pub type rps_Vector_value_type<T> = T;
pub type rps_Vector_iterator<T> = *mut T;
pub type rps_Vector_const_iterator<T> = *const T;
pub type rps_Vector_reverse_iterator = u8;
pub type rps_Vector_const_reverse_iterator = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rps_StrRef {
    pub str_: *const ::std::os::raw::c_char,
    pub len: usize,
}
#[test]
fn bindgen_test_layout_rps_StrRef() {
    const UNINIT: ::std::mem::MaybeUninit<rps_StrRef> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rps_StrRef>(),
        16usize,
        concat!("Size of: ", stringify!(rps_StrRef))
    );
    assert_eq!(
        ::std::mem::align_of::<rps_StrRef>(),
        8usize,
        concat!("Alignment of ", stringify!(rps_StrRef))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).str_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rps_StrRef),
            "::",
            stringify!(str_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).len) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rps_StrRef),
            "::",
            stringify!(len)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rps_Span<SizeType> {
    pub m_offset: SizeType,
    pub m_count: SizeType,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<SizeType>>,
}
pub type rps_Span_size_type<SizeType> = SizeType;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rps_SpanPool {
    pub _address: u8,
}
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Copy, Clone)]
pub struct rps_Arena {
    pub _bindgen_opaque_blob: [u64; 9usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rps_Arena_Block {
    pub pNext: *mut rps_Arena_Block,
    pub size: usize,
}
#[test]
fn bindgen_test_layout_rps_Arena_Block() {
    const UNINIT: ::std::mem::MaybeUninit<rps_Arena_Block> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rps_Arena_Block>(),
        16usize,
        concat!("Size of: ", stringify!(rps_Arena_Block))
    );
    assert_eq!(
        ::std::mem::align_of::<rps_Arena_Block>(),
        8usize,
        concat!("Alignment of ", stringify!(rps_Arena_Block))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rps_Arena_Block),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rps_Arena_Block),
            "::",
            stringify!(size)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rps_Arena_CheckPoint {
    pub pBlock: *mut ::std::os::raw::c_void,
    pub remainingSize: usize,
}
#[test]
fn bindgen_test_layout_rps_Arena_CheckPoint() {
    const UNINIT: ::std::mem::MaybeUninit<rps_Arena_CheckPoint> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rps_Arena_CheckPoint>(),
        16usize,
        concat!("Size of: ", stringify!(rps_Arena_CheckPoint))
    );
    assert_eq!(
        ::std::mem::align_of::<rps_Arena_CheckPoint>(),
        8usize,
        concat!("Alignment of ", stringify!(rps_Arena_CheckPoint))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pBlock) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rps_Arena_CheckPoint),
            "::",
            stringify!(pBlock)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).remainingSize) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rps_Arena_CheckPoint),
            "::",
            stringify!(remainingSize)
        )
    );
}
#[test]
fn bindgen_test_layout_rps_Arena() {
    assert_eq!(
        ::std::mem::size_of::<rps_Arena>(),
        72usize,
        concat!("Size of: ", stringify!(rps_Arena))
    );
    assert_eq!(
        ::std::mem::align_of::<rps_Arena>(),
        8usize,
        concat!("Alignment of ", stringify!(rps_Arena))
    );
}
pub const rps_Arena_DEFAULT_BLOCK_SIZE: usize = 65500;
pub const rps_Arena_DEFAULT_ALIGNMENT: usize = 16;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rps_ArenaAllocator {
    pub m_pArena: *mut rps_Arena,
}
pub type rps_ArenaAllocator_value_type<T> = T;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rps_GeneralAllocator {
    pub m_pCallbacks: *const RpsAllocator,
}
pub type rps_GeneralAllocator_value_type<T> = T;
#[repr(C)]
#[repr(align(4))]
#[derive(Copy, Clone)]
pub union rps_details_FreeListPoolSlot {
    pub _bindgen_opaque_blob: u32,
}
impl ::std::fmt::Debug for rps_details_FreeListPoolSlot {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(f, "rps_details_FreeListPoolSlot {{ opaque }}")
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rps_FreeListPool {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rps_TResult<T> {
    pub code: RpsResult,
    pub data: T,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<T>>,
}
#[repr(C)]
#[derive(Debug)]
pub struct rps_Device {
    pub m_allocator: RpsAllocator,
    pub m_printer: RpsPrinter,
    pub m_pfnOnDestory: PFN_rpsDeviceOnDestroy,
    pub m_pPrivateData: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_rps_Device() {
    const UNINIT: ::std::mem::MaybeUninit<rps_Device> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rps_Device>(),
        72usize,
        concat!("Size of: ", stringify!(rps_Device))
    );
    assert_eq!(
        ::std::mem::align_of::<rps_Device>(),
        8usize,
        concat!("Alignment of ", stringify!(rps_Device))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_allocator) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rps_Device),
            "::",
            stringify!(m_allocator)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_printer) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(rps_Device),
            "::",
            stringify!(m_printer)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_pfnOnDestory) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(rps_Device),
            "::",
            stringify!(m_pfnOnDestory)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_pPrivateData) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(rps_Device),
            "::",
            stringify!(m_pPrivateData)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN3rps6Device6CreateEPK19RpsDeviceCreateInfoPPS0_"]
    pub fn rps_Device_Create(
        pCreateInfo: *const RpsDeviceCreateInfo,
        ppDevice: *mut *mut rps_Device,
    ) -> RpsResult;
}
extern "C" {
    #[link_name = "\u{1}_ZN3rps6Device7DestroyEv"]
    pub fn rps_Device_Destroy(this: *mut rps_Device);
}
impl rps_Device {
    #[inline]
    pub unsafe fn Create(
        pCreateInfo: *const RpsDeviceCreateInfo,
        ppDevice: *mut *mut rps_Device,
    ) -> RpsResult {
        rps_Device_Create(pCreateInfo, ppDevice)
    }
    #[inline]
    pub unsafe fn Destroy(&mut self) {
        rps_Device_Destroy(self)
    }
}
pub type rps_NodeId = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rps_Edge {
    pub src: rps_NodeId,
    pub dst: rps_NodeId,
}
#[test]
fn bindgen_test_layout_rps_Edge() {
    const UNINIT: ::std::mem::MaybeUninit<rps_Edge> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rps_Edge>(),
        8usize,
        concat!("Size of: ", stringify!(rps_Edge))
    );
    assert_eq!(
        ::std::mem::align_of::<rps_Edge>(),
        4usize,
        concat!("Alignment of ", stringify!(rps_Edge))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).src) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rps_Edge),
            "::",
            stringify!(src)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dst) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rps_Edge),
            "::",
            stringify!(dst)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rps_Node {
    pub inEdges: rps_Span<::std::os::raw::c_uint>,
    pub outEdges: rps_Span<::std::os::raw::c_uint>,
    pub cmdId: i32,
    pub subgraph: u32,
    pub barrierScope: u32,
}
#[test]
fn bindgen_test_layout_rps_Node() {
    const UNINIT: ::std::mem::MaybeUninit<rps_Node> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rps_Node>(),
        28usize,
        concat!("Size of: ", stringify!(rps_Node))
    );
    assert_eq!(
        ::std::mem::align_of::<rps_Node>(),
        4usize,
        concat!("Alignment of ", stringify!(rps_Node))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).inEdges) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rps_Node),
            "::",
            stringify!(inEdges)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).outEdges) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rps_Node),
            "::",
            stringify!(outEdges)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cmdId) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rps_Node),
            "::",
            stringify!(cmdId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).subgraph) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(rps_Node),
            "::",
            stringify!(subgraph)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).barrierScope) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rps_Node),
            "::",
            stringify!(barrierScope)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rps_Subgraph {
    pub parentSubgraph: u32,
    pub flags: RpsSubgraphFlags,
    pub beginNode: rps_NodeId,
    pub endNode: rps_NodeId,
}
#[test]
fn bindgen_test_layout_rps_Subgraph() {
    const UNINIT: ::std::mem::MaybeUninit<rps_Subgraph> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rps_Subgraph>(),
        16usize,
        concat!("Size of: ", stringify!(rps_Subgraph))
    );
    assert_eq!(
        ::std::mem::align_of::<rps_Subgraph>(),
        4usize,
        concat!("Alignment of ", stringify!(rps_Subgraph))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parentSubgraph) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rps_Subgraph),
            "::",
            stringify!(parentSubgraph)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rps_Subgraph),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).beginNode) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rps_Subgraph),
            "::",
            stringify!(beginNode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).endNode) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(rps_Subgraph),
            "::",
            stringify!(endNode)
        )
    );
}
#[repr(C)]
#[derive(Debug)]
pub struct rps_Graph {
    pub m_nodes: rps_Vector<rps_Node, rps_ArenaAllocator>,
    pub m_edges: rps_Vector<rps_Edge, rps_ArenaAllocator>,
    pub m_subgraphs: rps_Vector<rps_Subgraph, rps_ArenaAllocator>,
    pub m_edgeListPool: [u64; 17usize],
}
#[test]
fn bindgen_test_layout_rps_Graph() {
    const UNINIT: ::std::mem::MaybeUninit<rps_Graph> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rps_Graph>(),
        232usize,
        concat!("Size of: ", stringify!(rps_Graph))
    );
    assert_eq!(
        ::std::mem::align_of::<rps_Graph>(),
        8usize,
        concat!("Alignment of ", stringify!(rps_Graph))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_nodes) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rps_Graph),
            "::",
            stringify!(m_nodes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_edges) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(rps_Graph),
            "::",
            stringify!(m_edges)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_subgraphs) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(rps_Graph),
            "::",
            stringify!(m_subgraphs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_edgeListPool) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(rps_Graph),
            "::",
            stringify!(m_edgeListPool)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN3rps5Graph7AddNodeEi"]
    pub fn rps_Graph_AddNode(this: *mut rps_Graph, cmdId: i32) -> rps_NodeId;
}
extern "C" {
    #[link_name = "\u{1}_ZN3rps5Graph9CloneNodeEji"]
    pub fn rps_Graph_CloneNode(this: *mut rps_Graph, srcNode: rps_NodeId, cmdId: i32)
        -> rps_NodeId;
}
extern "C" {
    #[link_name = "\u{1}_ZNK3rps5Graph16IsParentSubgraphEjj"]
    pub fn rps_Graph_IsParentSubgraph(
        this: *const rps_Graph,
        parentSubgraphId: u32,
        childSubgraphId: u32,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN3rps5Graph5ResetEv"]
    pub fn rps_Graph_Reset(this: *mut rps_Graph);
}
extern "C" {
    #[link_name = "\u{1}_ZN3rps5GraphC1ERKNS_6DeviceERNS_5ArenaE"]
    pub fn rps_Graph_Graph(this: *mut rps_Graph, device: *const rps_Device, arena: *mut rps_Arena);
}
impl rps_Graph {
    #[inline]
    pub unsafe fn AddNode(&mut self, cmdId: i32) -> rps_NodeId {
        rps_Graph_AddNode(self, cmdId)
    }
    #[inline]
    pub unsafe fn CloneNode(&mut self, srcNode: rps_NodeId, cmdId: i32) -> rps_NodeId {
        rps_Graph_CloneNode(self, srcNode, cmdId)
    }
    #[inline]
    pub unsafe fn IsParentSubgraph(&self, parentSubgraphId: u32, childSubgraphId: u32) -> bool {
        rps_Graph_IsParentSubgraph(self, parentSubgraphId, childSubgraphId)
    }
    #[inline]
    pub unsafe fn Reset(&mut self) {
        rps_Graph_Reset(self)
    }
    #[inline]
    pub unsafe fn new(device: *const rps_Device, arena: *mut rps_Arena) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        rps_Graph_Graph(__bindgen_tmp.as_mut_ptr(), device, arena);
        __bindgen_tmp.assume_init()
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rps_PersistentIdGenerator_BlockInfo {
    pub numResources: *mut u32,
    pub localIndex: u32,
    pub numChildren: u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rps_PersistentIdGenerator_BlockInstance {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    pub nextIteration: u32,
    pub offsets: *mut u32,
}
impl rps_PersistentIdGenerator_BlockInstance {
    #[inline]
    pub fn isReached(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_isReached(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn blockId(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 31u8) as u32) }
    }
    #[inline]
    pub fn set_blockId(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 31u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(isReached: u32, blockId: u32) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let isReached: u32 = unsafe { ::std::mem::transmute(isReached) };
            isReached as u64
        });
        __bindgen_bitfield_unit.set(1usize, 31u8, {
            let blockId: u32 = unsafe { ::std::mem::transmute(blockId) };
            blockId as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " @brief C++ helper type for RpsAccessAttr.\n\n @ingroup RpsAccessAttr"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rps_AccessAttr {
    pub _base: RpsAccessAttr,
}
#[test]
fn bindgen_test_layout_rps_AccessAttr() {
    assert_eq!(
        ::std::mem::size_of::<rps_AccessAttr>(),
        8usize,
        concat!("Size of: ", stringify!(rps_AccessAttr))
    );
    assert_eq!(
        ::std::mem::align_of::<rps_AccessAttr>(),
        4usize,
        concat!("Alignment of ", stringify!(rps_AccessAttr))
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK3rps10AccessAttr5PrintERK10RpsPrinter"]
    pub fn rps_AccessAttr_Print(this: *const rps_AccessAttr, printer: *const RpsPrinter);
}
impl rps_AccessAttr {
    #[inline]
    pub unsafe fn Print(&self, printer: *const RpsPrinter) {
        rps_AccessAttr_Print(self, printer)
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rps_Cmd {
    pub nodeDeclId: RpsNodeDeclId,
    pub programInstanceId: u32,
    pub tag: u32,
    pub args: rps_ArrayRef<RpsVariable, ::std::os::raw::c_ulong>,
    pub callback: RpsCmdCallback,
}
#[test]
fn bindgen_test_layout_rps_Cmd() {
    const UNINIT: ::std::mem::MaybeUninit<rps_Cmd> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rps_Cmd>(),
        56usize,
        concat!("Size of: ", stringify!(rps_Cmd))
    );
    assert_eq!(
        ::std::mem::align_of::<rps_Cmd>(),
        8usize,
        concat!("Alignment of ", stringify!(rps_Cmd))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nodeDeclId) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rps_Cmd),
            "::",
            stringify!(nodeDeclId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).programInstanceId) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rps_Cmd),
            "::",
            stringify!(programInstanceId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tag) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rps_Cmd),
            "::",
            stringify!(tag)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).args) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rps_Cmd),
            "::",
            stringify!(args)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).callback) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(rps_Cmd),
            "::",
            stringify!(callback)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rps_NodeDependency {
    pub before: RpsNodeId,
    pub after: RpsNodeId,
}
#[test]
fn bindgen_test_layout_rps_NodeDependency() {
    const UNINIT: ::std::mem::MaybeUninit<rps_NodeDependency> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rps_NodeDependency>(),
        8usize,
        concat!("Size of: ", stringify!(rps_NodeDependency))
    );
    assert_eq!(
        ::std::mem::align_of::<rps_NodeDependency>(),
        4usize,
        concat!("Alignment of ", stringify!(rps_NodeDependency))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).before) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rps_NodeDependency),
            "::",
            stringify!(before)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).after) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rps_NodeDependency),
            "::",
            stringify!(after)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rps_ResourceDecl {
    pub desc: RpsVariable,
    pub name: rps_StrRef,
}
#[test]
fn bindgen_test_layout_rps_ResourceDecl() {
    const UNINIT: ::std::mem::MaybeUninit<rps_ResourceDecl> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rps_ResourceDecl>(),
        24usize,
        concat!("Size of: ", stringify!(rps_ResourceDecl))
    );
    assert_eq!(
        ::std::mem::align_of::<rps_ResourceDecl>(),
        8usize,
        concat!("Alignment of ", stringify!(rps_ResourceDecl))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).desc) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rps_ResourceDecl),
            "::",
            stringify!(desc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rps_ResourceDecl),
            "::",
            stringify!(name)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rps_ResourceDescPacked {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    pub __bindgen_anon_1: rps_ResourceDescPacked__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rps_ResourceDescPacked__bindgen_ty_1 {
    pub image: rps_ResourceDescPacked__bindgen_ty_1__bindgen_ty_1,
    pub buffer: rps_ResourceDescPacked__bindgen_ty_1__bindgen_ty_2,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rps_ResourceDescPacked__bindgen_ty_1__bindgen_ty_1 {
    #[doc = "< The width of an image, or low 32 bit of the byte size of a buffer."]
    pub width: u32,
    #[doc = "< The height of an image, or high 32 bit of the byte size of a buffer."]
    pub height: u32,
    pub __bindgen_anon_1: rps_ResourceDescPacked__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 3usize]>,
    pub __bindgen_padding_0: u8,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rps_ResourceDescPacked__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
    #[doc = "< The depth of an 3D image."]
    pub depth: u32,
    #[doc = "< The number of array layers for an non-3D image."]
    pub arrayLayers: u32,
}
#[test]
fn bindgen_test_layout_rps_ResourceDescPacked__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<
        rps_ResourceDescPacked__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rps_ResourceDescPacked__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(rps_ResourceDescPacked__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<rps_ResourceDescPacked__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(rps_ResourceDescPacked__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).depth) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rps_ResourceDescPacked__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(depth)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).arrayLayers) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rps_ResourceDescPacked__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(arrayLayers)
        )
    );
}
impl ::std::fmt::Debug for rps_ResourceDescPacked__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(
            f,
            "rps_ResourceDescPacked__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {{ union }}"
        )
    }
}
#[test]
fn bindgen_test_layout_rps_ResourceDescPacked__bindgen_ty_1__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<rps_ResourceDescPacked__bindgen_ty_1__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rps_ResourceDescPacked__bindgen_ty_1__bindgen_ty_1>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(rps_ResourceDescPacked__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<rps_ResourceDescPacked__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(rps_ResourceDescPacked__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).width) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rps_ResourceDescPacked__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).height) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rps_ResourceDescPacked__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(height)
        )
    );
}
impl ::std::fmt::Debug for rps_ResourceDescPacked__bindgen_ty_1__bindgen_ty_1 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write ! (f , "rps_ResourceDescPacked__bindgen_ty_1__bindgen_ty_1 {{ __bindgen_anon_1: {:?}, mipLevels : {:?}, format : {:?}, sampleCount : {:?} }}" , self . __bindgen_anon_1 , self . mipLevels () , self . format () , self . sampleCount ())
    }
}
impl rps_ResourceDescPacked__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn mipLevels(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_mipLevels(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn format(&self) -> RpsFormat {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_format(&mut self, val: RpsFormat) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn sampleCount(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_sampleCount(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        mipLevels: u32,
        format: RpsFormat,
        sampleCount: u32,
    ) -> __BindgenBitfieldUnit<[u8; 3usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 3usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let mipLevels: u32 = unsafe { ::std::mem::transmute(mipLevels) };
            mipLevels as u64
        });
        __bindgen_bitfield_unit.set(8usize, 8u8, {
            let format: u32 = unsafe { ::std::mem::transmute(format) };
            format as u64
        });
        __bindgen_bitfield_unit.set(16usize, 8u8, {
            let sampleCount: u32 = unsafe { ::std::mem::transmute(sampleCount) };
            sampleCount as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rps_ResourceDescPacked__bindgen_ty_1__bindgen_ty_2 {
    pub sizeInBytesLo: u32,
    pub sizeInBytesHi: u32,
}
#[test]
fn bindgen_test_layout_rps_ResourceDescPacked__bindgen_ty_1__bindgen_ty_2() {
    const UNINIT: ::std::mem::MaybeUninit<rps_ResourceDescPacked__bindgen_ty_1__bindgen_ty_2> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rps_ResourceDescPacked__bindgen_ty_1__bindgen_ty_2>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(rps_ResourceDescPacked__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<rps_ResourceDescPacked__bindgen_ty_1__bindgen_ty_2>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(rps_ResourceDescPacked__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sizeInBytesLo) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rps_ResourceDescPacked__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(sizeInBytesLo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sizeInBytesHi) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rps_ResourceDescPacked__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(sizeInBytesHi)
        )
    );
}
#[test]
fn bindgen_test_layout_rps_ResourceDescPacked__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<rps_ResourceDescPacked__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rps_ResourceDescPacked__bindgen_ty_1>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(rps_ResourceDescPacked__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<rps_ResourceDescPacked__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(rps_ResourceDescPacked__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).image) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rps_ResourceDescPacked__bindgen_ty_1),
            "::",
            stringify!(image)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).buffer) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rps_ResourceDescPacked__bindgen_ty_1),
            "::",
            stringify!(buffer)
        )
    );
}
impl ::std::fmt::Debug for rps_ResourceDescPacked__bindgen_ty_1 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(f, "rps_ResourceDescPacked__bindgen_ty_1 {{ union }}")
    }
}
#[test]
fn bindgen_test_layout_rps_ResourceDescPacked() {
    assert_eq!(
        ::std::mem::size_of::<rps_ResourceDescPacked>(),
        20usize,
        concat!("Size of: ", stringify!(rps_ResourceDescPacked))
    );
    assert_eq!(
        ::std::mem::align_of::<rps_ResourceDescPacked>(),
        4usize,
        concat!("Alignment of ", stringify!(rps_ResourceDescPacked))
    );
}
impl ::std::fmt::Debug for rps_ResourceDescPacked {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write ! (f , "rps_ResourceDescPacked {{ type : {:?}, temporalLayers : {:?}, flags : {:?}, __bindgen_anon_1: {:?} }}" , self . type_ () , self . temporalLayers () , self . flags () , self . __bindgen_anon_1)
    }
}
impl rps_ResourceDescPacked {
    #[inline]
    pub fn type_(&self) -> RpsResourceType {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_type(&mut self, val: RpsResourceType) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn temporalLayers(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_temporalLayers(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn flags(&self) -> RpsResourceFlags {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_flags(&mut self, val: RpsResourceFlags) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        type_: RpsResourceType,
        temporalLayers: u32,
        flags: RpsResourceFlags,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let type_: u32 = unsafe { ::std::mem::transmute(type_) };
            type_ as u64
        });
        __bindgen_bitfield_unit.set(8usize, 8u8, {
            let temporalLayers: u32 = unsafe { ::std::mem::transmute(temporalLayers) };
            temporalLayers as u64
        });
        __bindgen_bitfield_unit.set(16usize, 16u8, {
            let flags: u32 = unsafe { ::std::mem::transmute(flags) };
            flags as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct rps_SubresourceRangePacked {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
}
pub const rps_SubresourceRangePacked_MAX_CLIP_COMPLEMENTS:
    rps_SubresourceRangePacked__bindgen_ty_1 = 5;
pub type rps_SubresourceRangePacked__bindgen_ty_1 = ::std::os::raw::c_uint;
#[test]
fn bindgen_test_layout_rps_SubresourceRangePacked() {
    assert_eq!(
        ::std::mem::size_of::<rps_SubresourceRangePacked>(),
        8usize,
        concat!("Size of: ", stringify!(rps_SubresourceRangePacked))
    );
    assert_eq!(
        ::std::mem::align_of::<rps_SubresourceRangePacked>(),
        4usize,
        concat!("Alignment of ", stringify!(rps_SubresourceRangePacked))
    );
}
impl rps_SubresourceRangePacked {
    #[inline]
    pub fn aspectMask(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_aspectMask(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn baseArrayLayer(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 24u8) as u32) }
    }
    #[inline]
    pub fn set_baseArrayLayer(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 24u8, val as u64)
        }
    }
    #[inline]
    pub fn arrayLayerEnd(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(32usize, 22u8) as u32) }
    }
    #[inline]
    pub fn set_arrayLayerEnd(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(32usize, 22u8, val as u64)
        }
    }
    #[inline]
    pub fn baseMipLevel(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(54usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_baseMipLevel(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(54usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn mipLevelEnd(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(59usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_mipLevelEnd(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(59usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        aspectMask: u32,
        baseArrayLayer: u32,
        arrayLayerEnd: u32,
        baseMipLevel: u32,
        mipLevelEnd: u32,
    ) -> __BindgenBitfieldUnit<[u8; 8usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let aspectMask: u32 = unsafe { ::std::mem::transmute(aspectMask) };
            aspectMask as u64
        });
        __bindgen_bitfield_unit.set(8usize, 24u8, {
            let baseArrayLayer: u32 = unsafe { ::std::mem::transmute(baseArrayLayer) };
            baseArrayLayer as u64
        });
        __bindgen_bitfield_unit.set(32usize, 22u8, {
            let arrayLayerEnd: u32 = unsafe { ::std::mem::transmute(arrayLayerEnd) };
            arrayLayerEnd as u64
        });
        __bindgen_bitfield_unit.set(54usize, 5u8, {
            let baseMipLevel: u32 = unsafe { ::std::mem::transmute(baseMipLevel) };
            baseMipLevel as u64
        });
        __bindgen_bitfield_unit.set(59usize, 5u8, {
            let mipLevelEnd: u32 = unsafe { ::std::mem::transmute(mipLevelEnd) };
            mipLevelEnd as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rps_ParamDecl {
    pub name: rps_StrRef,
    pub typeInfo: RpsTypeInfo,
    pub numElements: u32,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    pub access: RpsAccessAttr,
}
#[test]
fn bindgen_test_layout_rps_ParamDecl() {
    const UNINIT: ::std::mem::MaybeUninit<rps_ParamDecl> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rps_ParamDecl>(),
        40usize,
        concat!("Size of: ", stringify!(rps_ParamDecl))
    );
    assert_eq!(
        ::std::mem::align_of::<rps_ParamDecl>(),
        8usize,
        concat!("Alignment of ", stringify!(rps_ParamDecl))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rps_ParamDecl),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).typeInfo) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rps_ParamDecl),
            "::",
            stringify!(typeInfo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).numElements) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(rps_ParamDecl),
            "::",
            stringify!(numElements)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).access) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(rps_ParamDecl),
            "::",
            stringify!(access)
        )
    );
}
impl rps_ParamDecl {
    #[inline]
    pub fn flags(&self) -> RpsParameterFlags {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 30u8) as u32) }
    }
    #[inline]
    pub fn set_flags(&mut self, val: RpsParameterFlags) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 30u8, val as u64)
        }
    }
    #[inline]
    pub fn isArray(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(30usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_isArray(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(30usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn isUnboundedArray(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_isUnboundedArray(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        flags: RpsParameterFlags,
        isArray: u32,
        isUnboundedArray: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 30u8, {
            let flags: u32 = unsafe { ::std::mem::transmute(flags) };
            flags as u64
        });
        __bindgen_bitfield_unit.set(30usize, 1u8, {
            let isArray: u32 = unsafe { ::std::mem::transmute(isArray) };
            isArray as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let isUnboundedArray: u32 = unsafe { ::std::mem::transmute(isUnboundedArray) };
            isUnboundedArray as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Copy, Clone)]
pub struct rps_NodeParamDecl {
    pub _bindgen_opaque_blob: [u64; 6usize],
}
#[test]
fn bindgen_test_layout_rps_NodeParamDecl() {
    assert_eq!(
        ::std::mem::size_of::<rps_NodeParamDecl>(),
        48usize,
        concat!("Size of: ", stringify!(rps_NodeParamDecl))
    );
    assert_eq!(
        ::std::mem::align_of::<rps_NodeParamDecl>(),
        8usize,
        concat!("Alignment of ", stringify!(rps_NodeParamDecl))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rps_ParamSemanticsKindInfo {
    pub semantic: RpsSemantic,
    pub params: rps_Span<::std::os::raw::c_uint>,
}
#[test]
fn bindgen_test_layout_rps_ParamSemanticsKindInfo() {
    const UNINIT: ::std::mem::MaybeUninit<rps_ParamSemanticsKindInfo> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rps_ParamSemanticsKindInfo>(),
        12usize,
        concat!("Size of: ", stringify!(rps_ParamSemanticsKindInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<rps_ParamSemanticsKindInfo>(),
        4usize,
        concat!("Alignment of ", stringify!(rps_ParamSemanticsKindInfo))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).semantic) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rps_ParamSemanticsKindInfo),
            "::",
            stringify!(semantic)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).params) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rps_ParamSemanticsKindInfo),
            "::",
            stringify!(params)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rps_ParamElementRef {
    pub paramId: RpsParamId,
    pub arrayOffset: u32,
}
#[test]
fn bindgen_test_layout_rps_ParamElementRef() {
    const UNINIT: ::std::mem::MaybeUninit<rps_ParamElementRef> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rps_ParamElementRef>(),
        8usize,
        concat!("Size of: ", stringify!(rps_ParamElementRef))
    );
    assert_eq!(
        ::std::mem::align_of::<rps_ParamElementRef>(),
        4usize,
        concat!("Alignment of ", stringify!(rps_ParamElementRef))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).paramId) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rps_ParamElementRef),
            "::",
            stringify!(paramId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).arrayOffset) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rps_ParamElementRef),
            "::",
            stringify!(arrayOffset)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rps_NodeDeclRenderPassInfo {
    pub paramRefs: *mut rps_ParamElementRef,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
}
#[test]
fn bindgen_test_layout_rps_NodeDeclRenderPassInfo() {
    const UNINIT: ::std::mem::MaybeUninit<rps_NodeDeclRenderPassInfo> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rps_NodeDeclRenderPassInfo>(),
        16usize,
        concat!("Size of: ", stringify!(rps_NodeDeclRenderPassInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<rps_NodeDeclRenderPassInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(rps_NodeDeclRenderPassInfo))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).paramRefs) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rps_NodeDeclRenderPassInfo),
            "::",
            stringify!(paramRefs)
        )
    );
}
impl rps_NodeDeclRenderPassInfo {
    #[inline]
    pub fn numParamRefs(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_numParamRefs(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn renderTargetsMask(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_renderTargetsMask(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn resolveTargetsMask(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_resolveTargetsMask(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn renderTargetClearMask(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(24usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_renderTargetClearMask(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(24usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn depthStencilTargetMask(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(32usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_depthStencilTargetMask(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(32usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn clearDepth(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(33usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_clearDepth(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(33usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn clearStencil(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(34usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_clearStencil(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(34usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn resolveDepthStencil(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(35usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_resolveDepthStencil(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(35usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn resolveTargetRefs(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(36usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_resolveTargetRefs(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(36usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn clearOnly(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(40usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_clearOnly(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(40usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn clearValueRefs(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(41usize, 7u8) as u32) }
    }
    #[inline]
    pub fn set_clearValueRefs(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(41usize, 7u8, val as u64)
        }
    }
    #[inline]
    pub fn viewportRefs(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(48usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_viewportRefs(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(48usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn scissorRectRefs(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(56usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_scissorRectRefs(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(56usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        numParamRefs: u32,
        renderTargetsMask: u32,
        resolveTargetsMask: u32,
        renderTargetClearMask: u32,
        depthStencilTargetMask: u32,
        clearDepth: u32,
        clearStencil: u32,
        resolveDepthStencil: u32,
        resolveTargetRefs: u32,
        clearOnly: u32,
        clearValueRefs: u32,
        viewportRefs: u32,
        scissorRectRefs: u32,
    ) -> __BindgenBitfieldUnit<[u8; 8usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let numParamRefs: u32 = unsafe { ::std::mem::transmute(numParamRefs) };
            numParamRefs as u64
        });
        __bindgen_bitfield_unit.set(8usize, 8u8, {
            let renderTargetsMask: u32 = unsafe { ::std::mem::transmute(renderTargetsMask) };
            renderTargetsMask as u64
        });
        __bindgen_bitfield_unit.set(16usize, 8u8, {
            let resolveTargetsMask: u32 = unsafe { ::std::mem::transmute(resolveTargetsMask) };
            resolveTargetsMask as u64
        });
        __bindgen_bitfield_unit.set(24usize, 8u8, {
            let renderTargetClearMask: u32 =
                unsafe { ::std::mem::transmute(renderTargetClearMask) };
            renderTargetClearMask as u64
        });
        __bindgen_bitfield_unit.set(32usize, 1u8, {
            let depthStencilTargetMask: u32 =
                unsafe { ::std::mem::transmute(depthStencilTargetMask) };
            depthStencilTargetMask as u64
        });
        __bindgen_bitfield_unit.set(33usize, 1u8, {
            let clearDepth: u32 = unsafe { ::std::mem::transmute(clearDepth) };
            clearDepth as u64
        });
        __bindgen_bitfield_unit.set(34usize, 1u8, {
            let clearStencil: u32 = unsafe { ::std::mem::transmute(clearStencil) };
            clearStencil as u64
        });
        __bindgen_bitfield_unit.set(35usize, 1u8, {
            let resolveDepthStencil: u32 = unsafe { ::std::mem::transmute(resolveDepthStencil) };
            resolveDepthStencil as u64
        });
        __bindgen_bitfield_unit.set(36usize, 4u8, {
            let resolveTargetRefs: u32 = unsafe { ::std::mem::transmute(resolveTargetRefs) };
            resolveTargetRefs as u64
        });
        __bindgen_bitfield_unit.set(40usize, 1u8, {
            let clearOnly: u32 = unsafe { ::std::mem::transmute(clearOnly) };
            clearOnly as u64
        });
        __bindgen_bitfield_unit.set(41usize, 7u8, {
            let clearValueRefs: u32 = unsafe { ::std::mem::transmute(clearValueRefs) };
            clearValueRefs as u64
        });
        __bindgen_bitfield_unit.set(48usize, 8u8, {
            let viewportRefs: u32 = unsafe { ::std::mem::transmute(viewportRefs) };
            viewportRefs as u64
        });
        __bindgen_bitfield_unit.set(56usize, 8u8, {
            let scissorRectRefs: u32 = unsafe { ::std::mem::transmute(scissorRectRefs) };
            scissorRectRefs as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rps_NodeDeclInfo {
    pub name: rps_StrRef,
    pub params: rps_ArrayRef<rps_NodeParamDecl, ::std::os::raw::c_ulong>,
    pub flags: RpsNodeDeclFlags,
    pub semanticKinds: rps_ArrayRef<rps_ParamSemanticsKindInfo, u32>,
    pub semanticParamTable: rps_ArrayRef<RpsParamId, u32>,
    pub dynamicStates: rps_Span<::std::os::raw::c_uint>,
    pub fixedFunctionBindings: rps_Span<::std::os::raw::c_uint>,
    pub numAccesses: u32,
    pub pRenderPassInfo: *mut rps_NodeDeclRenderPassInfo,
}
#[test]
fn bindgen_test_layout_rps_NodeDeclInfo() {
    const UNINIT: ::std::mem::MaybeUninit<rps_NodeDeclInfo> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rps_NodeDeclInfo>(),
        104usize,
        concat!("Size of: ", stringify!(rps_NodeDeclInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<rps_NodeDeclInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(rps_NodeDeclInfo))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rps_NodeDeclInfo),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).params) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rps_NodeDeclInfo),
            "::",
            stringify!(params)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(rps_NodeDeclInfo),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).semanticKinds) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(rps_NodeDeclInfo),
            "::",
            stringify!(semanticKinds)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).semanticParamTable) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(rps_NodeDeclInfo),
            "::",
            stringify!(semanticParamTable)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dynamicStates) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(rps_NodeDeclInfo),
            "::",
            stringify!(dynamicStates)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fixedFunctionBindings) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(rps_NodeDeclInfo),
            "::",
            stringify!(fixedFunctionBindings)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).numAccesses) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(rps_NodeDeclInfo),
            "::",
            stringify!(numAccesses)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pRenderPassInfo) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(rps_NodeDeclInfo),
            "::",
            stringify!(pRenderPassInfo)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rps_RenderGraphSignature {
    pub m_allocator: *mut rps_Arena,
    pub m_nodeDecls: rps_ArrayRef<rps_NodeDeclInfo, ::std::os::raw::c_ulong>,
    pub m_paramDecls: rps_ArrayRef<rps_ParamDecl, ::std::os::raw::c_ulong>,
    pub m_externalResourceParamIds: rps_ArrayRef<RpsParamId, ::std::os::raw::c_ulong>,
    pub m_maxExternalResources: u32,
    pub m_totalParamDataBufferSize: u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rps_RenderGraphSignature_ParamSemanticKey {
    pub paramIndex: u32,
    pub semantic: RpsSemantic,
    pub semanticIndex: u32,
}
#[test]
fn bindgen_test_layout_rps_RenderGraphSignature_ParamSemanticKey() {
    const UNINIT: ::std::mem::MaybeUninit<rps_RenderGraphSignature_ParamSemanticKey> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rps_RenderGraphSignature_ParamSemanticKey>(),
        12usize,
        concat!(
            "Size of: ",
            stringify!(rps_RenderGraphSignature_ParamSemanticKey)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<rps_RenderGraphSignature_ParamSemanticKey>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(rps_RenderGraphSignature_ParamSemanticKey)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).paramIndex) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rps_RenderGraphSignature_ParamSemanticKey),
            "::",
            stringify!(paramIndex)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).semantic) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rps_RenderGraphSignature_ParamSemanticKey),
            "::",
            stringify!(semantic)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).semanticIndex) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rps_RenderGraphSignature_ParamSemanticKey),
            "::",
            stringify!(semanticIndex)
        )
    );
}
pub type rps_RenderGraphSignature_SortedParamSemanticList = [u64; 53usize];
#[test]
fn bindgen_test_layout_rps_RenderGraphSignature() {
    const UNINIT: ::std::mem::MaybeUninit<rps_RenderGraphSignature> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rps_RenderGraphSignature>(),
        64usize,
        concat!("Size of: ", stringify!(rps_RenderGraphSignature))
    );
    assert_eq!(
        ::std::mem::align_of::<rps_RenderGraphSignature>(),
        8usize,
        concat!("Alignment of ", stringify!(rps_RenderGraphSignature))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_allocator) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rps_RenderGraphSignature),
            "::",
            stringify!(m_allocator)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_nodeDecls) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rps_RenderGraphSignature),
            "::",
            stringify!(m_nodeDecls)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_paramDecls) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rps_RenderGraphSignature),
            "::",
            stringify!(m_paramDecls)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_externalResourceParamIds) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(rps_RenderGraphSignature),
            "::",
            stringify!(m_externalResourceParamIds)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_maxExternalResources) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(rps_RenderGraphSignature),
            "::",
            stringify!(m_maxExternalResources)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_totalParamDataBufferSize) as usize - ptr as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(rps_RenderGraphSignature),
            "::",
            stringify!(m_totalParamDataBufferSize)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rps_RpslHost {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug)]
pub struct rps_RenderGraphBuilder {
    pub m_renderGraph: *mut rps_RenderGraph,
    pub m_cmdArena: *mut rps_Arena,
    pub m_state: rps_RenderGraphBuilder_State,
    pub m_buildStatus: RpsResult,
    pub m_paramData:
        rps_ArrayRef<rps_RenderGraphBuilder_RenderGraphArgInfo, ::std::os::raw::c_ulong>,
    pub m_outputResourceIds: rps_ArrayRef<RpsResourceId, ::std::os::raw::c_ulong>,
    pub m_resourceDecls: rps_Vector<rps_ResourceDecl, rps_ArenaAllocator>,
    pub m_resourceDeclSlots: [u64; 5usize],
    pub m_cmdNodes: [u64; 5usize],
    pub m_explicitDependencies: rps_Vector<rps_NodeDependency, rps_ArenaAllocator>,
    pub m_dynamicNodeDecls: rps_Vector<*const rps_NodeDeclInfo, rps_ArenaAllocator>,
    pub m_dynamicNodeDeclIdBegin: u32,
    pub m_pCurrProgram: *mut rps_ProgramInstance,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rps_RenderGraphBuilder_RenderGraphArgInfo {
    pub data: RpsVariable,
    pub resources: rps_Span<::std::os::raw::c_uint>,
    pub outputResourceIds: rps_Span<::std::os::raw::c_uint>,
}
#[test]
fn bindgen_test_layout_rps_RenderGraphBuilder_RenderGraphArgInfo() {
    const UNINIT: ::std::mem::MaybeUninit<rps_RenderGraphBuilder_RenderGraphArgInfo> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rps_RenderGraphBuilder_RenderGraphArgInfo>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(rps_RenderGraphBuilder_RenderGraphArgInfo)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<rps_RenderGraphBuilder_RenderGraphArgInfo>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(rps_RenderGraphBuilder_RenderGraphArgInfo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rps_RenderGraphBuilder_RenderGraphArgInfo),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).resources) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rps_RenderGraphBuilder_RenderGraphArgInfo),
            "::",
            stringify!(resources)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).outputResourceIds) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rps_RenderGraphBuilder_RenderGraphArgInfo),
            "::",
            stringify!(outputResourceIds)
        )
    );
}
pub const rps_RenderGraphBuilder_State_Created: rps_RenderGraphBuilder_State = 0;
pub const rps_RenderGraphBuilder_State_Closed: rps_RenderGraphBuilder_State = 1;
pub const rps_RenderGraphBuilder_State_Building: rps_RenderGraphBuilder_State = 2;
pub const rps_RenderGraphBuilder_State_Error: rps_RenderGraphBuilder_State = 3;
pub type rps_RenderGraphBuilder_State = ::std::os::raw::c_int;
#[test]
fn bindgen_test_layout_rps_RenderGraphBuilder() {
    const UNINIT: ::std::mem::MaybeUninit<rps_RenderGraphBuilder> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rps_RenderGraphBuilder>(),
        248usize,
        concat!("Size of: ", stringify!(rps_RenderGraphBuilder))
    );
    assert_eq!(
        ::std::mem::align_of::<rps_RenderGraphBuilder>(),
        8usize,
        concat!("Alignment of ", stringify!(rps_RenderGraphBuilder))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_renderGraph) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rps_RenderGraphBuilder),
            "::",
            stringify!(m_renderGraph)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_cmdArena) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rps_RenderGraphBuilder),
            "::",
            stringify!(m_cmdArena)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_state) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rps_RenderGraphBuilder),
            "::",
            stringify!(m_state)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_buildStatus) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(rps_RenderGraphBuilder),
            "::",
            stringify!(m_buildStatus)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_paramData) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rps_RenderGraphBuilder),
            "::",
            stringify!(m_paramData)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_outputResourceIds) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(rps_RenderGraphBuilder),
            "::",
            stringify!(m_outputResourceIds)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_resourceDecls) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(rps_RenderGraphBuilder),
            "::",
            stringify!(m_resourceDecls)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_resourceDeclSlots) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(rps_RenderGraphBuilder),
            "::",
            stringify!(m_resourceDeclSlots)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_cmdNodes) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(rps_RenderGraphBuilder),
            "::",
            stringify!(m_cmdNodes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_explicitDependencies) as usize - ptr as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(rps_RenderGraphBuilder),
            "::",
            stringify!(m_explicitDependencies)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_dynamicNodeDecls) as usize - ptr as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(rps_RenderGraphBuilder),
            "::",
            stringify!(m_dynamicNodeDecls)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_dynamicNodeDeclIdBegin) as usize - ptr as usize },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(rps_RenderGraphBuilder),
            "::",
            stringify!(m_dynamicNodeDeclIdBegin)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_pCurrProgram) as usize - ptr as usize },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(rps_RenderGraphBuilder),
            "::",
            stringify!(m_pCurrProgram)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK3rps18RenderGraphBuilder16GetParamVariableEjPm"]
    pub fn rps_RenderGraphBuilder_GetParamVariable(
        this: *const rps_RenderGraphBuilder,
        paramId: RpsParamId,
        pSize: *mut usize,
    ) -> rps_TResult<RpsVariable>;
}
extern "C" {
    #[link_name = "\u{1}_ZNK3rps18RenderGraphBuilder18GetParamResourceIdEjj"]
    pub fn rps_RenderGraphBuilder_GetParamResourceId(
        this: *const rps_RenderGraphBuilder,
        paramId: RpsParamId,
        arrayIndex: u32,
    ) -> RpsResourceId;
}
extern "C" {
    #[link_name = "\u{1}_ZN3rps18RenderGraphBuilder5BeginEv"]
    pub fn rps_RenderGraphBuilder_Begin(this: *mut rps_RenderGraphBuilder) -> RpsResult;
}
extern "C" {
    #[link_name = "\u{1}_ZN3rps18RenderGraphBuilder3EndEv"]
    pub fn rps_RenderGraphBuilder_End(this: *mut rps_RenderGraphBuilder) -> RpsResult;
}
extern "C" {
    #[link_name = "\u{1}_ZN3rps18RenderGraphBuilder12AllocateDataEmm"]
    pub fn rps_RenderGraphBuilder_AllocateData(
        this: *mut rps_RenderGraphBuilder,
        size: usize,
        alignment: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[link_name = "\u{1}_ZN3rps18RenderGraphBuilder15DeclareVariableEmmPKv"]
    pub fn rps_RenderGraphBuilder_DeclareVariable(
        this: *mut rps_RenderGraphBuilder,
        size: usize,
        alignment: usize,
        pData: *const ::std::os::raw::c_void,
    ) -> RpsVariable;
}
extern "C" {
    #[link_name = "\u{1}_ZN3rps18RenderGraphBuilder18DeclareDynamicNodeEPK11RpsNodeDesc"]
    pub fn rps_RenderGraphBuilder_DeclareDynamicNode(
        this: *mut rps_RenderGraphBuilder,
        pNodeDesc: *const RpsNodeDesc,
    ) -> RpsNodeDeclId;
}
extern "C" {
    #[link_name = "\u{1}_ZN3rps18RenderGraphBuilder15DeclareResourceEjPvNS_6StrRefEPj"]
    pub fn rps_RenderGraphBuilder_DeclareResource(
        this: *mut rps_RenderGraphBuilder,
        localResourceId: u32,
        hDescVar: RpsVariable,
        name: rps_StrRef,
        pOutResId: *mut RpsResourceId,
    ) -> RpsResult;
}
extern "C" {
    #[link_name = "\u{1}_ZN3rps18RenderGraphBuilder15SetResourceNameEjNS_6StrRefE"]
    pub fn rps_RenderGraphBuilder_SetResourceName(
        this: *mut rps_RenderGraphBuilder,
        resourceId: RpsResourceId,
        name: rps_StrRef,
    ) -> RpsResult;
}
extern "C" {
    #[link_name = "\u{1}_ZN3rps18RenderGraphBuilder10AddCmdNodeEjjRK14RpsCmdCallbackPKPvjPj"]
    pub fn rps_RenderGraphBuilder_AddCmdNode(
        this: *mut rps_RenderGraphBuilder,
        nodeDeclId: RpsNodeDeclId,
        tag: u32,
        callback: *const RpsCmdCallback,
        pArgs: *const RpsVariable,
        numArgs: u32,
        pOutCmdId: *mut RpsNodeId,
    ) -> RpsResult;
}
extern "C" {
    #[link_name = "\u{1}_ZN3rps18RenderGraphBuilder7AddNodeEPNS_8RpslHostEjNS_8ArrayRefIPvmEEjjPj"]
    pub fn rps_RenderGraphBuilder_AddNode(
        this: *mut rps_RenderGraphBuilder,
        pRpslHost: *mut rps_RpslHost,
        localNodeDeclId: RpsNodeDeclId,
        args: rps_ArrayRef<RpsVariable, ::std::os::raw::c_ulong>,
        callFlags: RpsNodeFlags,
        nodeLocalId: u32,
        pOutCmdId: *mut RpsNodeId,
    ) -> RpsResult;
}
extern "C" {
    #[link_name = "\u{1}_ZN3rps18RenderGraphBuilder15ScheduleBarrierEv"]
    pub fn rps_RenderGraphBuilder_ScheduleBarrier(this: *mut rps_RenderGraphBuilder) -> RpsResult;
}
extern "C" {
    #[link_name = "\u{1}_ZN3rps18RenderGraphBuilder13BeginSubgraphEj"]
    pub fn rps_RenderGraphBuilder_BeginSubgraph(
        this: *mut rps_RenderGraphBuilder,
        flags: RpsSubgraphFlags,
    ) -> RpsResult;
}
extern "C" {
    #[link_name = "\u{1}_ZN3rps18RenderGraphBuilder11EndSubgraphEv"]
    pub fn rps_RenderGraphBuilder_EndSubgraph(this: *mut rps_RenderGraphBuilder) -> RpsResult;
}
extern "C" {
    #[link_name = "\u{1}_ZN3rps18RenderGraphBuilder13AddDependencyEjj"]
    pub fn rps_RenderGraphBuilder_AddDependency(
        this: *mut rps_RenderGraphBuilder,
        before: RpsNodeId,
        after: RpsNodeId,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN3rps18RenderGraphBuilder26SetOutputParamResourceViewEjPK15RpsResourceView"]
    pub fn rps_RenderGraphBuilder_SetOutputParamResourceView(
        this: *mut rps_RenderGraphBuilder,
        paramId: RpsParamId,
        pViews: *const RpsResourceView,
    ) -> RpsResult;
}
extern "C" {
    #[link_name = "\u{1}_ZN3rps18RenderGraphBuilder5PrintEPK10RpsPrinter"]
    pub fn rps_RenderGraphBuilder_Print(
        this: *mut rps_RenderGraphBuilder,
        pPrinter: *const RpsPrinter,
    ) -> RpsResult;
}
impl rps_RenderGraphBuilder {
    #[inline]
    pub unsafe fn GetParamVariable(
        &self,
        paramId: RpsParamId,
        pSize: *mut usize,
    ) -> rps_TResult<RpsVariable> {
        rps_RenderGraphBuilder_GetParamVariable(self, paramId, pSize)
    }
    #[inline]
    pub unsafe fn GetParamResourceId(&self, paramId: RpsParamId, arrayIndex: u32) -> RpsResourceId {
        rps_RenderGraphBuilder_GetParamResourceId(self, paramId, arrayIndex)
    }
    #[inline]
    pub unsafe fn Begin(&mut self) -> RpsResult {
        rps_RenderGraphBuilder_Begin(self)
    }
    #[inline]
    pub unsafe fn End(&mut self) -> RpsResult {
        rps_RenderGraphBuilder_End(self)
    }
    #[inline]
    pub unsafe fn AllocateData(
        &mut self,
        size: usize,
        alignment: usize,
    ) -> *mut ::std::os::raw::c_void {
        rps_RenderGraphBuilder_AllocateData(self, size, alignment)
    }
    #[inline]
    pub unsafe fn DeclareVariable(
        &mut self,
        size: usize,
        alignment: usize,
        pData: *const ::std::os::raw::c_void,
    ) -> RpsVariable {
        rps_RenderGraphBuilder_DeclareVariable(self, size, alignment, pData)
    }
    #[inline]
    pub unsafe fn DeclareDynamicNode(&mut self, pNodeDesc: *const RpsNodeDesc) -> RpsNodeDeclId {
        rps_RenderGraphBuilder_DeclareDynamicNode(self, pNodeDesc)
    }
    #[inline]
    pub unsafe fn DeclareResource(
        &mut self,
        localResourceId: u32,
        hDescVar: RpsVariable,
        name: rps_StrRef,
        pOutResId: *mut RpsResourceId,
    ) -> RpsResult {
        rps_RenderGraphBuilder_DeclareResource(self, localResourceId, hDescVar, name, pOutResId)
    }
    #[inline]
    pub unsafe fn SetResourceName(
        &mut self,
        resourceId: RpsResourceId,
        name: rps_StrRef,
    ) -> RpsResult {
        rps_RenderGraphBuilder_SetResourceName(self, resourceId, name)
    }
    #[inline]
    pub unsafe fn AddCmdNode(
        &mut self,
        nodeDeclId: RpsNodeDeclId,
        tag: u32,
        callback: *const RpsCmdCallback,
        pArgs: *const RpsVariable,
        numArgs: u32,
        pOutCmdId: *mut RpsNodeId,
    ) -> RpsResult {
        rps_RenderGraphBuilder_AddCmdNode(
            self, nodeDeclId, tag, callback, pArgs, numArgs, pOutCmdId,
        )
    }
    #[inline]
    pub unsafe fn AddNode(
        &mut self,
        pRpslHost: *mut rps_RpslHost,
        localNodeDeclId: RpsNodeDeclId,
        args: rps_ArrayRef<RpsVariable, ::std::os::raw::c_ulong>,
        callFlags: RpsNodeFlags,
        nodeLocalId: u32,
        pOutCmdId: *mut RpsNodeId,
    ) -> RpsResult {
        rps_RenderGraphBuilder_AddNode(
            self,
            pRpslHost,
            localNodeDeclId,
            args,
            callFlags,
            nodeLocalId,
            pOutCmdId,
        )
    }
    #[inline]
    pub unsafe fn ScheduleBarrier(&mut self) -> RpsResult {
        rps_RenderGraphBuilder_ScheduleBarrier(self)
    }
    #[inline]
    pub unsafe fn BeginSubgraph(&mut self, flags: RpsSubgraphFlags) -> RpsResult {
        rps_RenderGraphBuilder_BeginSubgraph(self, flags)
    }
    #[inline]
    pub unsafe fn EndSubgraph(&mut self) -> RpsResult {
        rps_RenderGraphBuilder_EndSubgraph(self)
    }
    #[inline]
    pub unsafe fn AddDependency(&mut self, before: RpsNodeId, after: RpsNodeId) {
        rps_RenderGraphBuilder_AddDependency(self, before, after)
    }
    #[inline]
    pub unsafe fn SetOutputParamResourceView(
        &mut self,
        paramId: RpsParamId,
        pViews: *const RpsResourceView,
    ) -> RpsResult {
        rps_RenderGraphBuilder_SetOutputParamResourceView(self, paramId, pViews)
    }
    #[inline]
    pub unsafe fn Print(&mut self, pPrinter: *const RpsPrinter) -> RpsResult {
        rps_RenderGraphBuilder_Print(self, pPrinter)
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rps_RpslEntry {
    pub name: *const ::std::os::raw::c_char,
    pub pfnEntry: PFN_RpslEntry,
    pub pParamDescs: *const RpsParameterDesc,
    pub pNodeDecls: *const RpsNodeDesc,
    pub numParams: u32,
    pub numNodeDecls: u32,
}
#[test]
fn bindgen_test_layout_rps_RpslEntry() {
    const UNINIT: ::std::mem::MaybeUninit<rps_RpslEntry> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rps_RpslEntry>(),
        40usize,
        concat!("Size of: ", stringify!(rps_RpslEntry))
    );
    assert_eq!(
        ::std::mem::align_of::<rps_RpslEntry>(),
        8usize,
        concat!("Alignment of ", stringify!(rps_RpslEntry))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rps_RpslEntry),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pfnEntry) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rps_RpslEntry),
            "::",
            stringify!(pfnEntry)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pParamDescs) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rps_RpslEntry),
            "::",
            stringify!(pParamDescs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pNodeDecls) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rps_RpslEntry),
            "::",
            stringify!(pNodeDecls)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).numParams) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(rps_RpslEntry),
            "::",
            stringify!(numParams)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).numNodeDecls) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(rps_RpslEntry),
            "::",
            stringify!(numNodeDecls)
        )
    );
}
#[repr(C)]
pub struct rps_Subprogram {
    pub m_device: *const rps_Device,
    pub m_arena: rps_Arena,
    pub m_pSignature: *const rps_RenderGraphSignature,
    pub m_pEntry: *const rps_RpslEntry,
    pub m_nodeImpls: rps_ArrayRef<rps_Subprogram_RpslNodeImpl, ::std::os::raw::c_ulong>,
    pub m_defaultNodeImpl: rps_Subprogram_RpslNodeImpl,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rps_Subprogram_RpslNodeImpl {
    pub __bindgen_anon_1: rps_Subprogram_RpslNodeImpl__bindgen_ty_1,
    pub pBuffer: *mut ::std::os::raw::c_void,
    pub bufferSize: u32,
    pub type_: rps_Subprogram_RpslNodeImpl_Type,
}
pub const rps_Subprogram_RpslNodeImpl_Type_Unknown: rps_Subprogram_RpslNodeImpl_Type = 0;
pub const rps_Subprogram_RpslNodeImpl_Type_RpslEntry: rps_Subprogram_RpslNodeImpl_Type = 1;
pub const rps_Subprogram_RpslNodeImpl_Type_Callback: rps_Subprogram_RpslNodeImpl_Type = 2;
pub type rps_Subprogram_RpslNodeImpl_Type = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub union rps_Subprogram_RpslNodeImpl__bindgen_ty_1 {
    pub pSubprogram: *mut rps_Subprogram,
    pub callback: RpsCmdCallback,
}
#[test]
fn bindgen_test_layout_rps_Subprogram_RpslNodeImpl__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<rps_Subprogram_RpslNodeImpl__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rps_Subprogram_RpslNodeImpl__bindgen_ty_1>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(rps_Subprogram_RpslNodeImpl__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<rps_Subprogram_RpslNodeImpl__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(rps_Subprogram_RpslNodeImpl__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pSubprogram) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rps_Subprogram_RpslNodeImpl__bindgen_ty_1),
            "::",
            stringify!(pSubprogram)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).callback) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rps_Subprogram_RpslNodeImpl__bindgen_ty_1),
            "::",
            stringify!(callback)
        )
    );
}
impl ::std::fmt::Debug for rps_Subprogram_RpslNodeImpl__bindgen_ty_1 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(f, "rps_Subprogram_RpslNodeImpl__bindgen_ty_1 {{ union }}")
    }
}
#[test]
fn bindgen_test_layout_rps_Subprogram_RpslNodeImpl() {
    const UNINIT: ::std::mem::MaybeUninit<rps_Subprogram_RpslNodeImpl> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rps_Subprogram_RpslNodeImpl>(),
        40usize,
        concat!("Size of: ", stringify!(rps_Subprogram_RpslNodeImpl))
    );
    assert_eq!(
        ::std::mem::align_of::<rps_Subprogram_RpslNodeImpl>(),
        8usize,
        concat!("Alignment of ", stringify!(rps_Subprogram_RpslNodeImpl))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pBuffer) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rps_Subprogram_RpslNodeImpl),
            "::",
            stringify!(pBuffer)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bufferSize) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(rps_Subprogram_RpslNodeImpl),
            "::",
            stringify!(bufferSize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(rps_Subprogram_RpslNodeImpl),
            "::",
            stringify!(type_)
        )
    );
}
impl ::std::fmt::Debug for rps_Subprogram_RpslNodeImpl {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(
            f,
            "rps_Subprogram_RpslNodeImpl {{ __bindgen_anon_1: {:?}, pBuffer: {:?}, type: {:?} }}",
            self.__bindgen_anon_1, self.pBuffer, self.type_
        )
    }
}
#[test]
fn bindgen_test_layout_rps_Subprogram() {
    const UNINIT: ::std::mem::MaybeUninit<rps_Subprogram> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rps_Subprogram>(),
        152usize,
        concat!("Size of: ", stringify!(rps_Subprogram))
    );
    assert_eq!(
        ::std::mem::align_of::<rps_Subprogram>(),
        8usize,
        concat!("Alignment of ", stringify!(rps_Subprogram))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_device) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rps_Subprogram),
            "::",
            stringify!(m_device)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_arena) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rps_Subprogram),
            "::",
            stringify!(m_arena)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_pSignature) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(rps_Subprogram),
            "::",
            stringify!(m_pSignature)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_pEntry) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(rps_Subprogram),
            "::",
            stringify!(m_pEntry)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_nodeImpls) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(rps_Subprogram),
            "::",
            stringify!(m_nodeImpls)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_defaultNodeImpl) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(rps_Subprogram),
            "::",
            stringify!(m_defaultNodeImpl)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN3rps10Subprogram6CreateERKNS_6DeviceEPK20RpsProgramCreateInfoPPS0_"]
    pub fn rps_Subprogram_Create(
        device: *const rps_Device,
        pCreateInfo: *const RpsProgramCreateInfo,
        ppInstance: *mut *mut rps_Subprogram,
    ) -> RpsResult;
}
impl ::std::fmt::Debug for rps_Subprogram {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write ! (f , "rps_Subprogram {{ m_device: {:?}, m_arena: {:?}, m_pSignature: {:?}, m_pEntry: {:?}, m_nodeImpls: {:?}, m_defaultNodeImpl: {:?} }}" , self . m_device , self . m_arena , self . m_pSignature , self . m_pEntry , self . m_nodeImpls , self . m_defaultNodeImpl)
    }
}
impl rps_Subprogram {
    #[inline]
    pub unsafe fn Create(
        device: *const rps_Device,
        pCreateInfo: *const RpsProgramCreateInfo,
        ppInstance: *mut *mut rps_Subprogram,
    ) -> RpsResult {
        rps_Subprogram_Create(device, pCreateInfo, ppInstance)
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rps_ResourceAliasingInfo {
    pub srcResourceIndex: u32,
    pub dstResourceIndex: u32,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: [u8; 3usize],
}
#[test]
fn bindgen_test_layout_rps_ResourceAliasingInfo() {
    const UNINIT: ::std::mem::MaybeUninit<rps_ResourceAliasingInfo> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rps_ResourceAliasingInfo>(),
        12usize,
        concat!("Size of: ", stringify!(rps_ResourceAliasingInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<rps_ResourceAliasingInfo>(),
        4usize,
        concat!("Alignment of ", stringify!(rps_ResourceAliasingInfo))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).srcResourceIndex) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rps_ResourceAliasingInfo),
            "::",
            stringify!(srcResourceIndex)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dstResourceIndex) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rps_ResourceAliasingInfo),
            "::",
            stringify!(dstResourceIndex)
        )
    );
}
impl rps_ResourceAliasingInfo {
    #[inline]
    pub fn srcDeactivating(&self) -> RpsBool {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_srcDeactivating(&mut self, val: RpsBool) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn dstActivating(&self) -> RpsBool {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_dstActivating(&mut self, val: RpsBool) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        srcDeactivating: RpsBool,
        dstActivating: RpsBool,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let srcDeactivating: u32 = unsafe { ::std::mem::transmute(srcDeactivating) };
            srcDeactivating as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let dstActivating: u32 = unsafe { ::std::mem::transmute(dstActivating) };
            dstActivating as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rps_FinalAccessInfo {
    pub prevTransition: u32,
    pub range: rps_SubresourceRangePacked,
}
#[test]
fn bindgen_test_layout_rps_FinalAccessInfo() {
    const UNINIT: ::std::mem::MaybeUninit<rps_FinalAccessInfo> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rps_FinalAccessInfo>(),
        12usize,
        concat!("Size of: ", stringify!(rps_FinalAccessInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<rps_FinalAccessInfo>(),
        4usize,
        concat!("Alignment of ", stringify!(rps_FinalAccessInfo))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).prevTransition) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rps_FinalAccessInfo),
            "::",
            stringify!(prevTransition)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).range) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rps_FinalAccessInfo),
            "::",
            stringify!(range)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rps_ResourceInstance {
    pub resourceDeclId: u32,
    pub temporalLayerOffset: u32,
    pub desc: rps_ResourceDescPacked,
    pub fullSubresourceRange: rps_SubresourceRangePacked,
    pub numSubResources: u32,
    pub clearValueId: u32,
    pub allAccesses: rps_AccessAttr,
    pub initialAccess: rps_AccessAttr,
    pub prevFinalAccess: rps_AccessAttr,
    pub finalAccesses: rps_Span<::std::os::raw::c_uint>,
    pub lifetimeBegin: u32,
    pub lifetimeEnd: u32,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
    pub allocRequirement: RpsGpuMemoryRequirement,
    pub allocPlacement: RpsHeapPlacement,
    pub hRuntimeResource: RpsRuntimeResource,
}
pub const rps_ResourceInstance_LIFETIME_UNDEFINED: u32 = 4294967295;
#[test]
fn bindgen_test_layout_rps_ResourceInstance() {
    const UNINIT: ::std::mem::MaybeUninit<rps_ResourceInstance> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rps_ResourceInstance>(),
        128usize,
        concat!("Size of: ", stringify!(rps_ResourceInstance))
    );
    assert_eq!(
        ::std::mem::align_of::<rps_ResourceInstance>(),
        8usize,
        concat!("Alignment of ", stringify!(rps_ResourceInstance))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).resourceDeclId) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rps_ResourceInstance),
            "::",
            stringify!(resourceDeclId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).temporalLayerOffset) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rps_ResourceInstance),
            "::",
            stringify!(temporalLayerOffset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).desc) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rps_ResourceInstance),
            "::",
            stringify!(desc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fullSubresourceRange) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(rps_ResourceInstance),
            "::",
            stringify!(fullSubresourceRange)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).numSubResources) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(rps_ResourceInstance),
            "::",
            stringify!(numSubResources)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).clearValueId) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(rps_ResourceInstance),
            "::",
            stringify!(clearValueId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).allAccesses) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(rps_ResourceInstance),
            "::",
            stringify!(allAccesses)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).initialAccess) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(rps_ResourceInstance),
            "::",
            stringify!(initialAccess)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).prevFinalAccess) as usize - ptr as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(rps_ResourceInstance),
            "::",
            stringify!(prevFinalAccess)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).finalAccesses) as usize - ptr as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(rps_ResourceInstance),
            "::",
            stringify!(finalAccesses)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).lifetimeBegin) as usize - ptr as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(rps_ResourceInstance),
            "::",
            stringify!(lifetimeBegin)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).lifetimeEnd) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(rps_ResourceInstance),
            "::",
            stringify!(lifetimeEnd)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).allocRequirement) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(rps_ResourceInstance),
            "::",
            stringify!(allocRequirement)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).allocPlacement) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(rps_ResourceInstance),
            "::",
            stringify!(allocPlacement)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hRuntimeResource) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(rps_ResourceInstance),
            "::",
            stringify!(hRuntimeResource)
        )
    );
}
impl ::std::fmt::Debug for rps_ResourceInstance {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write ! (f , "rps_ResourceInstance {{ desc: {:?}, fullSubresourceRange: {:?}, allAccesses: {:?}, initialAccess: {:?}, prevFinalAccess: {:?}, finalAccesses: {:?}, isTemporalSlice : {:?}, isFirstTemporalSlice : {:?}, isExternal : {:?}, isAliased : {:?}, isPendingCreate : {:?}, isPendingInit : {:?}, isMutableFormat : {:?}, bBufferFormattedWrite : {:?}, bBufferFormattedRead : {:?}, allocRequirement: {:?}, allocPlacement: {:?}, hRuntimeResource: {:?} }}" , self . desc , self . fullSubresourceRange , self . allAccesses , self . initialAccess , self . prevFinalAccess , self . finalAccesses , self . isTemporalSlice () , self . isFirstTemporalSlice () , self . isExternal () , self . isAliased () , self . isPendingCreate () , self . isPendingInit () , self . isMutableFormat () , self . bBufferFormattedWrite () , self . bBufferFormattedRead () , self . allocRequirement , self . allocPlacement , self . hRuntimeResource)
    }
}
impl rps_ResourceInstance {
    #[inline]
    pub fn isTemporalSlice(&self) -> bool {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_isTemporalSlice(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn isFirstTemporalSlice(&self) -> bool {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_isFirstTemporalSlice(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn isExternal(&self) -> bool {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_isExternal(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn isAliased(&self) -> bool {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_isAliased(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn isPendingCreate(&self) -> bool {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_isPendingCreate(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn isPendingInit(&self) -> bool {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_isPendingInit(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn isMutableFormat(&self) -> bool {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_isMutableFormat(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn bBufferFormattedWrite(&self) -> bool {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_bBufferFormattedWrite(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn bBufferFormattedRead(&self) -> bool {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_bBufferFormattedRead(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        isTemporalSlice: bool,
        isFirstTemporalSlice: bool,
        isExternal: bool,
        isAliased: bool,
        isPendingCreate: bool,
        isPendingInit: bool,
        isMutableFormat: bool,
        bBufferFormattedWrite: bool,
        bBufferFormattedRead: bool,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let isTemporalSlice: u8 = unsafe { ::std::mem::transmute(isTemporalSlice) };
            isTemporalSlice as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let isFirstTemporalSlice: u8 = unsafe { ::std::mem::transmute(isFirstTemporalSlice) };
            isFirstTemporalSlice as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let isExternal: u8 = unsafe { ::std::mem::transmute(isExternal) };
            isExternal as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let isAliased: u8 = unsafe { ::std::mem::transmute(isAliased) };
            isAliased as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let isPendingCreate: u8 = unsafe { ::std::mem::transmute(isPendingCreate) };
            isPendingCreate as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let isPendingInit: u8 = unsafe { ::std::mem::transmute(isPendingInit) };
            isPendingInit as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let isMutableFormat: u8 = unsafe { ::std::mem::transmute(isMutableFormat) };
            isMutableFormat as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let bBufferFormattedWrite: u8 = unsafe { ::std::mem::transmute(bBufferFormattedWrite) };
            bBufferFormattedWrite as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let bBufferFormattedRead: u8 = unsafe { ::std::mem::transmute(bBufferFormattedRead) };
            bBufferFormattedRead as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rps_CmdAccessInfo {
    pub resourceId: u32,
    pub range: rps_SubresourceRangePacked,
    pub access: rps_AccessAttr,
    pub viewFormat: RpsFormat,
    pub pViewInfo: *const RpsResourceView,
}
#[test]
fn bindgen_test_layout_rps_CmdAccessInfo() {
    const UNINIT: ::std::mem::MaybeUninit<rps_CmdAccessInfo> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rps_CmdAccessInfo>(),
        32usize,
        concat!("Size of: ", stringify!(rps_CmdAccessInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<rps_CmdAccessInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(rps_CmdAccessInfo))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).resourceId) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rps_CmdAccessInfo),
            "::",
            stringify!(resourceId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).range) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rps_CmdAccessInfo),
            "::",
            stringify!(range)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).access) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(rps_CmdAccessInfo),
            "::",
            stringify!(access)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).viewFormat) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(rps_CmdAccessInfo),
            "::",
            stringify!(viewFormat)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pViewInfo) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rps_CmdAccessInfo),
            "::",
            stringify!(pViewInfo)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rps_CmdRenderPassInfo {
    pub viewportInfo: RpsCmdViewportInfo,
    pub renderTargetInfo: RpsCmdRenderTargetInfo,
}
#[test]
fn bindgen_test_layout_rps_CmdRenderPassInfo() {
    const UNINIT: ::std::mem::MaybeUninit<rps_CmdRenderPassInfo> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rps_CmdRenderPassInfo>(),
        88usize,
        concat!("Size of: ", stringify!(rps_CmdRenderPassInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<rps_CmdRenderPassInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(rps_CmdRenderPassInfo))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).viewportInfo) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rps_CmdRenderPassInfo),
            "::",
            stringify!(viewportInfo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).renderTargetInfo) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(rps_CmdRenderPassInfo),
            "::",
            stringify!(renderTargetInfo)
        )
    );
}
#[repr(C)]
#[derive(Debug)]
pub struct rps_ProgramInstance {
    pub m_pProgram: *const rps_Subprogram,
    pub m_resourceIds: rps_Vector<RpsResourceId, rps_ArenaAllocator>,
    pub m_cmdIds: rps_Vector<RpsNodeId, rps_ArenaAllocator>,
    pub m_persistentIndexGenerator: [u64; 14usize],
}
pub const rps_ProgramInstance_PersistentIndexKinds_PERSISTENT_INDEX_KIND_RESOURCE_ID:
    rps_ProgramInstance_PersistentIndexKinds = 0;
pub const rps_ProgramInstance_PersistentIndexKinds_PERSISTENT_INDEX_KIND_NODE_ID:
    rps_ProgramInstance_PersistentIndexKinds = 1;
pub const rps_ProgramInstance_PersistentIndexKinds_PERSISTENT_INDEX_KIND_COUNT:
    rps_ProgramInstance_PersistentIndexKinds = 2;
pub type rps_ProgramInstance_PersistentIndexKinds = ::std::os::raw::c_uint;
#[test]
fn bindgen_test_layout_rps_ProgramInstance() {
    const UNINIT: ::std::mem::MaybeUninit<rps_ProgramInstance> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rps_ProgramInstance>(),
        184usize,
        concat!("Size of: ", stringify!(rps_ProgramInstance))
    );
    assert_eq!(
        ::std::mem::align_of::<rps_ProgramInstance>(),
        8usize,
        concat!("Alignment of ", stringify!(rps_ProgramInstance))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_pProgram) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rps_ProgramInstance),
            "::",
            stringify!(m_pProgram)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_resourceIds) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rps_ProgramInstance),
            "::",
            stringify!(m_resourceIds)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_cmdIds) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(rps_ProgramInstance),
            "::",
            stringify!(m_cmdIds)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_persistentIndexGenerator) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(rps_ProgramInstance),
            "::",
            stringify!(m_persistentIndexGenerator)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rps_CmdInfo {
    pub nodeDeclIndex: u32,
    pub __bindgen_anon_1: rps_CmdInfo__bindgen_ty_1,
    pub pNodeDecl: *const rps_NodeDeclInfo,
    pub pCmdDecl: *const rps_Cmd,
    pub accesses: rps_Span<::std::os::raw::c_uint>,
    pub pRenderPassInfo: *mut rps_CmdRenderPassInfo,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rps_CmdInfo__bindgen_ty_1 {
    pub __bindgen_anon_1: rps_CmdInfo__bindgen_ty_1__bindgen_ty_1,
    pub subgraphFlags: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct rps_CmdInfo__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_rps_CmdInfo__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<rps_CmdInfo__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(rps_CmdInfo__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<rps_CmdInfo__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(rps_CmdInfo__bindgen_ty_1__bindgen_ty_1)
        )
    );
}
impl rps_CmdInfo__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn cmdDeclIndex(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 31u8) as u32) }
    }
    #[inline]
    pub fn set_cmdDeclIndex(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 31u8, val as u64)
        }
    }
    #[inline]
    pub fn bPreferAsync(&self) -> bool {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_bPreferAsync(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        cmdDeclIndex: u32,
        bPreferAsync: bool,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 31u8, {
            let cmdDeclIndex: u32 = unsafe { ::std::mem::transmute(cmdDeclIndex) };
            cmdDeclIndex as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let bPreferAsync: u8 = unsafe { ::std::mem::transmute(bPreferAsync) };
            bPreferAsync as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_rps_CmdInfo__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<rps_CmdInfo__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rps_CmdInfo__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(rps_CmdInfo__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<rps_CmdInfo__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(rps_CmdInfo__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).subgraphFlags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rps_CmdInfo__bindgen_ty_1),
            "::",
            stringify!(subgraphFlags)
        )
    );
}
impl ::std::fmt::Debug for rps_CmdInfo__bindgen_ty_1 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(f, "rps_CmdInfo__bindgen_ty_1 {{ union }}")
    }
}
#[test]
fn bindgen_test_layout_rps_CmdInfo() {
    const UNINIT: ::std::mem::MaybeUninit<rps_CmdInfo> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rps_CmdInfo>(),
        40usize,
        concat!("Size of: ", stringify!(rps_CmdInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<rps_CmdInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(rps_CmdInfo))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nodeDeclIndex) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rps_CmdInfo),
            "::",
            stringify!(nodeDeclIndex)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pNodeDecl) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rps_CmdInfo),
            "::",
            stringify!(pNodeDecl)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pCmdDecl) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rps_CmdInfo),
            "::",
            stringify!(pCmdDecl)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).accesses) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rps_CmdInfo),
            "::",
            stringify!(accesses)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pRenderPassInfo) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(rps_CmdInfo),
            "::",
            stringify!(pRenderPassInfo)
        )
    );
}
impl ::std::fmt::Debug for rps_CmdInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write ! (f , "rps_CmdInfo {{ __bindgen_anon_1: {:?}, pNodeDecl: {:?}, pCmdDecl: {:?}, accesses: {:?}, pRenderPassInfo: {:?} }}" , self . __bindgen_anon_1 , self . pNodeDecl , self . pCmdDecl , self . accesses , self . pRenderPassInfo)
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rps_TransitionInfo {
    pub access: rps_CmdAccessInfo,
    pub nodeId: rps_NodeId,
    pub prevTransition: u32,
}
#[test]
fn bindgen_test_layout_rps_TransitionInfo() {
    const UNINIT: ::std::mem::MaybeUninit<rps_TransitionInfo> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rps_TransitionInfo>(),
        40usize,
        concat!("Size of: ", stringify!(rps_TransitionInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<rps_TransitionInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(rps_TransitionInfo))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).access) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rps_TransitionInfo),
            "::",
            stringify!(access)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nodeId) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(rps_TransitionInfo),
            "::",
            stringify!(nodeId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).prevTransition) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(rps_TransitionInfo),
            "::",
            stringify!(prevTransition)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rps_RenderGraphUpdateContext {
    pub pUpdateInfo: *const RpsRenderGraphUpdateInfo,
    pub renderGraph: *mut rps_RenderGraph,
    pub pRuntimeDevice: *mut rps_RuntimeDevice,
    pub frameArena: *mut rps_Arena,
    pub scratchArena: *mut rps_Arena,
}
#[test]
fn bindgen_test_layout_rps_RenderGraphUpdateContext() {
    const UNINIT: ::std::mem::MaybeUninit<rps_RenderGraphUpdateContext> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rps_RenderGraphUpdateContext>(),
        40usize,
        concat!("Size of: ", stringify!(rps_RenderGraphUpdateContext))
    );
    assert_eq!(
        ::std::mem::align_of::<rps_RenderGraphUpdateContext>(),
        8usize,
        concat!("Alignment of ", stringify!(rps_RenderGraphUpdateContext))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pUpdateInfo) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rps_RenderGraphUpdateContext),
            "::",
            stringify!(pUpdateInfo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).renderGraph) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rps_RenderGraphUpdateContext),
            "::",
            stringify!(renderGraph)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pRuntimeDevice) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rps_RenderGraphUpdateContext),
            "::",
            stringify!(pRuntimeDevice)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).frameArena) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rps_RenderGraphUpdateContext),
            "::",
            stringify!(frameArena)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).scratchArena) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(rps_RenderGraphUpdateContext),
            "::",
            stringify!(scratchArena)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rps_RuntimeCmdInfo {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    pub aliasingInfos: rps_Span<::std::os::raw::c_uint>,
}
#[test]
fn bindgen_test_layout_rps_RuntimeCmdInfo() {
    const UNINIT: ::std::mem::MaybeUninit<rps_RuntimeCmdInfo> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rps_RuntimeCmdInfo>(),
        12usize,
        concat!("Size of: ", stringify!(rps_RuntimeCmdInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<rps_RuntimeCmdInfo>(),
        4usize,
        concat!("Alignment of ", stringify!(rps_RuntimeCmdInfo))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).aliasingInfos) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rps_RuntimeCmdInfo),
            "::",
            stringify!(aliasingInfos)
        )
    );
}
impl rps_RuntimeCmdInfo {
    #[inline]
    pub fn cmdId(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 31u8) as u32) }
    }
    #[inline]
    pub fn set_cmdId(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 31u8, val as u64)
        }
    }
    #[inline]
    pub fn isTransition(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_isTransition(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(cmdId: u32, isTransition: u32) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 31u8, {
            let cmdId: u32 = unsafe { ::std::mem::transmute(cmdId) };
            cmdId as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let isTransition: u32 = unsafe { ::std::mem::transmute(isTransition) };
            isTransition as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rps_HeapInfo {
    pub memTypeIndex: u32,
    pub index: u32,
    pub size: u64,
    pub alignment: u32,
    pub usedSize: u64,
    pub maxUsedSize: u64,
    pub hRuntimeHeap: RpsRuntimeHeap,
}
#[test]
fn bindgen_test_layout_rps_HeapInfo() {
    const UNINIT: ::std::mem::MaybeUninit<rps_HeapInfo> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rps_HeapInfo>(),
        48usize,
        concat!("Size of: ", stringify!(rps_HeapInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<rps_HeapInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(rps_HeapInfo))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).memTypeIndex) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rps_HeapInfo),
            "::",
            stringify!(memTypeIndex)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).index) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rps_HeapInfo),
            "::",
            stringify!(index)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rps_HeapInfo),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).alignment) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rps_HeapInfo),
            "::",
            stringify!(alignment)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).usedSize) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rps_HeapInfo),
            "::",
            stringify!(usedSize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).maxUsedSize) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(rps_HeapInfo),
            "::",
            stringify!(maxUsedSize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hRuntimeHeap) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(rps_HeapInfo),
            "::",
            stringify!(hRuntimeHeap)
        )
    );
}
#[repr(C)]
pub struct rps_IRenderGraphPhase__bindgen_vtable(::std::os::raw::c_void);
#[repr(C)]
#[derive(Debug)]
pub struct rps_IRenderGraphPhase {
    pub vtable_: *const rps_IRenderGraphPhase__bindgen_vtable,
}
#[test]
fn bindgen_test_layout_rps_IRenderGraphPhase() {
    assert_eq!(
        ::std::mem::size_of::<rps_IRenderGraphPhase>(),
        8usize,
        concat!("Size of: ", stringify!(rps_IRenderGraphPhase))
    );
    assert_eq!(
        ::std::mem::align_of::<rps_IRenderGraphPhase>(),
        8usize,
        concat!("Alignment of ", stringify!(rps_IRenderGraphPhase))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rps_RuntimeCmd {
    pub cmdId: RpsNodeId,
}
#[test]
fn bindgen_test_layout_rps_RuntimeCmd() {
    const UNINIT: ::std::mem::MaybeUninit<rps_RuntimeCmd> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rps_RuntimeCmd>(),
        4usize,
        concat!("Size of: ", stringify!(rps_RuntimeCmd))
    );
    assert_eq!(
        ::std::mem::align_of::<rps_RuntimeCmd>(),
        4usize,
        concat!("Alignment of ", stringify!(rps_RuntimeCmd))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cmdId) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rps_RuntimeCmd),
            "::",
            stringify!(cmdId)
        )
    );
}
#[repr(C)]
#[derive(Debug)]
pub struct rps_RuntimeBackend {
    pub _base: rps_IRenderGraphPhase,
    pub m_renderGraph: *mut rps_RenderGraph,
}
#[test]
fn bindgen_test_layout_rps_RuntimeBackend() {
    const UNINIT: ::std::mem::MaybeUninit<rps_RuntimeBackend> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rps_RuntimeBackend>(),
        16usize,
        concat!("Size of: ", stringify!(rps_RuntimeBackend))
    );
    assert_eq!(
        ::std::mem::align_of::<rps_RuntimeBackend>(),
        8usize,
        concat!("Alignment of ", stringify!(rps_RuntimeBackend))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_renderGraph) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rps_RuntimeBackend),
            "::",
            stringify!(m_renderGraph)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK3rps14RuntimeBackend12CloneContextERKNS_25RuntimeCmdCallbackContextE25RpsRuntimeCommandBuffer_TPPK21RpsCmdCallbackContext"]
    pub fn rps_RuntimeBackend_CloneContext(
        this: *const rps_RuntimeBackend,
        context: *const rps_RuntimeCmdCallbackContext,
        hNewCmdBuffer: RpsRuntimeCommandBuffer,
        ppNewContext: *mut *const RpsCmdCallbackContext,
    ) -> RpsResult;
}
extern "C" {
    #[link_name = "\u{1}_ZN3rps14RuntimeBackend22GetCmdArgResourceInfosEPK21RpsCmdCallbackContextjjPPKNS_16ResourceInstanceEj"]
    pub fn rps_RuntimeBackend_GetCmdArgResourceInfos(
        pContext: *const RpsCmdCallbackContext,
        argIndex: u32,
        srcArrayIndex: u32,
        ppResources: *mut *const rps_ResourceInstance,
        count: u32,
    ) -> RpsResult;
}
extern "C" {
    #[link_name = "\u{1}_ZNK3rps14RuntimeBackend13RecordCommandERNS_25RuntimeCmdCallbackContextERKNS_10RuntimeCmdE"]
    pub fn rps_RuntimeBackend_RecordCommand(
        this: *const rps_RuntimeBackend,
        context: *mut rps_RuntimeCmdCallbackContext,
        runtimeCmd: *const rps_RuntimeCmd,
    ) -> RpsResult;
}
impl rps_RuntimeBackend {
    #[inline]
    pub unsafe fn CloneContext(
        &self,
        context: *const rps_RuntimeCmdCallbackContext,
        hNewCmdBuffer: RpsRuntimeCommandBuffer,
        ppNewContext: *mut *const RpsCmdCallbackContext,
    ) -> RpsResult {
        rps_RuntimeBackend_CloneContext(self, context, hNewCmdBuffer, ppNewContext)
    }
    #[inline]
    pub unsafe fn GetCmdArgResourceInfos(
        pContext: *const RpsCmdCallbackContext,
        argIndex: u32,
        srcArrayIndex: u32,
        ppResources: *mut *const rps_ResourceInstance,
        count: u32,
    ) -> RpsResult {
        rps_RuntimeBackend_GetCmdArgResourceInfos(
            pContext,
            argIndex,
            srcArrayIndex,
            ppResources,
            count,
        )
    }
    #[inline]
    pub unsafe fn RecordCommand(
        &self,
        context: *mut rps_RuntimeCmdCallbackContext,
        runtimeCmd: *const rps_RuntimeCmd,
    ) -> RpsResult {
        rps_RuntimeBackend_RecordCommand(self, context, runtimeCmd)
    }
}
extern "C" {
    #[link_name = "\u{1}_ZN3rps14RuntimeBackend3RunERNS_24RenderGraphUpdateContextE"]
    pub fn rps_RuntimeBackend_Run(
        this: *mut ::std::os::raw::c_void,
        context: *mut rps_RenderGraphUpdateContext,
    ) -> RpsResult;
}
extern "C" {
    #[link_name = "\u{1}_ZNK3rps14RuntimeBackend17RecordDebugMarkerERKNS_25RuntimeCmdCallbackContextE25RpsRuntimeDebugMarkerModeNS_6StrRefE"]
    pub fn rps_RuntimeBackend_RecordDebugMarker(
        this: *mut ::std::os::raw::c_void,
        context: *const rps_RuntimeCmdCallbackContext,
        mode: RpsRuntimeDebugMarkerMode,
        name: rps_StrRef,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN3rps14RuntimeBackend9OnDestroyEv"]
    pub fn rps_RuntimeBackend_OnDestroy(this: *mut ::std::os::raw::c_void);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rps_RuntimeCmdCallbackContext {
    pub _base: RpsCmdCallbackContext,
    pub pBackend: *const rps_RuntimeBackend,
    pub pRenderGraph: *const rps_RenderGraph,
    pub pNodeDeclInfo: *const rps_NodeDeclInfo,
    pub pCmdInfo: *const rps_CmdInfo,
    pub pCmd: *const rps_Cmd,
    pub pRuntimeCmd: *const rps_RuntimeCmd,
    pub cmdId: u32,
    pub result: RpsResult,
    pub recordFlags: RpsRecordCommandFlags,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_rps_RuntimeCmdCallbackContext() {
    const UNINIT: ::std::mem::MaybeUninit<rps_RuntimeCmdCallbackContext> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rps_RuntimeCmdCallbackContext>(),
        104usize,
        concat!("Size of: ", stringify!(rps_RuntimeCmdCallbackContext))
    );
    assert_eq!(
        ::std::mem::align_of::<rps_RuntimeCmdCallbackContext>(),
        8usize,
        concat!("Alignment of ", stringify!(rps_RuntimeCmdCallbackContext))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pBackend) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(rps_RuntimeCmdCallbackContext),
            "::",
            stringify!(pBackend)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pRenderGraph) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(rps_RuntimeCmdCallbackContext),
            "::",
            stringify!(pRenderGraph)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pNodeDeclInfo) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(rps_RuntimeCmdCallbackContext),
            "::",
            stringify!(pNodeDeclInfo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pCmdInfo) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(rps_RuntimeCmdCallbackContext),
            "::",
            stringify!(pCmdInfo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pCmd) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(rps_RuntimeCmdCallbackContext),
            "::",
            stringify!(pCmd)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pRuntimeCmd) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(rps_RuntimeCmdCallbackContext),
            "::",
            stringify!(pRuntimeCmd)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cmdId) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(rps_RuntimeCmdCallbackContext),
            "::",
            stringify!(cmdId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).result) as usize - ptr as usize },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(rps_RuntimeCmdCallbackContext),
            "::",
            stringify!(result)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).recordFlags) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(rps_RuntimeCmdCallbackContext),
            "::",
            stringify!(recordFlags)
        )
    );
}
impl rps_RuntimeCmdCallbackContext {
    #[inline]
    pub fn renderPassFlags(&self) -> RpsRuntimeRenderPassFlags {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 30u8) as u32) }
    }
    #[inline]
    pub fn set_renderPassFlags(&mut self, val: RpsRuntimeRenderPassFlags) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 30u8, val as u64)
        }
    }
    #[inline]
    pub fn bIsPrimaryContext(&self) -> bool {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(30usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_bIsPrimaryContext(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(30usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn bIsCmdBeginEnd(&self) -> bool {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_bIsCmdBeginEnd(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        renderPassFlags: RpsRuntimeRenderPassFlags,
        bIsPrimaryContext: bool,
        bIsCmdBeginEnd: bool,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 30u8, {
            let renderPassFlags: u32 = unsafe { ::std::mem::transmute(renderPassFlags) };
            renderPassFlags as u64
        });
        __bindgen_bitfield_unit.set(30usize, 1u8, {
            let bIsPrimaryContext: u8 = unsafe { ::std::mem::transmute(bIsPrimaryContext) };
            bIsPrimaryContext as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let bIsCmdBeginEnd: u8 = unsafe { ::std::mem::transmute(bIsCmdBeginEnd) };
            bIsCmdBeginEnd as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
pub struct rps_RenderGraph {
    pub m_device: *const rps_Device,
    pub m_createInfo: RpsRenderGraphCreateInfo,
    pub m_persistentArena: rps_Arena,
    pub m_frameArena: rps_Arena,
    pub m_scratchArena: rps_Arena,
    pub m_graph: rps_Graph,
    pub m_status: RpsResult,
    pub m_pSignature: *const rps_RenderGraphSignature,
    pub m_pMainEntry: *mut rps_Subprogram,
    pub m_memoryTypes: rps_ArrayRef<RpsMemoryTypeInfo, ::std::os::raw::c_ulong>,
    pub m_phases: rps_Vector<*mut rps_IRenderGraphPhase, rps_ArenaAllocator>,
    pub m_resourceCache: rps_Vector<rps_ResourceInstance, rps_ArenaAllocator>,
    pub m_programInstances: rps_Vector<*mut rps_ProgramInstance, rps_ArenaAllocator>,
    pub m_cmds: rps_Vector<rps_CmdInfo, rps_ArenaAllocator>,
    pub m_cmdAccesses: rps_Vector<rps_CmdAccessInfo, rps_ArenaAllocator>,
    pub m_transitions: rps_Vector<rps_TransitionInfo, rps_ArenaAllocator>,
    pub m_resourceFinalAccesses: rps_Vector<rps_FinalAccessInfo, rps_ArenaAllocator>,
    pub m_pBackend: *mut rps_RuntimeBackend,
    pub m_runtimeCmdInfos: rps_Vector<rps_RuntimeCmdInfo, rps_ArenaAllocator>,
    pub m_cmdBatches: rps_Vector<RpsCommandBatch, rps_ArenaAllocator>,
    pub m_cmdBatchWaitFenceIds: rps_Vector<u32, rps_ArenaAllocator>,
    pub m_aliasingInfos: rps_Vector<rps_ResourceAliasingInfo, rps_ArenaAllocator>,
    pub m_heaps: rps_Vector<rps_HeapInfo, rps_ArenaAllocator>,
    pub m_resourceClearValues: [u64; 5usize],
    pub m_builder: rps_RenderGraphBuilder,
    pub m_diagData: rps_RenderGraph__bindgen_ty_1,
    pub m_diagInfoArena: rps_Arena,
}
#[repr(C)]
pub struct rps_RenderGraph__bindgen_ty_1 {
    pub resourceInfos: rps_Vector<RpsResourceDiagnosticInfo, rps_ArenaAllocator>,
    pub cmdInfos: rps_Vector<RpsCmdDiagnosticInfo, rps_ArenaAllocator>,
    pub heapInfos: rps_Vector<RpsHeapDiagnosticInfo, rps_ArenaAllocator>,
}
#[test]
fn bindgen_test_layout_rps_RenderGraph__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<rps_RenderGraph__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rps_RenderGraph__bindgen_ty_1>(),
        96usize,
        concat!("Size of: ", stringify!(rps_RenderGraph__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<rps_RenderGraph__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(rps_RenderGraph__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).resourceInfos) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rps_RenderGraph__bindgen_ty_1),
            "::",
            stringify!(resourceInfos)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cmdInfos) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(rps_RenderGraph__bindgen_ty_1),
            "::",
            stringify!(cmdInfos)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).heapInfos) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(rps_RenderGraph__bindgen_ty_1),
            "::",
            stringify!(heapInfos)
        )
    );
}
impl ::std::fmt::Debug for rps_RenderGraph__bindgen_ty_1 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write ! (f , "rps_RenderGraph__bindgen_ty_1 {{ resourceInfos: {:?}, cmdInfos: {:?}, heapInfos: {:?} }}" , self . resourceInfos , self . cmdInfos , self . heapInfos)
    }
}
pub const rps_RenderGraph_INVALID_TRANSITION: u32 = 0;
#[test]
fn bindgen_test_layout_rps_RenderGraph() {
    const UNINIT: ::std::mem::MaybeUninit<rps_RenderGraph> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rps_RenderGraph>(),
        1432usize,
        concat!("Size of: ", stringify!(rps_RenderGraph))
    );
    assert_eq!(
        ::std::mem::align_of::<rps_RenderGraph>(),
        8usize,
        concat!("Alignment of ", stringify!(rps_RenderGraph))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_device) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rps_RenderGraph),
            "::",
            stringify!(m_device)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_createInfo) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rps_RenderGraph),
            "::",
            stringify!(m_createInfo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_persistentArena) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(rps_RenderGraph),
            "::",
            stringify!(m_persistentArena)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_frameArena) as usize - ptr as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(rps_RenderGraph),
            "::",
            stringify!(m_frameArena)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_scratchArena) as usize - ptr as usize },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(rps_RenderGraph),
            "::",
            stringify!(m_scratchArena)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_graph) as usize - ptr as usize },
        312usize,
        concat!(
            "Offset of field: ",
            stringify!(rps_RenderGraph),
            "::",
            stringify!(m_graph)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_status) as usize - ptr as usize },
        544usize,
        concat!(
            "Offset of field: ",
            stringify!(rps_RenderGraph),
            "::",
            stringify!(m_status)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_pSignature) as usize - ptr as usize },
        552usize,
        concat!(
            "Offset of field: ",
            stringify!(rps_RenderGraph),
            "::",
            stringify!(m_pSignature)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_pMainEntry) as usize - ptr as usize },
        560usize,
        concat!(
            "Offset of field: ",
            stringify!(rps_RenderGraph),
            "::",
            stringify!(m_pMainEntry)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_memoryTypes) as usize - ptr as usize },
        568usize,
        concat!(
            "Offset of field: ",
            stringify!(rps_RenderGraph),
            "::",
            stringify!(m_memoryTypes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_phases) as usize - ptr as usize },
        584usize,
        concat!(
            "Offset of field: ",
            stringify!(rps_RenderGraph),
            "::",
            stringify!(m_phases)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_resourceCache) as usize - ptr as usize },
        616usize,
        concat!(
            "Offset of field: ",
            stringify!(rps_RenderGraph),
            "::",
            stringify!(m_resourceCache)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_programInstances) as usize - ptr as usize },
        648usize,
        concat!(
            "Offset of field: ",
            stringify!(rps_RenderGraph),
            "::",
            stringify!(m_programInstances)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_cmds) as usize - ptr as usize },
        680usize,
        concat!(
            "Offset of field: ",
            stringify!(rps_RenderGraph),
            "::",
            stringify!(m_cmds)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_cmdAccesses) as usize - ptr as usize },
        712usize,
        concat!(
            "Offset of field: ",
            stringify!(rps_RenderGraph),
            "::",
            stringify!(m_cmdAccesses)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_transitions) as usize - ptr as usize },
        744usize,
        concat!(
            "Offset of field: ",
            stringify!(rps_RenderGraph),
            "::",
            stringify!(m_transitions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_resourceFinalAccesses) as usize - ptr as usize },
        776usize,
        concat!(
            "Offset of field: ",
            stringify!(rps_RenderGraph),
            "::",
            stringify!(m_resourceFinalAccesses)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_pBackend) as usize - ptr as usize },
        808usize,
        concat!(
            "Offset of field: ",
            stringify!(rps_RenderGraph),
            "::",
            stringify!(m_pBackend)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_runtimeCmdInfos) as usize - ptr as usize },
        816usize,
        concat!(
            "Offset of field: ",
            stringify!(rps_RenderGraph),
            "::",
            stringify!(m_runtimeCmdInfos)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_cmdBatches) as usize - ptr as usize },
        848usize,
        concat!(
            "Offset of field: ",
            stringify!(rps_RenderGraph),
            "::",
            stringify!(m_cmdBatches)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_cmdBatchWaitFenceIds) as usize - ptr as usize },
        880usize,
        concat!(
            "Offset of field: ",
            stringify!(rps_RenderGraph),
            "::",
            stringify!(m_cmdBatchWaitFenceIds)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_aliasingInfos) as usize - ptr as usize },
        912usize,
        concat!(
            "Offset of field: ",
            stringify!(rps_RenderGraph),
            "::",
            stringify!(m_aliasingInfos)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_heaps) as usize - ptr as usize },
        944usize,
        concat!(
            "Offset of field: ",
            stringify!(rps_RenderGraph),
            "::",
            stringify!(m_heaps)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_resourceClearValues) as usize - ptr as usize },
        976usize,
        concat!(
            "Offset of field: ",
            stringify!(rps_RenderGraph),
            "::",
            stringify!(m_resourceClearValues)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_builder) as usize - ptr as usize },
        1016usize,
        concat!(
            "Offset of field: ",
            stringify!(rps_RenderGraph),
            "::",
            stringify!(m_builder)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_diagData) as usize - ptr as usize },
        1264usize,
        concat!(
            "Offset of field: ",
            stringify!(rps_RenderGraph),
            "::",
            stringify!(m_diagData)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_diagInfoArena) as usize - ptr as usize },
        1360usize,
        concat!(
            "Offset of field: ",
            stringify!(rps_RenderGraph),
            "::",
            stringify!(m_diagInfoArena)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN3rps11RenderGraph6CreateERNS_6DeviceEPK24RpsRenderGraphCreateInfoPPS0_"]
    pub fn rps_RenderGraph_Create(
        device: *mut rps_Device,
        pCreateInfo: *const RpsRenderGraphCreateInfo,
        ppRenderGraph: *mut *mut rps_RenderGraph,
    ) -> RpsResult;
}
extern "C" {
    #[link_name = "\u{1}_ZN3rps11RenderGraph7DestroyEv"]
    pub fn rps_RenderGraph_Destroy(this: *mut rps_RenderGraph);
}
extern "C" {
    #[link_name = "\u{1}_ZN3rps11RenderGraph10BeginBuildEv"]
    pub fn rps_RenderGraph_BeginBuild(this: *mut rps_RenderGraph) -> *mut rps_RenderGraphBuilder;
}
extern "C" {
    #[link_name = "\u{1}_ZN3rps11RenderGraph6UpdateERK24RpsRenderGraphUpdateInfo"]
    pub fn rps_RenderGraph_Update(
        this: *mut rps_RenderGraph,
        updateInfo: *const RpsRenderGraphUpdateInfo,
    ) -> RpsResult;
}
extern "C" {
    #[link_name = "\u{1}_ZNK3rps11RenderGraph14RecordCommandsERK31RpsRenderGraphRecordCommandInfo"]
    pub fn rps_RenderGraph_RecordCommands(
        this: *const rps_RenderGraph,
        recordInfo: *const RpsRenderGraphRecordCommandInfo,
    ) -> RpsResult;
}
extern "C" {
    #[link_name = "\u{1}_ZN3rps11RenderGraph17GetDiagnosticInfoER28RpsRenderGraphDiagnosticInfoj"]
    pub fn rps_RenderGraph_GetDiagnosticInfo(
        this: *mut rps_RenderGraph,
        diagInfos: *mut RpsRenderGraphDiagnosticInfo,
        diagnosticFlags: RpsRenderGraphDiagnosticInfoFlags,
    ) -> RpsResult;
}
extern "C" {
    #[link_name = "\u{1}_ZN3rps11RenderGraph26GetOrCreateProgramInstanceEPNS_10SubprogramERj"]
    pub fn rps_RenderGraph_GetOrCreateProgramInstance(
        this: *mut rps_RenderGraph,
        pSubprogram: *mut rps_Subprogram,
        globalProgramInstanceId: *mut u32,
    ) -> *mut rps_ProgramInstance;
}
extern "C" {
    #[link_name = "\u{1}_ZNK3rps11RenderGraph22GetCmdRenderTargetInfoEjR22RpsCmdRenderTargetInfo"]
    pub fn rps_RenderGraph_GetCmdRenderTargetInfo(
        this: *const rps_RenderGraph,
        cmdId: RpsNodeId,
        renderTargetInfo: *mut RpsCmdRenderTargetInfo,
    ) -> RpsResult;
}
extern "C" {
    #[link_name = "\u{1}_ZNK3rps11RenderGraph18GetCmdViewportInfoEjR18RpsCmdViewportInfo"]
    pub fn rps_RenderGraph_GetCmdViewportInfo(
        this: *const rps_RenderGraph,
        arg1: RpsNodeId,
        viewportInfo: *mut RpsCmdViewportInfo,
    ) -> RpsResult;
}
extern "C" {
    #[link_name = "\u{1}_ZNK3rps11RenderGraph22GetRuntimeResourceInfoEjjP22RpsRuntimeResourceInfo"]
    pub fn rps_RenderGraph_GetRuntimeResourceInfo(
        this: *const rps_RenderGraph,
        resourceId: RpsResourceId,
        temporalLayerIndex: u32,
        pResourceInfo: *mut RpsRuntimeResourceInfo,
    ) -> RpsResult;
}
extern "C" {
    #[link_name = "\u{1}_ZNK3rps11RenderGraph38GetOutputParameterRuntimeResourceInfosEjjjP22RpsRuntimeResourceInfo"]
    pub fn rps_RenderGraph_GetOutputParameterRuntimeResourceInfos(
        this: *const rps_RenderGraph,
        paramId: RpsParamId,
        arrayOffset: u32,
        resourceCount: u32,
        pResourceInfos: *mut RpsRuntimeResourceInfo,
    ) -> RpsResult;
}
impl ::std::fmt::Debug for rps_RenderGraph {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write ! (f , "rps_RenderGraph {{ m_device: {:?}, m_createInfo: {:?}, m_persistentArena: {:?}, m_frameArena: {:?}, m_scratchArena: {:?}, m_graph: {:?}, m_status: {:?}, m_pSignature: {:?}, m_pMainEntry: {:?}, m_memoryTypes: {:?}, m_phases: {:?}, m_resourceCache: {:?}, m_programInstances: {:?}, m_cmds: {:?}, m_cmdAccesses: {:?}, m_transitions: {:?}, m_resourceFinalAccesses: {:?}, m_pBackend: {:?}, m_runtimeCmdInfos: {:?}, m_cmdBatches: {:?}, m_cmdBatchWaitFenceIds: {:?}, m_aliasingInfos: {:?}, m_heaps: {:?}, m_resourceClearValues: opaque, m_builder: {:?}, m_diagData: {:?}, m_diagInfoArena: {:?} }}" , self . m_device , self . m_createInfo , self . m_persistentArena , self . m_frameArena , self . m_scratchArena , self . m_graph , self . m_status , self . m_pSignature , self . m_pMainEntry , self . m_memoryTypes , self . m_phases , self . m_resourceCache , self . m_programInstances , self . m_cmds , self . m_cmdAccesses , self . m_transitions , self . m_resourceFinalAccesses , self . m_pBackend , self . m_runtimeCmdInfos , self . m_cmdBatches , self . m_cmdBatchWaitFenceIds , self . m_aliasingInfos , self . m_heaps , self . m_builder , self . m_diagData , self . m_diagInfoArena)
    }
}
impl rps_RenderGraph {
    #[inline]
    pub unsafe fn Create(
        device: *mut rps_Device,
        pCreateInfo: *const RpsRenderGraphCreateInfo,
        ppRenderGraph: *mut *mut rps_RenderGraph,
    ) -> RpsResult {
        rps_RenderGraph_Create(device, pCreateInfo, ppRenderGraph)
    }
    #[inline]
    pub unsafe fn Destroy(&mut self) {
        rps_RenderGraph_Destroy(self)
    }
    #[inline]
    pub unsafe fn BeginBuild(&mut self) -> *mut rps_RenderGraphBuilder {
        rps_RenderGraph_BeginBuild(self)
    }
    #[inline]
    pub unsafe fn Update(&mut self, updateInfo: *const RpsRenderGraphUpdateInfo) -> RpsResult {
        rps_RenderGraph_Update(self, updateInfo)
    }
    #[inline]
    pub unsafe fn RecordCommands(
        &self,
        recordInfo: *const RpsRenderGraphRecordCommandInfo,
    ) -> RpsResult {
        rps_RenderGraph_RecordCommands(self, recordInfo)
    }
    #[inline]
    pub unsafe fn GetDiagnosticInfo(
        &mut self,
        diagInfos: *mut RpsRenderGraphDiagnosticInfo,
        diagnosticFlags: RpsRenderGraphDiagnosticInfoFlags,
    ) -> RpsResult {
        rps_RenderGraph_GetDiagnosticInfo(self, diagInfos, diagnosticFlags)
    }
    #[inline]
    pub unsafe fn GetOrCreateProgramInstance(
        &mut self,
        pSubprogram: *mut rps_Subprogram,
        globalProgramInstanceId: *mut u32,
    ) -> *mut rps_ProgramInstance {
        rps_RenderGraph_GetOrCreateProgramInstance(self, pSubprogram, globalProgramInstanceId)
    }
    #[inline]
    pub unsafe fn GetCmdRenderTargetInfo(
        &self,
        cmdId: RpsNodeId,
        renderTargetInfo: *mut RpsCmdRenderTargetInfo,
    ) -> RpsResult {
        rps_RenderGraph_GetCmdRenderTargetInfo(self, cmdId, renderTargetInfo)
    }
    #[inline]
    pub unsafe fn GetCmdViewportInfo(
        &self,
        arg1: RpsNodeId,
        viewportInfo: *mut RpsCmdViewportInfo,
    ) -> RpsResult {
        rps_RenderGraph_GetCmdViewportInfo(self, arg1, viewportInfo)
    }
    #[inline]
    pub unsafe fn GetRuntimeResourceInfo(
        &self,
        resourceId: RpsResourceId,
        temporalLayerIndex: u32,
        pResourceInfo: *mut RpsRuntimeResourceInfo,
    ) -> RpsResult {
        rps_RenderGraph_GetRuntimeResourceInfo(self, resourceId, temporalLayerIndex, pResourceInfo)
    }
    #[inline]
    pub unsafe fn GetOutputParameterRuntimeResourceInfos(
        &self,
        paramId: RpsParamId,
        arrayOffset: u32,
        resourceCount: u32,
        pResourceInfos: *mut RpsRuntimeResourceInfo,
    ) -> RpsResult {
        rps_RenderGraph_GetOutputParameterRuntimeResourceInfos(
            self,
            paramId,
            arrayOffset,
            resourceCount,
            pResourceInfos,
        )
    }
}
#[repr(C)]
pub struct rps_RuntimeDevice__bindgen_vtable(::std::os::raw::c_void);
#[repr(C)]
#[derive(Debug)]
pub struct rps_RuntimeDevice {
    pub vtable_: *const rps_RuntimeDevice__bindgen_vtable,
    pub m_pDevice: *mut rps_Device,
    pub m_createInfo: RpsRuntimeDeviceCreateInfo,
}
#[test]
fn bindgen_test_layout_rps_RuntimeDevice() {
    const UNINIT: ::std::mem::MaybeUninit<rps_RuntimeDevice> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rps_RuntimeDevice>(),
        104usize,
        concat!("Size of: ", stringify!(rps_RuntimeDevice))
    );
    assert_eq!(
        ::std::mem::align_of::<rps_RuntimeDevice>(),
        8usize,
        concat!("Alignment of ", stringify!(rps_RuntimeDevice))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_pDevice) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rps_RuntimeDevice),
            "::",
            stringify!(m_pDevice)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_createInfo) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rps_RuntimeDevice),
            "::",
            stringify!(m_createInfo)
        )
    );
}
#[doc = "< Unknown format."]
pub const RpsFormat_RPS_FORMAT_UNKNOWN: RpsFormat = 0;
#[doc = "< 4-channel RGBA format with each channel being a typeless 32-bit value."]
pub const RpsFormat_RPS_FORMAT_R32G32B32A32_TYPELESS: RpsFormat = 1;
#[doc = "< 4-channel RGBA format with each channel being a 32-bit IEEE 754 floating"]
pub const RpsFormat_RPS_FORMAT_R32G32B32A32_FLOAT: RpsFormat = 2;
#[doc = "< 4-channel RGBA format with each channel being a 32-bit unsigned integer."]
pub const RpsFormat_RPS_FORMAT_R32G32B32A32_UINT: RpsFormat = 3;
#[doc = "< 4-channel RGBA format with each channel being a 32-bit signed integer."]
pub const RpsFormat_RPS_FORMAT_R32G32B32A32_SINT: RpsFormat = 4;
#[doc = "< 3-channel RGB format with each channel being a typeless 32-bit value."]
pub const RpsFormat_RPS_FORMAT_R32G32B32_TYPELESS: RpsFormat = 5;
#[doc = "< 3-channel RGB format with each channel being a 32-bit IEEE 754 floating"]
pub const RpsFormat_RPS_FORMAT_R32G32B32_FLOAT: RpsFormat = 6;
#[doc = "< 3-channel RGB format with each channel being a 32-bit unsigned integer."]
pub const RpsFormat_RPS_FORMAT_R32G32B32_UINT: RpsFormat = 7;
#[doc = "< 3-channel RGB format with each channel being a 32-bit signed integer."]
pub const RpsFormat_RPS_FORMAT_R32G32B32_SINT: RpsFormat = 8;
#[doc = "< 4-channel RGBA format with each channel being a typeless 16-bit value."]
pub const RpsFormat_RPS_FORMAT_R16G16B16A16_TYPELESS: RpsFormat = 9;
#[doc = "< 4-channel RGBA format with each channel being a 16-bit floating point"]
pub const RpsFormat_RPS_FORMAT_R16G16B16A16_FLOAT: RpsFormat = 10;
#[doc = "< 4-channel RGBA format with each channel being a normalized, 16-bit unsigned"]
pub const RpsFormat_RPS_FORMAT_R16G16B16A16_UNORM: RpsFormat = 11;
#[doc = "< 4-channel RGBA format with each channel being a 16-bit unsigned integer."]
pub const RpsFormat_RPS_FORMAT_R16G16B16A16_UINT: RpsFormat = 12;
#[doc = "< 4-channel RGBA format with each channel being a normalized, 16-bit signed"]
pub const RpsFormat_RPS_FORMAT_R16G16B16A16_SNORM: RpsFormat = 13;
#[doc = " 4-channel RGBA format with each channel being a 16-bit signed integer."]
pub const RpsFormat_RPS_FORMAT_R16G16B16A16_SINT: RpsFormat = 14;
#[doc = " 2-channel RG format with each channel being a typeless 32-bit value."]
pub const RpsFormat_RPS_FORMAT_R32G32_TYPELESS: RpsFormat = 15;
#[doc = " 2-channel RG format with each channel being a 32-bit IEEE 754 floating point value."]
pub const RpsFormat_RPS_FORMAT_R32G32_FLOAT: RpsFormat = 16;
#[doc = " 2-channel RG format with each channel being a 32-bit unsigned integer."]
pub const RpsFormat_RPS_FORMAT_R32G32_UINT: RpsFormat = 17;
#[doc = " 2-channel RG format with each channel being a 32-bit signed integer."]
pub const RpsFormat_RPS_FORMAT_R32G32_SINT: RpsFormat = 18;
#[doc = " 2-channel RG format with the first channel being a typeless 32-bit value, the second channel a typeless 8-bit\n value and 24 unused bits at the end."]
pub const RpsFormat_RPS_FORMAT_R32G8X24_TYPELESS: RpsFormat = 19;
#[doc = " 2-channel RG format with the first channel being a 32-bit depth value, the second one a 8-bit unsigned integer\n value and 24 unused bits at the end."]
pub const RpsFormat_RPS_FORMAT_D32_FLOAT_S8X24_UINT: RpsFormat = 20;
#[doc = " Single channel R format with the channel being a typeless 32-bit IEEE 754 floating point value and additional\n sets of 8 and 24 unused bits afterwards."]
pub const RpsFormat_RPS_FORMAT_R32_FLOAT_X8X24_TYPELESS: RpsFormat = 21;
#[doc = " Single channel R format with 32 unused bits, the channel being an 8-bit unsigned integer value and 24 unused\n bits at the end."]
pub const RpsFormat_RPS_FORMAT_X32_TYPELESS_G8X24_UINT: RpsFormat = 22;
#[doc = " 4-channel RGBA format with the RGB channels being typeless 10-bit values and the A channel being a typeless\n 2-bit value."]
pub const RpsFormat_RPS_FORMAT_R10G10B10A2_TYPELESS: RpsFormat = 23;
#[doc = " 4-channel RGBA format with the RGB channels being 10-bit normalized, unsigned integer values and the A channel\n being a 2-bit normalized, unsigned integer value."]
pub const RpsFormat_RPS_FORMAT_R10G10B10A2_UNORM: RpsFormat = 24;
#[doc = " 4-channel RGBA format with the RGB channels being 10-bit unsigned integer values and the A channel being a 2-bit\n unsigned integer value."]
pub const RpsFormat_RPS_FORMAT_R10G10B10A2_UINT: RpsFormat = 25;
#[doc = " 3-channel RGB format with the RG channels being 11-bit floating point values and the B channel being a 10-bit\n floating point value."]
pub const RpsFormat_RPS_FORMAT_R11G11B10_FLOAT: RpsFormat = 26;
#[doc = "< 4-channel RGBA format with all channels being typeless 8-bit values."]
pub const RpsFormat_RPS_FORMAT_R8G8B8A8_TYPELESS: RpsFormat = 27;
#[doc = "< 4-channel RGBA format with all channels being normalized 8-bit unsigned"]
pub const RpsFormat_RPS_FORMAT_R8G8B8A8_UNORM: RpsFormat = 28;
#[doc = "< 4-channel RGBA format with all channels being normalized 8-bit unsigned integer"]
pub const RpsFormat_RPS_FORMAT_R8G8B8A8_UNORM_SRGB: RpsFormat = 29;
#[doc = "< 4-channel RGBA format with all channels being 8-bit unsigned integers."]
pub const RpsFormat_RPS_FORMAT_R8G8B8A8_UINT: RpsFormat = 30;
#[doc = "< 4-channel RGBA format with all channels being normalized, 8-bit signed"]
pub const RpsFormat_RPS_FORMAT_R8G8B8A8_SNORM: RpsFormat = 31;
#[doc = "< 4-channel RGBA format with all channels being 8-bit signed integers."]
pub const RpsFormat_RPS_FORMAT_R8G8B8A8_SINT: RpsFormat = 32;
#[doc = "< 2-channel RG format with each channel being a typeless 16-bit value."]
pub const RpsFormat_RPS_FORMAT_R16G16_TYPELESS: RpsFormat = 33;
#[doc = "< 2-channel RG format with each channel being a 16-bit IEEE 754 floating point value."]
pub const RpsFormat_RPS_FORMAT_R16G16_FLOAT: RpsFormat = 34;
#[doc = "< 2-channel RG format with each channel being a normalized, 16-bit unsigned integer."]
pub const RpsFormat_RPS_FORMAT_R16G16_UNORM: RpsFormat = 35;
#[doc = "< 2-channel RG format with each channel being a 16-bit unsigned integer."]
pub const RpsFormat_RPS_FORMAT_R16G16_UINT: RpsFormat = 36;
#[doc = "< 2-channel RG format with each channel being a normalized, 16-bit signed integer"]
pub const RpsFormat_RPS_FORMAT_R16G16_SNORM: RpsFormat = 37;
#[doc = "< 2-channel RG format with each channel being a 16-bit signed integer."]
pub const RpsFormat_RPS_FORMAT_R16G16_SINT: RpsFormat = 38;
#[doc = "< Single channel R format with the channel being a typeless 32-bit value."]
pub const RpsFormat_RPS_FORMAT_R32_TYPELESS: RpsFormat = 39;
#[doc = "< Single channel R format with the channel being a 32-bit IEEE 754 floating point depth"]
pub const RpsFormat_RPS_FORMAT_D32_FLOAT: RpsFormat = 40;
#[doc = "< Single channel R format with the channel being a 32-bit IEEE 754 floating point"]
pub const RpsFormat_RPS_FORMAT_R32_FLOAT: RpsFormat = 41;
#[doc = "< Single channel R format with the channel being a 32-bit unsigned integer."]
pub const RpsFormat_RPS_FORMAT_R32_UINT: RpsFormat = 42;
#[doc = "< Single channel R format with the channel being a 32-bit signed integer."]
pub const RpsFormat_RPS_FORMAT_R32_SINT: RpsFormat = 43;
#[doc = " 2-channel RG format with the first channel being a typeless 24-bit value and the second one a typeless 8-bit\n value."]
pub const RpsFormat_RPS_FORMAT_R24G8_TYPELESS: RpsFormat = 44;
#[doc = " 2-channel RG format with the first channel being a normalized, 24-bit unsigned integer depth value and the\n second one an 8-bit unsigned integer stencil value."]
pub const RpsFormat_RPS_FORMAT_D24_UNORM_S8_UINT: RpsFormat = 45;
#[doc = " 2-channel RG format with the first channel being a normalized, 24-bit unsigned integer value and the second one\n a typeless 8-bit value."]
pub const RpsFormat_RPS_FORMAT_R24_UNORM_X8_TYPELESS: RpsFormat = 46;
#[doc = " Single channel R format with 24 unused bits with the channel being an 8-bit unsigned integer."]
pub const RpsFormat_RPS_FORMAT_X24_TYPELESS_G8_UINT: RpsFormat = 47;
#[doc = "< 2-channel RG format with each channel being a typeless 8-bit value."]
pub const RpsFormat_RPS_FORMAT_R8G8_TYPELESS: RpsFormat = 48;
#[doc = "< 2-channel RG format with each channel being a normalized, 8-bit unsigned integer."]
pub const RpsFormat_RPS_FORMAT_R8G8_UNORM: RpsFormat = 49;
#[doc = "< 2-channel RG format with each channel being a 8-bit unsigned integer."]
pub const RpsFormat_RPS_FORMAT_R8G8_UINT: RpsFormat = 50;
#[doc = "< 2-channel RG format with each channel being a normalized, 8-bit signed integer."]
pub const RpsFormat_RPS_FORMAT_R8G8_SNORM: RpsFormat = 51;
#[doc = "< 2-channel RG format with each channel being a 8-bit signed integer."]
pub const RpsFormat_RPS_FORMAT_R8G8_SINT: RpsFormat = 52;
#[doc = "< Single channel R format with the channel being a typeless 16-bit value."]
pub const RpsFormat_RPS_FORMAT_R16_TYPELESS: RpsFormat = 53;
#[doc = "< Single channel R format with the channel being a 16-bit IEEE 754 floating point"]
pub const RpsFormat_RPS_FORMAT_R16_FLOAT: RpsFormat = 54;
#[doc = "< Single channel R format with the channel being a 16-bit IEEE 754 floating point"]
pub const RpsFormat_RPS_FORMAT_D16_UNORM: RpsFormat = 55;
#[doc = "< Single channel R format with the channel being a 16-bit unsigned integer."]
pub const RpsFormat_RPS_FORMAT_R16_UNORM: RpsFormat = 56;
#[doc = "< Single channel R format with the channel being a 16-bit signed integer."]
pub const RpsFormat_RPS_FORMAT_R16_UINT: RpsFormat = 57;
#[doc = "< Single channel R format with the channel being a normalized, 16-bit signed integer."]
pub const RpsFormat_RPS_FORMAT_R16_SNORM: RpsFormat = 58;
#[doc = "< Single channel R format with the channel being a 16-bit signed integer."]
pub const RpsFormat_RPS_FORMAT_R16_SINT: RpsFormat = 59;
#[doc = "< Single channel R format with the channel being a typeless 8-bit value."]
pub const RpsFormat_RPS_FORMAT_R8_TYPELESS: RpsFormat = 60;
#[doc = "< Single channel R format with the channel being a normalized, 8-bit unsigned integer."]
pub const RpsFormat_RPS_FORMAT_R8_UNORM: RpsFormat = 61;
#[doc = "< Single channel R format with the channel being a 8-bit signed integer."]
pub const RpsFormat_RPS_FORMAT_R8_UINT: RpsFormat = 62;
#[doc = "< Single channel R format with the channel being a normalized, 8-bit signed integer."]
pub const RpsFormat_RPS_FORMAT_R8_SNORM: RpsFormat = 63;
#[doc = "< Single channel R format with the channel being a 8-bit signed integer."]
pub const RpsFormat_RPS_FORMAT_R8_SINT: RpsFormat = 64;
#[doc = "< Single channel A format with the channel being a normalized, 8-bit unsigned integer."]
pub const RpsFormat_RPS_FORMAT_A8_UNORM: RpsFormat = 65;
#[doc = "< Single channel R format with the channel being a 1-bit unsigned integer."]
pub const RpsFormat_RPS_FORMAT_R1_UNORM: RpsFormat = 66;
#[doc = " 4-channel RGB format with the first three channels being a 9-bit mantissa. Together with the 5-bit exponent that\n is shared for all three channels they form three 9-bit mantissa + 5-bit exponent floating point value."]
pub const RpsFormat_RPS_FORMAT_R9G9B9E5_SHAREDEXP: RpsFormat = 67;
#[doc = " 4-channel RGB format with each channel being a normalized, 8-bit unsigned integer. Each block of 32 bits\n describes the RGB values for a pair of pixels that always share one R and B value but have separate G values."]
pub const RpsFormat_RPS_FORMAT_R8G8_B8G8_UNORM: RpsFormat = 68;
#[doc = " 4-channel RGB format with each channel being a normalized, 8-bit unsigned integer. Each block of 32 bits\n describes the RGB values for a pair of pixels that always share one R and B value but have separate G values."]
pub const RpsFormat_RPS_FORMAT_G8R8_G8B8_UNORM: RpsFormat = 69;
#[doc = " 4-channel block compressed format with the first channel being a typeless 5-bit value, the second one a\n typeless, 6-bit value, the third one a typeless, 5-bit value and the last one a typeless, 0-bit or 1-bit value."]
pub const RpsFormat_RPS_FORMAT_BC1_TYPELESS: RpsFormat = 70;
#[doc = " 4-channel block compressed format with the first channel being a normalized, 5-bit unsigned integer, the second\n one a normalized, 6-bit unsigned integer, the third one a normalized, 5-bit unsigned integer and the last one a\n normalized, 0-bit or 1-bit unsigned integer."]
pub const RpsFormat_RPS_FORMAT_BC1_UNORM: RpsFormat = 71;
#[doc = " 4-channel block compressed format with the first channel being a normalized, 5-bit unsigned integer SRGB value,\n the second one a normalized, 6-bit unsigned integer SRGB value, the third one a normalized, 5-bit unsigned\n integer SRGB value and the last one a normalized, 0-bit or 1-bit unsigned integer SRGB value."]
pub const RpsFormat_RPS_FORMAT_BC1_UNORM_SRGB: RpsFormat = 72;
#[doc = " 4-channel block compressed format with the first channel being a typeless 5-bit value, the second one a\n typeless, 6-bit value, the third one a typeless, 5-bit value and the last one a typeless, 4-bit value."]
pub const RpsFormat_RPS_FORMAT_BC2_TYPELESS: RpsFormat = 73;
#[doc = " 4-channel block compressed format with the first channel being a normalized, 5-bit unsigned integer, the second\n one a normalized, 6-bit unsigned integer, the third one a normalized, 5-bit unsigned integer and the last one a\n normalized, 4-bit unsigned integer."]
pub const RpsFormat_RPS_FORMAT_BC2_UNORM: RpsFormat = 74;
#[doc = " 4-channel block compressed format with the first channel being a normalized, 5-bit unsigned integer SRGB value,\n the second one a normalized, 6-bit unsigned integer SRGB value, the third one a normalized, 5-bit unsigned\n integer SRGB value and the last one a normalized, 4-bit unsigned integer SRGB value."]
pub const RpsFormat_RPS_FORMAT_BC2_UNORM_SRGB: RpsFormat = 75;
#[doc = " 4-channel block compressed format with the first channel being a typeless 5-bit value, the second one a\n typeless, 6-bit value, the third one a typeless, 5-bit value and the last one a typeless, 8-bit value."]
pub const RpsFormat_RPS_FORMAT_BC3_TYPELESS: RpsFormat = 76;
#[doc = " 4-channel block compressed format with the first channel being a normalized, 5-bit unsigned integer, the second\n one a normalized, 6-bit unsigned integer, the third one a normalized, 5-bit unsigned integer and the last one a\n normalized, 8-bit unsigned integer."]
pub const RpsFormat_RPS_FORMAT_BC3_UNORM: RpsFormat = 77;
#[doc = " 4-channel block compressed format with the first channel being a normalized, 5-bit unsigned integer SRGB value,\n the second one a normalized, 6-bit unsigned integer SRGB value, the third one a normalized, 5-bit unsigned\n integer SRGB value and the last one a normalized, 0-bit or 1-bit unsigned integer SRGB value."]
pub const RpsFormat_RPS_FORMAT_BC3_UNORM_SRGB: RpsFormat = 78;
#[doc = " Single channel block compressed format with the channel being a typeless 8-bit value."]
pub const RpsFormat_RPS_FORMAT_BC4_TYPELESS: RpsFormat = 79;
#[doc = " Single channel block compressed format with the channel being a normalized, 8-bit signed integer value."]
pub const RpsFormat_RPS_FORMAT_BC4_UNORM: RpsFormat = 80;
#[doc = " Single channel block compressed format with the channel being a normalized, 8-bit signed integer value."]
pub const RpsFormat_RPS_FORMAT_BC4_SNORM: RpsFormat = 81;
#[doc = " 2-channel block compressed format with each channel being a typeless 8-bit value."]
pub const RpsFormat_RPS_FORMAT_BC5_TYPELESS: RpsFormat = 82;
#[doc = " 2-channel block compressed format with each channel being a normalized, 8-bit unsigned integer value."]
pub const RpsFormat_RPS_FORMAT_BC5_UNORM: RpsFormat = 83;
#[doc = " 2-channel block compressed format with each channel being a normalized, 8-bit signed integer value."]
pub const RpsFormat_RPS_FORMAT_BC5_SNORM: RpsFormat = 84;
#[doc = " 3-channel BGR format with the first channel being a normalized, 5-bit unsigned integer, the second one a\n normalized, 6-bit unsigned integer and the third one a normalized, 5-bit unsigned integer."]
pub const RpsFormat_RPS_FORMAT_B5G6R5_UNORM: RpsFormat = 85;
#[doc = " 4-channel BGRA format with the first three channels being a normalized, 5-bit unsigned integer and the last one\n a normalized, 1-bit unsigned integer."]
pub const RpsFormat_RPS_FORMAT_B5G5R5A1_UNORM: RpsFormat = 86;
#[doc = " 4-channel BGRA format with each channel being a normalized, 8-bit unsigned integer."]
pub const RpsFormat_RPS_FORMAT_B8G8R8A8_UNORM: RpsFormat = 87;
#[doc = " 3-channel BGR format with each channel being a normalized, 8-bit unsigned integer value and 8 unused bits at the\n end."]
pub const RpsFormat_RPS_FORMAT_B8G8R8X8_UNORM: RpsFormat = 88;
#[doc = " 4-channel RGB 2.8-biased fixed-point format with the first three channels being a normalized, 10-bit\n unsigned integer and the last one a normalized 2-bit unsigned integer."]
pub const RpsFormat_RPS_FORMAT_R10G10B10_XR_BIAS_A2_UNORM: RpsFormat = 89;
#[doc = "< 4-channel BGRA format with each channel being a typeless 8-bit value."]
pub const RpsFormat_RPS_FORMAT_B8G8R8A8_TYPELESS: RpsFormat = 90;
#[doc = "< 4-channel BGRA format with each channel being a normalized, 8-bit unsigned"]
pub const RpsFormat_RPS_FORMAT_B8G8R8A8_UNORM_SRGB: RpsFormat = 91;
#[doc = "< 3-channel BGR format with each channel being a typeless 8-bit value and 8"]
pub const RpsFormat_RPS_FORMAT_B8G8R8X8_TYPELESS: RpsFormat = 92;
#[doc = "< 3-channel BGR format with each channel being a normalized, 8-bit unsigned"]
pub const RpsFormat_RPS_FORMAT_B8G8R8X8_UNORM_SRGB: RpsFormat = 93;
#[doc = " 3-channel block compressed HDR format with each channel being a typeless 16-bit value."]
pub const RpsFormat_RPS_FORMAT_BC6H_TYPELESS: RpsFormat = 94;
#[doc = " 3-channel block compressed HDR format with each channel being a 16-bit unsigned \"half\" floating point value."]
pub const RpsFormat_RPS_FORMAT_BC6H_UF16: RpsFormat = 95;
#[doc = " 3-channel block compressed HDR format with each channel being a 16-bit signed \"half\" floating point value."]
pub const RpsFormat_RPS_FORMAT_BC6H_SF16: RpsFormat = 96;
#[doc = " 3-channel or 4-channel block compressed format with the first three channels being a typeless, 4-7-bit value and\n the last one an optional, typeless 0-8-bit value."]
pub const RpsFormat_RPS_FORMAT_BC7_TYPELESS: RpsFormat = 97;
#[doc = " 3-channel or 4-channel block compressed format with the first three channels being an normalized, 4-7-bit\n unsigned integer and the last one an optional, normalized, 0-8-bit unsigned integer."]
pub const RpsFormat_RPS_FORMAT_BC7_UNORM: RpsFormat = 98;
#[doc = " 3-channel or 4-channel block compressed format with the first three channels being an normalized, 4-7-bit\n unsigned integer and the last one an optional, normalized, 0-8-bit unsigned integer ."]
pub const RpsFormat_RPS_FORMAT_BC7_UNORM_SRGB: RpsFormat = 99;
#[doc = "< 4-channel video resource format with each channel being a 8-bit value."]
pub const RpsFormat_RPS_FORMAT_AYUV: RpsFormat = 100;
#[doc = "< 4-channel video resource format with each of the first three channels being a"]
pub const RpsFormat_RPS_FORMAT_Y410: RpsFormat = 101;
#[doc = "< 4-channel video resource format with each channel being a 16-bit value."]
pub const RpsFormat_RPS_FORMAT_Y416: RpsFormat = 102;
#[doc = "< 2-channel video resource format with each channel being a 8-bit value."]
pub const RpsFormat_RPS_FORMAT_NV12: RpsFormat = 103;
#[doc = "< 2-channel video resource format with each channel being a 16-bit value."]
pub const RpsFormat_RPS_FORMAT_P010: RpsFormat = 104;
#[doc = "< 2-channel video resource format with each channel being a 8-bit value."]
pub const RpsFormat_RPS_FORMAT_P016: RpsFormat = 105;
#[doc = "< Video resource format with opaque layout."]
pub const RpsFormat_RPS_FORMAT_420_OPAQUE: RpsFormat = 106;
#[doc = "< 4-channel video resource format with each channel being a 8-bit value."]
pub const RpsFormat_RPS_FORMAT_YUY2: RpsFormat = 107;
#[doc = "< 4-channel video resource format with each channel being a 16-bit value."]
pub const RpsFormat_RPS_FORMAT_Y210: RpsFormat = 108;
#[doc = "< 4-channel video resource format with each channel being a 16-bit value."]
pub const RpsFormat_RPS_FORMAT_Y216: RpsFormat = 109;
#[doc = "< 2-channel video resource format with each channel being a 8-bit value."]
pub const RpsFormat_RPS_FORMAT_NV11: RpsFormat = 110;
#[doc = "< 4-bit palletized video resource format."]
pub const RpsFormat_RPS_FORMAT_AI44: RpsFormat = 111;
#[doc = "< 4-bit palletized video resource format."]
pub const RpsFormat_RPS_FORMAT_IA44: RpsFormat = 112;
#[doc = "< RGB video resource format with 8-bit palletization."]
pub const RpsFormat_RPS_FORMAT_P8: RpsFormat = 113;
#[doc = "< RGB video resource format with 8-bit palletization."]
pub const RpsFormat_RPS_FORMAT_A8P8: RpsFormat = 114;
#[doc = "< 4-channels BGRA format with each channel being a normalized 4-bit unsigned integer."]
pub const RpsFormat_RPS_FORMAT_B4G4R4A4_UNORM: RpsFormat = 115;
#[doc = "< Number of formats available in <c><i>RpsFormat</i></c>."]
pub const RpsFormat_RPS_FORMAT_COUNT: RpsFormat = 116;
#[doc = " @brief Supported RPS formats."]
pub type RpsFormat = ::std::os::raw::c_uint;
extern "C" {
    #[doc = " @brief Returns whether a format is block compressed.\n\n All block compressed formats start with the prefix RPS_FORMAT_BC.\n\n @param format       Format to check.\n\n @returns            RPS_TRUE if the format is block compressed, RPS_FALSE otherwise."]
    #[link_name = "\u{1}_Z26rpsFormatIsBlockCompressed9RpsFormat"]
    pub fn rpsFormatIsBlockCompressed(format: RpsFormat) -> RpsBool;
}
extern "C" {
    #[doc = " @brief Returns whether a format has a depth or a stencil component.\n\n @param format       Format to check.\n\n @returns            RPS_TRUE if the format has a depth or a stencil component, RPS_FALSE otherwise."]
    #[link_name = "\u{1}_Z24rpsFormatHasDepthStencil9RpsFormat"]
    pub fn rpsFormatHasDepthStencil(format: RpsFormat) -> RpsBool;
}
extern "C" {
    #[doc = " @brief Returns whether a format has a depth component.\n\n @param format       Format to check.\n\n @returns            RPS_TRUE if the format has a depth component, RPS_FALSE otherwise."]
    #[link_name = "\u{1}_Z17rpsFormatHasDepth9RpsFormat"]
    pub fn rpsFormatHasDepth(format: RpsFormat) -> RpsBool;
}
extern "C" {
    #[doc = " @brief Returns whether a format has a stencil component.\n\n @param format       Format to check.\n\n @returns            RPS_TRUE if the format has a stencil component, RPS_FALSE otherwise."]
    #[link_name = "\u{1}_Z19rpsFormatHasStencil9RpsFormat"]
    pub fn rpsFormatHasStencil(format: RpsFormat) -> RpsBool;
}
extern "C" {
    #[doc = " @brief Returns whether a format has only a depth component and no stencil component.\n\n @param format       Format to check.\n\n @returns            RPS_TRUE if the format has a stencil component and no stencil component, RPS_FALSE otherwise."]
    #[link_name = "\u{1}_Z20rpsFormatIsDepthOnly9RpsFormat"]
    pub fn rpsFormatIsDepthOnly(format: RpsFormat) -> RpsBool;
}
extern "C" {
    #[doc = " @brief Returns the single element byte size for a format.\n\n For most formats one element is one pixel. This is different for block compressed formats, e.g.\n RPS_FORMAT_BC1_UNORM. The byte size of one block will be returned for these instead.\n\n @param format       Format to check.\n\n @returns            0 if the format does not support element wise usage, size of bytes of a single element otherwise."]
    #[link_name = "\u{1}_Z24rpsGetFormatElementBytes9RpsFormat"]
    pub fn rpsGetFormatElementBytes(format: RpsFormat) -> u32;
}
extern "C" {
    #[doc = " @brief Gets the name string of a format.\n\n @param format       Format to get its name for.\n\n @returns            Null terminated string with the format name."]
    #[link_name = "\u{1}_Z16rpsFormatGetName9RpsFormat"]
    pub fn rpsFormatGetName(format: RpsFormat) -> *const ::std::os::raw::c_char;
}
#[doc = " @brief Type for resource identifiers."]
pub type RpsResourceId = u32;
#[doc = "< Resource type is unknown / invalid."]
pub const RpsResourceType_RPS_RESOURCE_TYPE_UNKNOWN: RpsResourceType = 0;
#[doc = "< A buffer resource type."]
pub const RpsResourceType_RPS_RESOURCE_TYPE_BUFFER: RpsResourceType = 1;
#[doc = "< A 1D image resource type."]
pub const RpsResourceType_RPS_RESOURCE_TYPE_IMAGE_1D: RpsResourceType = 2;
#[doc = "< A 2D image resource type."]
pub const RpsResourceType_RPS_RESOURCE_TYPE_IMAGE_2D: RpsResourceType = 3;
#[doc = "< A 3D image resource type."]
pub const RpsResourceType_RPS_RESOURCE_TYPE_IMAGE_3D: RpsResourceType = 4;
#[doc = "< Count of defined resource type values."]
pub const RpsResourceType_RPS_RESOURCE_TYPE_COUNT: RpsResourceType = 5;
#[doc = " @brief Resource types used by RPS resources."]
pub type RpsResourceType = ::std::os::raw::c_uint;
#[doc = "< No special properties."]
pub const RpsResourceFlagBits_RPS_RESOURCE_FLAG_NONE: RpsResourceFlagBits = 0;
#[doc = "< Supports cubemap views."]
pub const RpsResourceFlagBits_RPS_RESOURCE_FLAG_CUBEMAP_COMPATIBLE_BIT: RpsResourceFlagBits = 2;
#[doc = "< Uses rowmajor image layout."]
pub const RpsResourceFlagBits_RPS_RESOURCE_FLAG_ROWMAJOR_IMAGE_BIT: RpsResourceFlagBits = 4;
#[doc = "< Preferred to be in GPU-local CPU-visible heap"]
pub const RpsResourceFlagBits_RPS_RESOURCE_FLAG_PREFER_GPU_LOCAL_CPU_VISIBLE_BIT:
    RpsResourceFlagBits = 8;
#[doc = "< Preferred to be in dedicated allocation or as"]
pub const RpsResourceFlagBits_RPS_RESOURCE_FLAG_PREFER_DEDICATED_ALLOCATION_BIT:
    RpsResourceFlagBits = 16;
#[doc = "< Resource data is persistent from frame to"]
pub const RpsResourceFlagBits_RPS_RESOURCE_FLAG_PERSISTENT_BIT: RpsResourceFlagBits = 32768;
#[doc = " @brief Bitflags for special properties of a resource."]
pub type RpsResourceFlagBits = ::std::os::raw::c_uint;
#[doc = " @brief Bitmask type for <c><i>RpsResourceFlagBits</i></c>."]
pub type RpsResourceFlags = RpsFlags32;
pub const RpsImageAspectUsageFlagBits_RPS_IMAGE_ASPECT_UNKNOWN: RpsImageAspectUsageFlagBits = 0;
#[doc = " Image aspect usage is unknown."]
pub const RpsImageAspectUsageFlagBits_RPS_IMAGE_ASPECT_COLOR: RpsImageAspectUsageFlagBits = 1;
#[doc = " The color aspect is used."]
pub const RpsImageAspectUsageFlagBits_RPS_IMAGE_ASPECT_DEPTH: RpsImageAspectUsageFlagBits = 2;
#[doc = " The depth aspect is used."]
pub const RpsImageAspectUsageFlagBits_RPS_IMAGE_ASPECT_STENCIL: RpsImageAspectUsageFlagBits = 4;
#[doc = " The stencil aspect is used."]
pub const RpsImageAspectUsageFlagBits_RPS_IMAGE_ASPECT_METADATA: RpsImageAspectUsageFlagBits = 8;
#[doc = " The metadata aspect is used."]
pub const RpsImageAspectUsageFlagBits_RPS_IMAGE_ASPECT_DEFAULT: RpsImageAspectUsageFlagBits = 1;
#[doc = " @brief Bitflags for used aspects of an image resource."]
pub type RpsImageAspectUsageFlagBits = ::std::os::raw::c_uint;
#[doc = " @brief Bitmask type for <c><i>RpsImageAspectUsageFlagBits</i></c>."]
pub type RpsImageAspectUsageFlags = RpsFlags32;
#[doc = " @brief RGBA color value to use for clearing a resource.\n\n Depending on the underlying format of a resource, an appropriately\n typed member of this union should be used."]
#[repr(C)]
#[derive(Copy, Clone)]
pub union RpsClearColorValue {
    #[doc = "< 4-tuple of IEEE 754 floating point values representing an RGBA clear color."]
    pub float32: [f32; 4usize],
    #[doc = "< 4-tuple of signed integers representing an RGBA clear color."]
    pub int32: [i32; 4usize],
    #[doc = "< 4-tuple of unsigned integers representing an RGBA clear color."]
    pub uint32: [u32; 4usize],
}
#[test]
fn bindgen_test_layout_RpsClearColorValue() {
    const UNINIT: ::std::mem::MaybeUninit<RpsClearColorValue> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<RpsClearColorValue>(),
        16usize,
        concat!("Size of: ", stringify!(RpsClearColorValue))
    );
    assert_eq!(
        ::std::mem::align_of::<RpsClearColorValue>(),
        4usize,
        concat!("Alignment of ", stringify!(RpsClearColorValue))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).float32) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RpsClearColorValue),
            "::",
            stringify!(float32)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).int32) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RpsClearColorValue),
            "::",
            stringify!(int32)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).uint32) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RpsClearColorValue),
            "::",
            stringify!(uint32)
        )
    );
}
impl ::std::fmt::Debug for RpsClearColorValue {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(f, "RpsClearColorValue {{ union }}")
    }
}
#[doc = "< No clear flags are specified. (Not a valid use case)."]
pub const RpsClearFlags_RPS_CLEAR_FLAG_NONE: RpsClearFlags = 0;
#[doc = "< Clears the color aspect of a render target view."]
pub const RpsClearFlags_RPS_CLEAR_FLAG_COLOR: RpsClearFlags = 1;
#[doc = "< Clears the depth aspect of a depth stencil view."]
pub const RpsClearFlags_RPS_CLEAR_FLAG_DEPTH: RpsClearFlags = 2;
#[doc = "< Clears the stencil aspect of a depth stencil view."]
pub const RpsClearFlags_RPS_CLEAR_FLAG_STENCIL: RpsClearFlags = 4;
#[doc = "< Clears the UAV with floating point data."]
pub const RpsClearFlags_RPS_CLEAR_FLAG_UAVFLOAT: RpsClearFlags = 8;
#[doc = "< Clears the UAV with integer data."]
pub const RpsClearFlags_RPS_CLEAR_FLAG_UAVUINT: RpsClearFlags = 16;
#[doc = " @brief Bitflags for the way a resource should be cleared."]
pub type RpsClearFlags = ::std::os::raw::c_uint;
#[doc = " @brief Parameters for clearing a depth stencil resource."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RpsClearDepthStencilValue {
    #[doc = "< Clear value for the depth aspect."]
    pub depth: f32,
    #[doc = "< Clear value for the stencil aspect."]
    pub stencil: u32,
}
#[test]
fn bindgen_test_layout_RpsClearDepthStencilValue() {
    const UNINIT: ::std::mem::MaybeUninit<RpsClearDepthStencilValue> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<RpsClearDepthStencilValue>(),
        8usize,
        concat!("Size of: ", stringify!(RpsClearDepthStencilValue))
    );
    assert_eq!(
        ::std::mem::align_of::<RpsClearDepthStencilValue>(),
        4usize,
        concat!("Alignment of ", stringify!(RpsClearDepthStencilValue))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).depth) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RpsClearDepthStencilValue),
            "::",
            stringify!(depth)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).stencil) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(RpsClearDepthStencilValue),
            "::",
            stringify!(stencil)
        )
    );
}
#[doc = " @brief General value a resource can be cleared to.\n\n Depending on the context and target resource view format, an appropriately\n typed member of this union should be used."]
#[repr(C)]
#[derive(Copy, Clone)]
pub union RpsClearValue {
    #[doc = "< Clear value for a color resource."]
    pub color: RpsClearColorValue,
    #[doc = "< Clear value for a depth stencil resource."]
    pub depthStencil: RpsClearDepthStencilValue,
}
#[test]
fn bindgen_test_layout_RpsClearValue() {
    const UNINIT: ::std::mem::MaybeUninit<RpsClearValue> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<RpsClearValue>(),
        16usize,
        concat!("Size of: ", stringify!(RpsClearValue))
    );
    assert_eq!(
        ::std::mem::align_of::<RpsClearValue>(),
        4usize,
        concat!("Alignment of ", stringify!(RpsClearValue))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).color) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RpsClearValue),
            "::",
            stringify!(color)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).depthStencil) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RpsClearValue),
            "::",
            stringify!(depthStencil)
        )
    );
}
impl ::std::fmt::Debug for RpsClearValue {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(f, "RpsClearValue {{ union }}")
    }
}
#[doc = " @brief Parameters for clearing a resource."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct RpsClearInfo {
    #[doc = "< Format of the resource view to use for clearing."]
    pub format: RpsFormat,
    #[doc = "< Clear value."]
    pub value: RpsClearValue,
}
#[test]
fn bindgen_test_layout_RpsClearInfo() {
    const UNINIT: ::std::mem::MaybeUninit<RpsClearInfo> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<RpsClearInfo>(),
        20usize,
        concat!("Size of: ", stringify!(RpsClearInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<RpsClearInfo>(),
        4usize,
        concat!("Alignment of ", stringify!(RpsClearInfo))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).format) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RpsClearInfo),
            "::",
            stringify!(format)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(RpsClearInfo),
            "::",
            stringify!(value)
        )
    );
}
impl ::std::fmt::Debug for RpsClearInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(
            f,
            "RpsClearInfo {{ format: {:?}, value: {:?} }}",
            self.format, self.value
        )
    }
}
#[doc = " @brief Parameters for a resource description."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct RpsResourceDesc {
    #[doc = "< Resource type."]
    pub type_: RpsResourceType,
    #[doc = "< Number of temporal layers the resource consists of."]
    pub temporalLayers: u32,
    #[doc = "< Resource flags for special properties."]
    pub flags: RpsResourceFlags,
    pub __bindgen_anon_1: RpsResourceDesc__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union RpsResourceDesc__bindgen_ty_1 {
    pub image: RpsResourceDesc__bindgen_ty_1__bindgen_ty_1,
    pub buffer: RpsResourceDesc__bindgen_ty_1__bindgen_ty_2,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct RpsResourceDesc__bindgen_ty_1__bindgen_ty_1 {
    #[doc = "< Width of an image resource."]
    pub width: u32,
    #[doc = "< Height of an image resource."]
    pub height: u32,
    pub __bindgen_anon_1: RpsResourceDesc__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
    #[doc = "< Number of mipmap levels."]
    pub mipLevels: u32,
    #[doc = "< Platform independent format to be interpreted by the runtime."]
    pub format: RpsFormat,
    #[doc = "< Number of MSAA samples of an image."]
    pub sampleCount: u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union RpsResourceDesc__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
    #[doc = "< Depth of a 3D image resource."]
    pub depth: u32,
    #[doc = "< Number of array layers for a non-3D image resource."]
    pub arrayLayers: u32,
}
#[test]
fn bindgen_test_layout_RpsResourceDesc__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<
        RpsResourceDesc__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<RpsResourceDesc__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(RpsResourceDesc__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<RpsResourceDesc__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(RpsResourceDesc__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).depth) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RpsResourceDesc__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(depth)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).arrayLayers) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RpsResourceDesc__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(arrayLayers)
        )
    );
}
impl ::std::fmt::Debug for RpsResourceDesc__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(
            f,
            "RpsResourceDesc__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {{ union }}"
        )
    }
}
#[test]
fn bindgen_test_layout_RpsResourceDesc__bindgen_ty_1__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<RpsResourceDesc__bindgen_ty_1__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<RpsResourceDesc__bindgen_ty_1__bindgen_ty_1>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(RpsResourceDesc__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<RpsResourceDesc__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(RpsResourceDesc__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).width) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RpsResourceDesc__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).height) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(RpsResourceDesc__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mipLevels) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(RpsResourceDesc__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(mipLevels)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).format) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(RpsResourceDesc__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(format)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sampleCount) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(RpsResourceDesc__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(sampleCount)
        )
    );
}
impl ::std::fmt::Debug for RpsResourceDesc__bindgen_ty_1__bindgen_ty_1 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write ! (f , "RpsResourceDesc__bindgen_ty_1__bindgen_ty_1 {{ __bindgen_anon_1: {:?}, format: {:?} }}" , self . __bindgen_anon_1 , self . format)
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RpsResourceDesc__bindgen_ty_1__bindgen_ty_2 {
    #[doc = "< Lower 32 bits of the size of a buffer resource in bytes."]
    pub sizeInBytesLo: u32,
    #[doc = "< Higher 32 bits of the size of a buffer resource in bytes."]
    pub sizeInBytesHi: u32,
}
#[test]
fn bindgen_test_layout_RpsResourceDesc__bindgen_ty_1__bindgen_ty_2() {
    const UNINIT: ::std::mem::MaybeUninit<RpsResourceDesc__bindgen_ty_1__bindgen_ty_2> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<RpsResourceDesc__bindgen_ty_1__bindgen_ty_2>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(RpsResourceDesc__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<RpsResourceDesc__bindgen_ty_1__bindgen_ty_2>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(RpsResourceDesc__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sizeInBytesLo) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RpsResourceDesc__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(sizeInBytesLo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sizeInBytesHi) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(RpsResourceDesc__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(sizeInBytesHi)
        )
    );
}
#[test]
fn bindgen_test_layout_RpsResourceDesc__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<RpsResourceDesc__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<RpsResourceDesc__bindgen_ty_1>(),
        24usize,
        concat!("Size of: ", stringify!(RpsResourceDesc__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<RpsResourceDesc__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(RpsResourceDesc__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).image) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RpsResourceDesc__bindgen_ty_1),
            "::",
            stringify!(image)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).buffer) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RpsResourceDesc__bindgen_ty_1),
            "::",
            stringify!(buffer)
        )
    );
}
impl ::std::fmt::Debug for RpsResourceDesc__bindgen_ty_1 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(f, "RpsResourceDesc__bindgen_ty_1 {{ union }}")
    }
}
#[test]
fn bindgen_test_layout_RpsResourceDesc() {
    const UNINIT: ::std::mem::MaybeUninit<RpsResourceDesc> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<RpsResourceDesc>(),
        36usize,
        concat!("Size of: ", stringify!(RpsResourceDesc))
    );
    assert_eq!(
        ::std::mem::align_of::<RpsResourceDesc>(),
        4usize,
        concat!("Alignment of ", stringify!(RpsResourceDesc))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RpsResourceDesc),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).temporalLayers) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(RpsResourceDesc),
            "::",
            stringify!(temporalLayers)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(RpsResourceDesc),
            "::",
            stringify!(flags)
        )
    );
}
impl ::std::fmt::Debug for RpsResourceDesc {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(
            f,
            "RpsResourceDesc {{ type: {:?}, __bindgen_anon_1: {:?} }}",
            self.type_, self.__bindgen_anon_1
        )
    }
}
#[doc = " @brief Subsection of a resource from the graphics API perspective."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RpsSubresourceRange {
    #[doc = "< First mipmapping level accessible in the range."]
    pub baseMipLevel: u16,
    #[doc = "< Number of mipmap levels in the range."]
    pub mipLevels: u16,
    #[doc = "< First layer accessible in the range."]
    pub baseArrayLayer: u32,
    #[doc = "< Number of array layers accessible in the range."]
    pub arrayLayers: u32,
}
#[test]
fn bindgen_test_layout_RpsSubresourceRange() {
    const UNINIT: ::std::mem::MaybeUninit<RpsSubresourceRange> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<RpsSubresourceRange>(),
        12usize,
        concat!("Size of: ", stringify!(RpsSubresourceRange))
    );
    assert_eq!(
        ::std::mem::align_of::<RpsSubresourceRange>(),
        4usize,
        concat!("Alignment of ", stringify!(RpsSubresourceRange))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).baseMipLevel) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RpsSubresourceRange),
            "::",
            stringify!(baseMipLevel)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mipLevels) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(RpsSubresourceRange),
            "::",
            stringify!(mipLevels)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).baseArrayLayer) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(RpsSubresourceRange),
            "::",
            stringify!(baseArrayLayer)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).arrayLayers) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(RpsSubresourceRange),
            "::",
            stringify!(arrayLayers)
        )
    );
}
#[doc = " @brief Output resources for writing results of a graphics node."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RpsCmdRenderTargetInfo {
    #[doc = "< Number of render targets used by the node."]
    pub numRenderTargets: u32,
    #[doc = "< Number of MSAA samples."]
    pub numSamples: u32,
    #[doc = "< Depth stencil format or RPS_FORMAT_UNKNOWN if no depth buffer is bound."]
    pub depthStencilFormat: RpsFormat,
    #[doc = " Array of render target formats with one format for each of the numRenderTargets render targets."]
    pub renderTargetFormats: [RpsFormat; 8usize],
}
#[test]
fn bindgen_test_layout_RpsCmdRenderTargetInfo() {
    const UNINIT: ::std::mem::MaybeUninit<RpsCmdRenderTargetInfo> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<RpsCmdRenderTargetInfo>(),
        44usize,
        concat!("Size of: ", stringify!(RpsCmdRenderTargetInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<RpsCmdRenderTargetInfo>(),
        4usize,
        concat!("Alignment of ", stringify!(RpsCmdRenderTargetInfo))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).numRenderTargets) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RpsCmdRenderTargetInfo),
            "::",
            stringify!(numRenderTargets)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).numSamples) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(RpsCmdRenderTargetInfo),
            "::",
            stringify!(numSamples)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).depthStencilFormat) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(RpsCmdRenderTargetInfo),
            "::",
            stringify!(depthStencilFormat)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).renderTargetFormats) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(RpsCmdRenderTargetInfo),
            "::",
            stringify!(renderTargetFormats)
        )
    );
}
#[doc = "< Unknown access."]
pub const RpsAccessFlagBits_RPS_ACCESS_UNKNOWN: RpsAccessFlagBits = 0;
#[doc = "< Accessible as an indirect argument buffer."]
pub const RpsAccessFlagBits_RPS_ACCESS_INDIRECT_ARGS_BIT: RpsAccessFlagBits = 1;
#[doc = "< Accessible as an index buffer."]
pub const RpsAccessFlagBits_RPS_ACCESS_INDEX_BUFFER_BIT: RpsAccessFlagBits = 2;
#[doc = "< Accessible as a vertex buffer."]
pub const RpsAccessFlagBits_RPS_ACCESS_VERTEX_BUFFER_BIT: RpsAccessFlagBits = 4;
#[doc = "< Accessible as a constant buffer."]
pub const RpsAccessFlagBits_RPS_ACCESS_CONSTANT_BUFFER_BIT: RpsAccessFlagBits = 8;
#[doc = "< Accessible as a shader resource (readonly) view."]
pub const RpsAccessFlagBits_RPS_ACCESS_SHADER_RESOURCE_BIT: RpsAccessFlagBits = 16;
#[doc = "< Accessible as a unordered access (shader readwrite) view."]
pub const RpsAccessFlagBits_RPS_ACCESS_UNORDERED_ACCESS_BIT: RpsAccessFlagBits = 32;
#[doc = "< Accessible as a shading rate image in a Variable Rate Shading"]
pub const RpsAccessFlagBits_RPS_ACCESS_SHADING_RATE_BIT: RpsAccessFlagBits = 64;
#[doc = "< Accessible as a render target view."]
pub const RpsAccessFlagBits_RPS_ACCESS_RENDER_TARGET_BIT: RpsAccessFlagBits = 128;
#[doc = "< Accessible as a readonly depth view."]
pub const RpsAccessFlagBits_RPS_ACCESS_DEPTH_READ_BIT: RpsAccessFlagBits = 256;
#[doc = "< Accessible as a writable depth view."]
pub const RpsAccessFlagBits_RPS_ACCESS_DEPTH_WRITE_BIT: RpsAccessFlagBits = 512;
#[doc = "< Accessible as a readonly stencil view."]
pub const RpsAccessFlagBits_RPS_ACCESS_STENCIL_READ_BIT: RpsAccessFlagBits = 1024;
#[doc = "< Accessible as a writable stencil view."]
pub const RpsAccessFlagBits_RPS_ACCESS_STENCIL_WRITE_BIT: RpsAccessFlagBits = 2048;
#[doc = "< Accessible for write as a stream out buffer."]
pub const RpsAccessFlagBits_RPS_ACCESS_STREAM_OUT_BIT: RpsAccessFlagBits = 4096;
#[doc = "< Accessible as a copy source."]
pub const RpsAccessFlagBits_RPS_ACCESS_COPY_SRC_BIT: RpsAccessFlagBits = 8192;
#[doc = "< Accessible as a copy target."]
pub const RpsAccessFlagBits_RPS_ACCESS_COPY_DEST_BIT: RpsAccessFlagBits = 16384;
#[doc = "< Accessible as a resolve source."]
pub const RpsAccessFlagBits_RPS_ACCESS_RESOLVE_SRC_BIT: RpsAccessFlagBits = 32768;
#[doc = "< Accessible as a resolve target."]
pub const RpsAccessFlagBits_RPS_ACCESS_RESOLVE_DEST_BIT: RpsAccessFlagBits = 65536;
#[doc = "< Accessible for write (build) as a raytracing acceleration"]
pub const RpsAccessFlagBits_RPS_ACCESS_RAYTRACING_AS_BUILD_BIT: RpsAccessFlagBits = 131072;
#[doc = "< Accessible for read as a raytracing acceleration structure."]
pub const RpsAccessFlagBits_RPS_ACCESS_RAYTRACING_AS_READ_BIT: RpsAccessFlagBits = 262144;
#[doc = "< Accessible as a present source."]
pub const RpsAccessFlagBits_RPS_ACCESS_PRESENT_BIT: RpsAccessFlagBits = 524288;
#[doc = "< Accessible for reads by the CPU."]
pub const RpsAccessFlagBits_RPS_ACCESS_CPU_READ_BIT: RpsAccessFlagBits = 1048576;
#[doc = "< Accessible for writes by the CPU."]
pub const RpsAccessFlagBits_RPS_ACCESS_CPU_WRITE_BIT: RpsAccessFlagBits = 2097152;
#[doc = " Access does not read existing data so it can be discarded. Does not apply to the stencil aspect."]
pub const RpsAccessFlagBits_RPS_ACCESS_DISCARD_DATA_BEFORE_BIT: RpsAccessFlagBits = 4194304;
#[doc = " Data can be discarded after current access (node). Does not apply to the stencil aspect.\n This is typically not programmed directly, but added internally during subresource data lifetime analysis\n based on if the data will be accessed afterwards. However it can be used to force discarding the data."]
pub const RpsAccessFlagBits_RPS_ACCESS_DISCARD_DATA_AFTER_BIT: RpsAccessFlagBits = 8388608;
#[doc = " Stencil access does not read existing data so it can be discarded. Applies only to the stencil aspect."]
pub const RpsAccessFlagBits_RPS_ACCESS_STENCIL_DISCARD_DATA_BEFORE_BIT: RpsAccessFlagBits =
    16777216;
#[doc = " Stencil data can be discarded after current access (node). Applies only to the stencil aspect.\n This is typically not programmed directly, but added internally during subresource data lifetime analysis\n based on if the data will be accessed afterwards. However it can be used to force discarding the data."]
pub const RpsAccessFlagBits_RPS_ACCESS_STENCIL_DISCARD_DATA_AFTER_BIT: RpsAccessFlagBits = 33554432;
#[doc = " Initial state when entering the node. This allows a view to have a different state at entering and exiting,\n in case the node implementation needs to perform a transition but does not want to transition it back to the\n original state. Not implemented yet."]
pub const RpsAccessFlagBits_RPS_ACCESS_BEFORE_BIT: RpsAccessFlagBits = 67108864;
#[doc = " Final state when exiting the node. This allows a view to have a different state at entering and exiting,\n in case the node implementation needs to perform a transition but does not want to transition it back to the\n original state. Not implemented yet."]
pub const RpsAccessFlagBits_RPS_ACCESS_AFTER_BIT: RpsAccessFlagBits = 134217728;
#[doc = " View is cleared before the current access. Usually used together with other basic access flags."]
pub const RpsAccessFlagBits_RPS_ACCESS_CLEAR_BIT: RpsAccessFlagBits = 268435456;
#[doc = " Access can be used by a render pass attachment (as render target or depth stencil). Used to distinguish clear-only\n accesses (which may use special clear commands) and render target / depth stencil view accesses."]
pub const RpsAccessFlagBits_RPS_ACCESS_RENDER_PASS: RpsAccessFlagBits = 536870912;
#[doc = " Access does not care about the ordering with regard to other accesses which also have the\n RPS_ACCESS_RELAXED_ORDER_BIT flag."]
pub const RpsAccessFlagBits_RPS_ACCESS_RELAXED_ORDER_BIT: RpsAccessFlagBits = 1073741824;
#[doc = " Access does not need a resource view to be created, (e.g. via\n ID3D12GraphicsCommandList::CopyResource)."]
pub const RpsAccessFlagBits_RPS_ACCESS_NO_VIEW_BIT: RpsAccessFlagBits = -2147483648;
#[doc = " Accessible as a predication buffer."]
pub const RpsAccessFlagBits_RPS_ACCESS_PREDICATION_BIT: RpsAccessFlagBits = 1;
#[doc = " Depth read write access."]
pub const RpsAccessFlagBits_RPS_ACCESS_DEPTH: RpsAccessFlagBits = 768;
#[doc = " Stencil read write access."]
pub const RpsAccessFlagBits_RPS_ACCESS_STENCIL: RpsAccessFlagBits = 3072;
#[doc = " Depth / Stencil read access."]
pub const RpsAccessFlagBits_RPS_ACCESS_DEPTH_STENCIL_READ: RpsAccessFlagBits = 1280;
#[doc = " Depth / Stencil write access."]
pub const RpsAccessFlagBits_RPS_ACCESS_DEPTH_STENCIL_WRITE: RpsAccessFlagBits = 2560;
#[doc = " Depth / Stencil read write access."]
pub const RpsAccessFlagBits_RPS_ACCESS_DEPTH_STENCIL: RpsAccessFlagBits = 3840;
#[doc = " Bitwise OR of all possible GPU writeable access flags."]
pub const RpsAccessFlagBits_RPS_ACCESS_ALL_GPU_WRITE: RpsAccessFlagBits = 219808;
#[doc = " Bitwise OR of all possible GPU readonly access flags."]
pub const RpsAccessFlagBits_RPS_ACCESS_ALL_GPU_READONLY: RpsAccessFlagBits = 828767;
#[doc = " Bitwise OR of all possible GPU access flags."]
pub const RpsAccessFlagBits_RPS_ACCESS_ALL_GPU: RpsAccessFlagBits = 1048575;
#[doc = " Bitwise OR of all possible CPU access flags."]
pub const RpsAccessFlagBits_RPS_ACCESS_ALL_CPU: RpsAccessFlagBits = 3145728;
#[doc = " Bitwise OR of all GPU / CPU access, excluding decorator flags such as RPS_ACCESS_RELAXED_ORDER_BIT and RPS_ACCESS_NO_VIEW_BIT."]
pub const RpsAccessFlagBits_RPS_ACCESS_ALL_ACCESS_MASK: RpsAccessFlagBits = 4194303;
#[doc = " @brief Bitflags for resource (view) access attributes.\n\n If specified for a node parameter, it indicates the required resource layout and synchronizations before entering\n and after exiting the node."]
pub type RpsAccessFlagBits = ::std::os::raw::c_int;
#[doc = " @brief Bitmask type for <c><i>RpsAccessFlagBits</i></c>."]
pub type RpsAccessFlags = RpsFlags32;
#[doc = "< No shader stages."]
pub const RpsShaderStageBits_RPS_SHADER_STAGE_NONE: RpsShaderStageBits = 0;
#[doc = "< Vertex shader stage."]
pub const RpsShaderStageBits_RPS_SHADER_STAGE_VS: RpsShaderStageBits = 1;
#[doc = "< Pixel shader stage."]
pub const RpsShaderStageBits_RPS_SHADER_STAGE_PS: RpsShaderStageBits = 2;
#[doc = "< Geometry shader stage."]
pub const RpsShaderStageBits_RPS_SHADER_STAGE_GS: RpsShaderStageBits = 4;
#[doc = "< Compute shader stage."]
pub const RpsShaderStageBits_RPS_SHADER_STAGE_CS: RpsShaderStageBits = 8;
#[doc = "< Hull shader stage."]
pub const RpsShaderStageBits_RPS_SHADER_STAGE_HS: RpsShaderStageBits = 16;
#[doc = "< Domain shader stage."]
pub const RpsShaderStageBits_RPS_SHADER_STAGE_DS: RpsShaderStageBits = 32;
#[doc = "< Raytracing shader stage."]
pub const RpsShaderStageBits_RPS_SHADER_STAGE_RAYTRACING: RpsShaderStageBits = 64;
#[doc = "< Amplification shader stage."]
pub const RpsShaderStageBits_RPS_SHADER_STAGE_AS: RpsShaderStageBits = 128;
#[doc = "< Mesh shader stage."]
pub const RpsShaderStageBits_RPS_SHADER_STAGE_MS: RpsShaderStageBits = 256;
#[doc = "< All shader stages."]
pub const RpsShaderStageBits_RPS_SHADER_STAGE_ALL: RpsShaderStageBits = 511;
#[doc = " @brief Bitflags for shader stages."]
pub type RpsShaderStageBits = ::std::os::raw::c_uint;
#[doc = " @brief Bitmask type for <c><i>RpsShaderStageBits</i></c>."]
pub type RpsShaderStageFlags = RpsFlags32;
#[doc = " @brief Resource access attribute."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RpsAccessAttr {
    #[doc = "< Access flags."]
    pub accessFlags: RpsAccessFlags,
    #[doc = "< Shader stages allowed for access if applicable."]
    pub accessStages: RpsShaderStageFlags,
}
#[test]
fn bindgen_test_layout_RpsAccessAttr() {
    const UNINIT: ::std::mem::MaybeUninit<RpsAccessAttr> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<RpsAccessAttr>(),
        8usize,
        concat!("Size of: ", stringify!(RpsAccessAttr))
    );
    assert_eq!(
        ::std::mem::align_of::<RpsAccessAttr>(),
        4usize,
        concat!("Alignment of ", stringify!(RpsAccessAttr))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).accessFlags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RpsAccessAttr),
            "::",
            stringify!(accessFlags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).accessStages) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(RpsAccessAttr),
            "::",
            stringify!(accessStages)
        )
    );
}
#[doc = "< No semantics."]
pub const RpsSemantic_RPS_SEMANTIC_UNSPECIFIED: RpsSemantic = 0;
#[doc = "< Reserved for future use."]
pub const RpsSemantic_RPS_SEMANTIC_VERTEX_SHADER: RpsSemantic = 1;
#[doc = "< Reserved for future use."]
pub const RpsSemantic_RPS_SEMANTIC_PIXEL_SHADER: RpsSemantic = 2;
#[doc = "< Reserved for future use."]
pub const RpsSemantic_RPS_SEMANTIC_GEOMETRY_SHADER: RpsSemantic = 3;
#[doc = "< Reserved for future use."]
pub const RpsSemantic_RPS_SEMANTIC_COMPUTE_SHADER: RpsSemantic = 4;
#[doc = "< Reserved for future use."]
pub const RpsSemantic_RPS_SEMANTIC_HULL_SHADER: RpsSemantic = 5;
#[doc = "< Reserved for future use."]
pub const RpsSemantic_RPS_SEMANTIC_DOMAIN_SHADER: RpsSemantic = 6;
#[doc = "< Reserved for future use."]
pub const RpsSemantic_RPS_SEMANTIC_RAYTRACING_PIPELINE: RpsSemantic = 7;
#[doc = "< Reserved for future use."]
pub const RpsSemantic_RPS_SEMANTIC_AMPLIFICATION_SHADER: RpsSemantic = 8;
#[doc = "< Reserved for future use."]
pub const RpsSemantic_RPS_SEMANTIC_MESH_SHADER: RpsSemantic = 9;
#[doc = "< Reserved for future use."]
pub const RpsSemantic_RPS_SEMANTIC_VERTEX_LAYOUT: RpsSemantic = 10;
#[doc = "< Reserved for future use."]
pub const RpsSemantic_RPS_SEMANTIC_STREAM_OUT_LAYOUT: RpsSemantic = 11;
#[doc = "< Reserved for future use."]
pub const RpsSemantic_RPS_SEMANTIC_STREAM_OUT_DESC: RpsSemantic = 12;
#[doc = "< Reserved for future use."]
pub const RpsSemantic_RPS_SEMANTIC_BLEND_STATE: RpsSemantic = 13;
#[doc = "< Reserved for future use."]
pub const RpsSemantic_RPS_SEMANTIC_RENDER_TARGET_BLEND: RpsSemantic = 14;
#[doc = "< Reserved for future use."]
pub const RpsSemantic_RPS_SEMANTIC_DEPTH_STENCIL_STATE: RpsSemantic = 15;
#[doc = "< Reserved for future use."]
pub const RpsSemantic_RPS_SEMANTIC_RASTERIZER_STATE: RpsSemantic = 16;
#[doc = "< Start of the dynamic state semantic enumeration values."]
pub const RpsSemantic_RPS_SEMANTIC_DYNAMIC_STATE_BEGIN: RpsSemantic = 17;
#[doc = " Usage as a viewport. The data type must be <c><i>RpsViewport</i></c>."]
pub const RpsSemantic_RPS_SEMANTIC_VIEWPORT: RpsSemantic = 17;
#[doc = " Usage as a scissor rectangle. The data type must be <c><i>RpsRect</i></c>."]
pub const RpsSemantic_RPS_SEMANTIC_SCISSOR: RpsSemantic = 18;
#[doc = " Usage as primitive topology. The data must be one of the values specified by <c><i>RpsPrimitiveTopology</i></c>."]
pub const RpsSemantic_RPS_SEMANTIC_PRIMITIVE_TOPOLOGY: RpsSemantic = 19;
#[doc = " Reserved for future use."]
pub const RpsSemantic_RPS_SEMANTIC_PATCH_CONTROL_POINTS: RpsSemantic = 20;
#[doc = " Reserved for future use."]
pub const RpsSemantic_RPS_SEMANTIC_PRIMITIVE_STRIP_CUT_INDEX: RpsSemantic = 21;
#[doc = " Reserved for future use."]
pub const RpsSemantic_RPS_SEMANTIC_BLEND_FACTOR: RpsSemantic = 22;
#[doc = " Reserved for future use."]
pub const RpsSemantic_RPS_SEMANTIC_STENCIL_REF: RpsSemantic = 23;
#[doc = " Reserved for future use."]
pub const RpsSemantic_RPS_SEMANTIC_DEPTH_BOUNDS: RpsSemantic = 24;
#[doc = " Reserved for future use."]
pub const RpsSemantic_RPS_SEMANTIC_SAMPLE_LOCATION: RpsSemantic = 25;
#[doc = " Reserved for future use."]
pub const RpsSemantic_RPS_SEMANTIC_SHADING_RATE: RpsSemantic = 26;
#[doc = " Usage as a color clear value. The data type must be float[4]."]
pub const RpsSemantic_RPS_SEMANTIC_COLOR_CLEAR_VALUE: RpsSemantic = 27;
#[doc = " Usage as a depth clear value. The data type must be float."]
pub const RpsSemantic_RPS_SEMANTIC_DEPTH_CLEAR_VALUE: RpsSemantic = 28;
#[doc = " Usage as a stencil clear value. The data type must be uint32_t, only the lower 8 bit will be used."]
pub const RpsSemantic_RPS_SEMANTIC_STENCIL_CLEAR_VALUE: RpsSemantic = 29;
#[doc = " Start of the resource binding enumeration values."]
pub const RpsSemantic_RPS_SEMANTIC_RESOURCE_BINDING_BEGIN: RpsSemantic = 30;
#[doc = " Bound as a vertex buffer. The semantic index indicates the vertex buffer binding slot."]
pub const RpsSemantic_RPS_SEMANTIC_VERTEX_BUFFER: RpsSemantic = 30;
#[doc = " Bound as an index buffer."]
pub const RpsSemantic_RPS_SEMANTIC_INDEX_BUFFER: RpsSemantic = 31;
#[doc = " Bound as an indirect argument buffer."]
pub const RpsSemantic_RPS_SEMANTIC_INDIRECT_ARGS: RpsSemantic = 32;
#[doc = " Bound as an indirect count buffer."]
pub const RpsSemantic_RPS_SEMANTIC_STREAM_OUT_BUFFER: RpsSemantic = 33;
#[doc = " Bound for write as a stream out buffer. The semantic index indicates the stream out buffer binding slot."]
pub const RpsSemantic_RPS_SEMANTIC_INDIRECT_COUNT: RpsSemantic = 34;
#[doc = " Bound as a render target view. The semantic index indicates the render target slot."]
pub const RpsSemantic_RPS_SEMANTIC_RENDER_TARGET: RpsSemantic = 35;
#[doc = " Bound as a depth stencil view."]
pub const RpsSemantic_RPS_SEMANTIC_DEPTH_STENCIL_TARGET: RpsSemantic = 36;
#[doc = " Bound as a shading rate image in a Variable Rate Shading (VRS) pass."]
pub const RpsSemantic_RPS_SEMANTIC_SHADING_RATE_IMAGE: RpsSemantic = 37;
#[doc = " Bound as a resolve target. The semantic index indicates the render\n target slot of the resolve source."]
pub const RpsSemantic_RPS_SEMANTIC_RESOLVE_TARGET: RpsSemantic = 38;
#[doc = " User defined resource view binding. This is intended for shader resource views and unordered access views where\n resources are bound to programmable shaders instead of fixed function binding points."]
pub const RpsSemantic_RPS_SEMANTIC_USER_RESOURCE_BINDING: RpsSemantic = 39;
#[doc = "< Number of defined semantics."]
pub const RpsSemantic_RPS_SEMANTIC_COUNT: RpsSemantic = 40;
#[doc = " @brief Graphics resource and argument data usage semantics."]
pub type RpsSemantic = ::std::os::raw::c_uint;
#[doc = " @brief Graph entry and node parameter semantic attribute."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RpsSemanticAttr {
    pub semantic: RpsSemantic,
    pub semanticIndex: u32,
}
#[test]
fn bindgen_test_layout_RpsSemanticAttr() {
    const UNINIT: ::std::mem::MaybeUninit<RpsSemanticAttr> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<RpsSemanticAttr>(),
        8usize,
        concat!("Size of: ", stringify!(RpsSemanticAttr))
    );
    assert_eq!(
        ::std::mem::align_of::<RpsSemanticAttr>(),
        4usize,
        concat!("Alignment of ", stringify!(RpsSemanticAttr))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).semantic) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RpsSemanticAttr),
            "::",
            stringify!(semantic)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).semanticIndex) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(RpsSemanticAttr),
            "::",
            stringify!(semanticIndex)
        )
    );
}
#[doc = "< No special resource view flags."]
pub const RpsResourceViewFlagBits_RPS_RESOURCE_VIEW_FLAG_NONE: RpsResourceViewFlagBits = 0;
#[doc = "< Resource view is used as a cubemap."]
pub const RpsResourceViewFlagBits_RPS_RESOURCE_VIEW_FLAG_CUBEMAP_BIT: RpsResourceViewFlagBits = 1;
#[doc = " @brief Bitflags for resource view properties."]
pub type RpsResourceViewFlagBits = ::std::os::raw::c_uint;
#[doc = " @brief Bitmask for <c><i>RpsResourceViewFlagBits</i></c>."]
pub type RpsResourceViewFlags = RpsFlags32;
#[doc = " @brief General resource view.\n\n All shared parameters between buffer and image views."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RpsResourceView {
    #[doc = "< Resource ID of the viewed resource. RPS_RESOURCE_ID_INVALID indicates a null"]
    pub resourceId: RpsResourceId,
    #[doc = "< Format of the view. RPS_FORMAT_UNKNOWN indicates the format should be inherited from"]
    pub viewFormat: RpsFormat,
    #[doc = "< Temporal layer of the view. 0 means the current frame,"]
    pub temporalLayer: u32,
    #[doc = "< Flags for additional view properties."]
    pub flags: RpsResourceViewFlags,
}
#[test]
fn bindgen_test_layout_RpsResourceView() {
    const UNINIT: ::std::mem::MaybeUninit<RpsResourceView> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<RpsResourceView>(),
        16usize,
        concat!("Size of: ", stringify!(RpsResourceView))
    );
    assert_eq!(
        ::std::mem::align_of::<RpsResourceView>(),
        4usize,
        concat!("Alignment of ", stringify!(RpsResourceView))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).resourceId) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RpsResourceView),
            "::",
            stringify!(resourceId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).viewFormat) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(RpsResourceView),
            "::",
            stringify!(viewFormat)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).temporalLayer) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(RpsResourceView),
            "::",
            stringify!(temporalLayer)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(RpsResourceView),
            "::",
            stringify!(flags)
        )
    );
}
#[doc = " @brief Image resource view."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RpsImageView {
    #[doc = "< Base resource view properties."]
    pub base: RpsResourceView,
    #[doc = "< Subresource range of the view."]
    pub subresourceRange: RpsSubresourceRange,
    #[doc = "< Min LOD clamp value of the texture view."]
    pub minLodClamp: f32,
    #[doc = "< 32-bit value for the color component (RGBA channel) mapping of the view."]
    pub componentMapping: u32,
}
#[test]
fn bindgen_test_layout_RpsImageView() {
    const UNINIT: ::std::mem::MaybeUninit<RpsImageView> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<RpsImageView>(),
        36usize,
        concat!("Size of: ", stringify!(RpsImageView))
    );
    assert_eq!(
        ::std::mem::align_of::<RpsImageView>(),
        4usize,
        concat!("Alignment of ", stringify!(RpsImageView))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).base) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RpsImageView),
            "::",
            stringify!(base)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).subresourceRange) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(RpsImageView),
            "::",
            stringify!(subresourceRange)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).minLodClamp) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(RpsImageView),
            "::",
            stringify!(minLodClamp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).componentMapping) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(RpsImageView),
            "::",
            stringify!(componentMapping)
        )
    );
}
#[doc = "< Red component."]
pub const RpsResourceViewComponentMapping_RPS_RESOURCE_VIEW_COMPONENT_MAPPING_R:
    RpsResourceViewComponentMapping = 0;
#[doc = "< Green component."]
pub const RpsResourceViewComponentMapping_RPS_RESOURCE_VIEW_COMPONENT_MAPPING_G:
    RpsResourceViewComponentMapping = 1;
#[doc = "< Blue component."]
pub const RpsResourceViewComponentMapping_RPS_RESOURCE_VIEW_COMPONENT_MAPPING_B:
    RpsResourceViewComponentMapping = 2;
#[doc = "< Alpha component"]
pub const RpsResourceViewComponentMapping_RPS_RESOURCE_VIEW_COMPONENT_MAPPING_A:
    RpsResourceViewComponentMapping = 3;
#[doc = "< Constant value of 0."]
pub const RpsResourceViewComponentMapping_RPS_RESOURCE_VIEW_COMPONENT_MAPPING_ZERO:
    RpsResourceViewComponentMapping = 4;
#[doc = "< Constant value of 1."]
pub const RpsResourceViewComponentMapping_RPS_RESOURCE_VIEW_COMPONENT_MAPPING_ONE:
    RpsResourceViewComponentMapping = 5;
#[doc = "  Specifies the default component mapping (where R, G, B, A components map to R, G, B, A without swizzling).\n  Note this is using 1 byte each channel, different from DX12 default."]
pub const RpsResourceViewComponentMapping_RPS_RESOURCE_VIEW_COMPONENT_MAPPING_DEFAULT:
    RpsResourceViewComponentMapping = 50462976;
#[doc = " @brief Resource components or value to map to for component mapping."]
pub type RpsResourceViewComponentMapping = ::std::os::raw::c_uint;
#[doc = " @brief Buffer resource view."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RpsBufferView {
    #[doc = "< Base view properties."]
    pub base: RpsResourceView,
    #[doc = "< Offset of the buffer range in bytes."]
    pub offset: u64,
    #[doc = "< Size of the buffer range in bytes."]
    pub sizeInBytes: u64,
    #[doc = "< Stride of a structured buffer view. If the API does not support altering per-view"]
    pub stride: u32,
}
#[test]
fn bindgen_test_layout_RpsBufferView() {
    const UNINIT: ::std::mem::MaybeUninit<RpsBufferView> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<RpsBufferView>(),
        40usize,
        concat!("Size of: ", stringify!(RpsBufferView))
    );
    assert_eq!(
        ::std::mem::align_of::<RpsBufferView>(),
        8usize,
        concat!("Alignment of ", stringify!(RpsBufferView))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).base) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RpsBufferView),
            "::",
            stringify!(base)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).offset) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(RpsBufferView),
            "::",
            stringify!(offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sizeInBytes) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(RpsBufferView),
            "::",
            stringify!(sizeInBytes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).stride) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(RpsBufferView),
            "::",
            stringify!(stride)
        )
    );
}
#[doc = "< Type ID of RpsImageView."]
pub const RpsRuntimeBuiltInTypeIds_RPS_TYPE_IMAGE_VIEW: RpsRuntimeBuiltInTypeIds = 64;
#[doc = "< Type ID of RpsBufferView."]
pub const RpsRuntimeBuiltInTypeIds_RPS_TYPE_BUFFER_VIEW: RpsRuntimeBuiltInTypeIds = 65;
#[doc = " @brief Enumeration of runtime defined built-in type IDs."]
pub type RpsRuntimeBuiltInTypeIds = ::std::os::raw::c_uint;
#[doc = " Screen region to render to."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RpsViewport {
    #[doc = "< Left offset of the viewport."]
    pub x: f32,
    #[doc = "< Top offset of the viewport."]
    pub y: f32,
    #[doc = "< Width of the viewport."]
    pub width: f32,
    #[doc = "< Height of the viewport."]
    pub height: f32,
    #[doc = "< Minimum Z value of the viewport."]
    pub minZ: f32,
    #[doc = "< Maximum Z value of the viewport."]
    pub maxZ: f32,
}
#[test]
fn bindgen_test_layout_RpsViewport() {
    const UNINIT: ::std::mem::MaybeUninit<RpsViewport> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<RpsViewport>(),
        24usize,
        concat!("Size of: ", stringify!(RpsViewport))
    );
    assert_eq!(
        ::std::mem::align_of::<RpsViewport>(),
        4usize,
        concat!("Alignment of ", stringify!(RpsViewport))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).x) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RpsViewport),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).y) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(RpsViewport),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).width) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(RpsViewport),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).height) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(RpsViewport),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).minZ) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(RpsViewport),
            "::",
            stringify!(minZ)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).maxZ) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(RpsViewport),
            "::",
            stringify!(maxZ)
        )
    );
}
#[doc = " Rectangular geometrical figure."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RpsRect {
    #[doc = "< X coordinate of the left edge of the rectangle."]
    pub x: i32,
    #[doc = "< Y coordinate of the top edge of the rectangle."]
    pub y: i32,
    #[doc = "< Width of the rectangle."]
    pub width: i32,
    #[doc = "< Height of the rectangle."]
    pub height: i32,
}
#[test]
fn bindgen_test_layout_RpsRect() {
    const UNINIT: ::std::mem::MaybeUninit<RpsRect> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<RpsRect>(),
        16usize,
        concat!("Size of: ", stringify!(RpsRect))
    );
    assert_eq!(
        ::std::mem::align_of::<RpsRect>(),
        4usize,
        concat!("Alignment of ", stringify!(RpsRect))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).x) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RpsRect),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).y) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(RpsRect),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).width) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(RpsRect),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).height) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(RpsRect),
            "::",
            stringify!(height)
        )
    );
}
#[doc = "< Undefined topology."]
pub const RpsPrimitiveTopology_RPS_PRIMITIVE_TOPOLOGY_UNDEFINED: RpsPrimitiveTopology = 0;
#[doc = "< Point list topology."]
pub const RpsPrimitiveTopology_RPS_PRIMITIVE_TOPOLOGY_POINTLIST: RpsPrimitiveTopology = 1;
#[doc = "< Line list topology."]
pub const RpsPrimitiveTopology_RPS_PRIMITIVE_TOPOLOGY_LINELIST: RpsPrimitiveTopology = 2;
#[doc = "< Line strip topology."]
pub const RpsPrimitiveTopology_RPS_PRIMITIVE_TOPOLOGY_LINESTRIP: RpsPrimitiveTopology = 3;
#[doc = "< Triangle list topology."]
pub const RpsPrimitiveTopology_RPS_PRIMITIVE_TOPOLOGY_TRIANGLELIST: RpsPrimitiveTopology = 4;
#[doc = "< Triangle strip topology."]
pub const RpsPrimitiveTopology_RPS_PRIMITIVE_TOPOLOGY_TRIANGLESTRIP: RpsPrimitiveTopology = 5;
#[doc = "< Line list with adjacency topology."]
pub const RpsPrimitiveTopology_RPS_PRIMITIVE_TOPOLOGY_LINELIST_ADJ: RpsPrimitiveTopology = 10;
#[doc = "< Line strip with adjacency topology."]
pub const RpsPrimitiveTopology_RPS_PRIMITIVE_TOPOLOGY_LINESTRIP_ADJ: RpsPrimitiveTopology = 11;
#[doc = "< Triangle list with adjacency topology."]
pub const RpsPrimitiveTopology_RPS_PRIMITIVE_TOPOLOGY_TRIANGLELIST_ADJ: RpsPrimitiveTopology = 12;
#[doc = "< Triangle strip with adjacency topology."]
pub const RpsPrimitiveTopology_RPS_PRIMITIVE_TOPOLOGY_TRIANGLESTRIP_ADJ: RpsPrimitiveTopology = 13;
#[doc = "< Patch list. The number of control points in the patch list"]
pub const RpsPrimitiveTopology_RPS_PRIMITIVE_TOPOLOGY_PATCHLIST: RpsPrimitiveTopology = 14;
#[doc = "< Forces the enumeration to be int32 type. Do not use!!!"]
pub const RpsPrimitiveTopology_RPS_PRIMITIVE_TOPOLOGY_FORCE_INT32: RpsPrimitiveTopology =
    2147483647;
#[doc = " @brief Primitive topology types.\n\n This maps to common API primitive topology enumerations\n such as `D3D_PRIMITIVE_TOPOLOGY` and `VkPrimitiveTopology`."]
pub type RpsPrimitiveTopology = ::std::os::raw::c_uint;
#[doc = "< Resolve operation outputs the average value of all MSAA samples."]
pub const RpsResolveMode_RPS_RESOLVE_MODE_AVERAGE: RpsResolveMode = 0;
#[doc = "< Resolve operation outputs the minimum value of all MSAA samples."]
pub const RpsResolveMode_RPS_RESOLVE_MODE_MIN: RpsResolveMode = 1;
#[doc = "< Resolve operation outputs the maximum value of all MSAA samples."]
pub const RpsResolveMode_RPS_RESOLVE_MODE_MAX: RpsResolveMode = 2;
#[doc = "< Encoding sampler feedback map (DX12 only)."]
pub const RpsResolveMode_RPS_RESOLVE_MODE_ENCODE_SAMPLER_FEEDBACK: RpsResolveMode = 3;
#[doc = "< Decoding sampler feedback map (DX12 only)."]
pub const RpsResolveMode_RPS_RESOLVE_MODE_DECODE_SAMPLER_FEEDBACK: RpsResolveMode = 4;
pub const RpsResolveMode_RPS_RESOLVE_MODE_FORCE_INT32: RpsResolveMode = 2147483647;
#[doc = " @brief Resolve mode types for built-in resolve node.\n\n Support of the modes is subject to the API backend used."]
pub type RpsResolveMode = ::std::os::raw::c_uint;
#[doc = " @brief Screen regions to render to.\n\n @ingroup RpsRenderGraphCommandRecording"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RpsCmdViewportInfo {
    #[doc = "< Default render area of the node. Usually deduced from the bound render"]
    pub defaultRenderArea: RpsRect,
    #[doc = "< Number of viewports used by the node."]
    pub numViewports: u32,
    #[doc = "< Number of scissor rectangles used by the node."]
    pub numScissorRects: u32,
    #[doc = "< Pointer to an array of <c><i>const RpsViewport*</i></c> with numViewports"]
    pub pViewports: *const RpsViewport,
    #[doc = "< Pointer to an array of <c><i>const RpsRect*</i></c> with numScissorRects"]
    pub pScissorRects: *const RpsRect,
}
#[test]
fn bindgen_test_layout_RpsCmdViewportInfo() {
    const UNINIT: ::std::mem::MaybeUninit<RpsCmdViewportInfo> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<RpsCmdViewportInfo>(),
        40usize,
        concat!("Size of: ", stringify!(RpsCmdViewportInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<RpsCmdViewportInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(RpsCmdViewportInfo))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).defaultRenderArea) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RpsCmdViewportInfo),
            "::",
            stringify!(defaultRenderArea)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).numViewports) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(RpsCmdViewportInfo),
            "::",
            stringify!(numViewports)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).numScissorRects) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(RpsCmdViewportInfo),
            "::",
            stringify!(numScissorRects)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pViewports) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(RpsCmdViewportInfo),
            "::",
            stringify!(pViewports)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pScissorRects) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(RpsCmdViewportInfo),
            "::",
            stringify!(pScissorRects)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RpsRuntimeDevice_T {
    _unused: [u8; 0],
}
pub type RpsRuntimeDevice = *mut RpsRuntimeDevice_T;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RpsRenderGraph_T {
    _unused: [u8; 0],
}
pub type RpsRenderGraph = *mut RpsRenderGraph_T;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RpsRenderGraphBuilder_T {
    _unused: [u8; 0],
}
pub type RpsRenderGraphBuilder = *mut RpsRenderGraphBuilder_T;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RpsRenderGraphPhase_T {
    _unused: [u8; 0],
}
pub type RpsRenderGraphPhase = *mut RpsRenderGraphPhase_T;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RpsSubprogram_T {
    _unused: [u8; 0],
}
pub type RpsSubprogram = *mut RpsSubprogram_T;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RpsRuntimeHeap_T {
    pub ptr: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_RpsRuntimeHeap_T() {
    const UNINIT: ::std::mem::MaybeUninit<RpsRuntimeHeap_T> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<RpsRuntimeHeap_T>(),
        8usize,
        concat!("Size of: ", stringify!(RpsRuntimeHeap_T))
    );
    assert_eq!(
        ::std::mem::align_of::<RpsRuntimeHeap_T>(),
        8usize,
        concat!("Alignment of ", stringify!(RpsRuntimeHeap_T))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ptr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RpsRuntimeHeap_T),
            "::",
            stringify!(ptr)
        )
    );
}
pub type RpsRuntimeHeap = RpsRuntimeHeap_T;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RpsRuntimeResource_T {
    pub ptr: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_RpsRuntimeResource_T() {
    const UNINIT: ::std::mem::MaybeUninit<RpsRuntimeResource_T> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<RpsRuntimeResource_T>(),
        8usize,
        concat!("Size of: ", stringify!(RpsRuntimeResource_T))
    );
    assert_eq!(
        ::std::mem::align_of::<RpsRuntimeResource_T>(),
        8usize,
        concat!("Alignment of ", stringify!(RpsRuntimeResource_T))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ptr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RpsRuntimeResource_T),
            "::",
            stringify!(ptr)
        )
    );
}
pub type RpsRuntimeResource = RpsRuntimeResource_T;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RpsRuntimeCommandBuffer_T {
    pub ptr: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_RpsRuntimeCommandBuffer_T() {
    const UNINIT: ::std::mem::MaybeUninit<RpsRuntimeCommandBuffer_T> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<RpsRuntimeCommandBuffer_T>(),
        8usize,
        concat!("Size of: ", stringify!(RpsRuntimeCommandBuffer_T))
    );
    assert_eq!(
        ::std::mem::align_of::<RpsRuntimeCommandBuffer_T>(),
        8usize,
        concat!("Alignment of ", stringify!(RpsRuntimeCommandBuffer_T))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ptr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RpsRuntimeCommandBuffer_T),
            "::",
            stringify!(ptr)
        )
    );
}
pub type RpsRuntimeCommandBuffer = RpsRuntimeCommandBuffer_T;
#[doc = " @brief Function parameter attribute."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RpsParamAttr {
    #[doc = "< Access attribute of the parameter."]
    pub access: RpsAccessAttr,
    #[doc = "< Semantic attribute of the parameter."]
    pub semantic: RpsSemanticAttr,
}
#[test]
fn bindgen_test_layout_RpsParamAttr() {
    const UNINIT: ::std::mem::MaybeUninit<RpsParamAttr> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<RpsParamAttr>(),
        16usize,
        concat!("Size of: ", stringify!(RpsParamAttr))
    );
    assert_eq!(
        ::std::mem::align_of::<RpsParamAttr>(),
        4usize,
        concat!("Alignment of ", stringify!(RpsParamAttr))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).access) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RpsParamAttr),
            "::",
            stringify!(access)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).semantic) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(RpsParamAttr),
            "::",
            stringify!(semantic)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RpsParamAttrList_T {
    _unused: [u8; 0],
}
pub type RpsParamAttrList = *mut RpsParamAttrList_T;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RpsNodeAttrList_T {
    _unused: [u8; 0],
}
pub type RpsNodeAttrList = *mut RpsNodeAttrList_T;
#[doc = " No schedule flag bits are specified. Default options are used. When used as\n RpsRenderGraphUpdateInfo::scheduleFlags, the RpsRenderGraphCreateInfo::scheduleInfo::scheduleFlags specified\n at render graph creation time are used instead."]
pub const RpsScheduleFlagBits_RPS_SCHEDULE_UNSPECIFIED: RpsScheduleFlagBits = 0;
#[doc = " Command nodes are kept in the program order."]
pub const RpsScheduleFlagBits_RPS_SCHEDULE_KEEP_PROGRAM_ORDER_BIT: RpsScheduleFlagBits = 1;
#[doc = " Schedules in favor of reducing total GPU memory usage. Possible strategies include minimizing transient resource\n lifetimes and aggressive aliasing. This may increase the number of barriers generated."]
pub const RpsScheduleFlagBits_RPS_SCHEDULE_PREFER_MEMORY_SAVING_BIT: RpsScheduleFlagBits = 2;
#[doc = " Schedules commands randomly (without changing program logic). Mostly useful for testing purposes. Applications\n should normally avoid using this flag for end-user scenarios. If RPS_SCHEDULE_KEEP_PROGRAM_ORDER_BIT is set,\n this flag will have no effect."]
pub const RpsScheduleFlagBits_RPS_SCHEDULE_RANDOM_ORDER_BIT: RpsScheduleFlagBits = 4;
#[doc = " Avoids alternating between graphics and compute work on the same queue. This can help for some architectures\n where switching between graphics and compute produces extra overhead."]
pub const RpsScheduleFlagBits_RPS_SCHEDULE_MINIMIZE_COMPUTE_GFX_SWITCH_BIT: RpsScheduleFlagBits = 8;
#[doc = " Disables dead code elimination optimization. By default, RPS removes nodes that have no visible effect (Not\n contributing to modification of external, temporal, persistent or CPU resources). This flag disables this\n optimization."]
pub const RpsScheduleFlagBits_RPS_SCHEDULE_DISABLE_DEAD_CODE_ELIMINATION_BIT: RpsScheduleFlagBits =
    16;
#[doc = " Disables work pipelining based on the workload type."]
pub const RpsScheduleFlagBits_RPS_SCHEDULE_WORKLOAD_TYPE_PIPELINING_DISABLE_BIT:
    RpsScheduleFlagBits = 32;
#[doc = " Performs aggressive work pipelining based on the workload type. If\n RPS_SCHEDULE_WORKLOAD_TYPE_PIPELINING_DISABLE_BIT is set, this flag will have not effect."]
pub const RpsScheduleFlagBits_RPS_SCHEDULE_WORKLOAD_TYPE_PIPELINING_AGGRESSIVE_BIT:
    RpsScheduleFlagBits = 64;
#[doc = " Reserved for future use. Includes split barriers where appropriate."]
pub const RpsScheduleFlagBits_RPS_SCHEDULE_ALLOW_SPLIT_BARRIERS_BIT: RpsScheduleFlagBits = 65536;
#[doc = " Reserved for future use. Avoids rescheduling if possible and uses the existing schedule instead."]
pub const RpsScheduleFlagBits_RPS_SCHEDULE_AVOID_RESCHEDULE_BIT: RpsScheduleFlagBits = 131072;
#[doc = " Reserved for future use. Allows work to overlap between multiple frames."]
pub const RpsScheduleFlagBits_RPS_SCHEDULE_ALLOW_FRAME_OVERLAP_BIT: RpsScheduleFlagBits = 2097152;
#[doc = " Reserved for future use. Tries to use render pass transitions instead of standalone transition nodes when\n possible. If RPS_SCHEDULE_DISABLE_RENDERPASS_TRANSITIONS_BIT is set, this flag will have no effect."]
pub const RpsScheduleFlagBits_RPS_SCHEDULE_PREFER_RENDERPASS_TRANSITIONS_BIT: RpsScheduleFlagBits =
    4194304;
#[doc = " Reserved for future use. Uses standalone transition nodes instead of render pass transitions."]
pub const RpsScheduleFlagBits_RPS_SCHEDULE_DISABLE_RENDERPASS_TRANSITIONS_BIT: RpsScheduleFlagBits =
    8388608;
#[doc = " Uses default options. This is identical to RPS_SCHEDULE_UNSPECIFIED in most cases, except when used as\n RpsRenderGraphUpdateInfo::scheduleFlags, instead using the default options regardless of\n RpsRenderGraphCreateInfo::scheduleInfo::scheduleFlags. This default behavior is a baseline set of criteria used\n for scheduling to which these flags can add additional ones."]
pub const RpsScheduleFlagBits_RPS_SCHEDULE_DEFAULT: RpsScheduleFlagBits = 1073741824;
#[doc = " Prioritizes application performance over a lower memory footprint."]
pub const RpsScheduleFlagBits_RPS_SCHEDULE_DEFAULT_PERFORMANCE: RpsScheduleFlagBits = 1073741824;
#[doc = " Prioritizes a lower memory footprint over performance."]
pub const RpsScheduleFlagBits_RPS_SCHEDULE_DEFAULT_MEMORY: RpsScheduleFlagBits = 2;
#[doc = " @brief Bitflags for scheduling behavior."]
pub type RpsScheduleFlagBits = ::std::os::raw::c_uint;
#[doc = " @brief Bitmask type for <c><i>RpsScheduleFlagBits</i></c>."]
pub type RpsScheduleFlags = RpsFlags32;
#[doc = "< No diagnostic mode enabled."]
pub const RpsDiagnosticFlagBits_RPS_DIAGNOSTIC_NONE: RpsDiagnosticFlagBits = 0;
#[doc = "< Dumps the resources and commands of a render graph"]
pub const RpsDiagnosticFlagBits_RPS_DIAGNOSTIC_ENABLE_PRE_SCHEDULE_DUMP: RpsDiagnosticFlagBits = 1;
#[doc = "< Dumps the commands of the render graph after"]
pub const RpsDiagnosticFlagBits_RPS_DIAGNOSTIC_ENABLE_POST_SCHEDULE_DUMP: RpsDiagnosticFlagBits = 2;
#[doc = "< Dumps the directed acyclic graph of nodes defined"]
pub const RpsDiagnosticFlagBits_RPS_DIAGNOSTIC_ENABLE_DAG_DUMP: RpsDiagnosticFlagBits = 4;
#[doc = "< Inserts source code location debug data for"]
pub const RpsDiagnosticFlagBits_RPS_DIAGNOSTIC_ENABLE_SOURCE_LOCATION: RpsDiagnosticFlagBits = 8;
#[doc = "< Sets resource names as debug names in the graphics"]
pub const RpsDiagnosticFlagBits_RPS_DIAGNOSTIC_ENABLE_RUNTIME_DEBUG_NAMES: RpsDiagnosticFlagBits =
    16;
#[doc = "< Enable all flags."]
pub const RpsDiagnosticFlagBits_RPS_DIAGNOSTIC_ENABLE_ALL: RpsDiagnosticFlagBits = 31;
#[doc = " @brief Bitflags for enabling diagnostic systems."]
pub type RpsDiagnosticFlagBits = ::std::os::raw::c_uint;
#[doc = " @brief Bitmask type for <c><i>RpsDiagnosticFlagBits</i></c>."]
pub type RpsDiagnosticFlags = RpsFlags32;
#[doc = "< No special properties."]
pub const RpsRenderGraphFlagBits_RPS_RENDER_GRAPH_FLAG_NONE: RpsRenderGraphFlagBits = 0;
#[doc = "< Disallows unbound nodes if no default callback is set."]
pub const RpsRenderGraphFlagBits_RPS_RENDER_GRAPH_DISALLOW_UNBOUND_NODES_BIT:
    RpsRenderGraphFlagBits = 1;
#[doc = "< Disables GPU memory aliasing."]
pub const RpsRenderGraphFlagBits_RPS_RENDER_GRAPH_NO_GPU_MEMORY_ALIASING: RpsRenderGraphFlagBits =
    2;
#[doc = "< Disables lifetime analysis unless required by other"]
pub const RpsRenderGraphFlagBits_RPS_RENDER_GRAPH_NO_LIFETIME_ANALYSIS: RpsRenderGraphFlagBits = 4;
#[doc = " @brief Bitflags for special render graph properties."]
pub type RpsRenderGraphFlagBits = ::std::os::raw::c_uint;
#[doc = " @brief Bitmask type for <c><i>RpsRenderGraphFlagBits</i></c>."]
pub type RpsRenderGraphFlags = RpsFlags32;
#[doc = "< No node declaration properties."]
pub const RpsNodeDeclFlagBits_RPS_NODE_DECL_FLAG_NONE: RpsNodeDeclFlagBits = 0;
#[doc = "< Node requires a queue with graphics capabilites."]
pub const RpsNodeDeclFlagBits_RPS_NODE_DECL_GRAPHICS_BIT: RpsNodeDeclFlagBits = 1;
#[doc = "< Node requires a queue with compute capabilities."]
pub const RpsNodeDeclFlagBits_RPS_NODE_DECL_COMPUTE_BIT: RpsNodeDeclFlagBits = 2;
#[doc = "< Node requires a queue with copy capabilities."]
pub const RpsNodeDeclFlagBits_RPS_NODE_DECL_COPY_BIT: RpsNodeDeclFlagBits = 4;
#[doc = "< Node prefers to be executed as a render pass if the API backend"]
pub const RpsNodeDeclFlagBits_RPS_NODE_DECL_PREFER_RENDER_PASS: RpsNodeDeclFlagBits = 8;
#[doc = "< Node prefers to be executed asynchronously."]
pub const RpsNodeDeclFlagBits_RPS_NODE_DECL_PREFER_ASYNC: RpsNodeDeclFlagBits = 16;
#[doc = " @brief Bitflags for properties of a render graph node declaration.\n\n These are e.g. required queue type, async preferences, etc. All usages of a node will use the same set of\n properties the node was declared with."]
pub type RpsNodeDeclFlagBits = ::std::os::raw::c_uint;
#[doc = " @brief Bitmask type for <c><i>RpsNodeDeclFlagBits</i></c>."]
pub type RpsNodeDeclFlags = RpsFlags32;
#[doc = "< No bit flags."]
pub const RpsParameterFlagBits_RPS_PARAMETER_FLAG_NONE: RpsParameterFlagBits = 0;
#[doc = "< Node parameter is an output parameter."]
pub const RpsParameterFlagBits_RPS_PARAMETER_FLAG_OUT_BIT: RpsParameterFlagBits = 1;
#[doc = "< Node parameter is optional."]
pub const RpsParameterFlagBits_RPS_PARAMETER_FLAG_OPTIONAL_BIT: RpsParameterFlagBits = 2;
#[doc = "< Node parameter is an RPS resource."]
pub const RpsParameterFlagBits_RPS_PARAMETER_FLAG_RESOURCE_BIT: RpsParameterFlagBits = 4;
#[doc = " @brief Bitflags for decorating node parameters."]
pub type RpsParameterFlagBits = ::std::os::raw::c_uint;
#[doc = " @brief Bitmask type for <c><i>RpsParameterFlagBits</i></c>."]
pub type RpsParameterFlags = u32;
#[doc = " No callback properties."]
pub const RpsCmdCallbackFlagBits_RPS_CMD_CALLBACK_FLAG_NONE: RpsCmdCallbackFlagBits = 0;
#[doc = " Skips default render target / depth stencil buffer setup, even if any were specified in the node parameter\n semantics."]
pub const RpsCmdCallbackFlagBits_RPS_CMD_CALLBACK_CUSTOM_RENDER_TARGETS_BIT:
    RpsCmdCallbackFlagBits = 1;
#[doc = " Skips viewport and scissor rect setup. Used when the command callback will do the setup instead."]
pub const RpsCmdCallbackFlagBits_RPS_CMD_CALLBACK_CUSTOM_VIEWPORT_SCISSOR_BIT:
    RpsCmdCallbackFlagBits = 2;
#[doc = " Skips render state & resource binding setup other than render targets (including depth stencil buffer) and\n viewport (including scissor rects)."]
pub const RpsCmdCallbackFlagBits_RPS_CMD_CALLBACK_CUSTOM_STATE_SETUP_BIT: RpsCmdCallbackFlagBits =
    4;
#[doc = " Skips all setup."]
pub const RpsCmdCallbackFlagBits_RPS_CMD_CALLBACK_CUSTOM_ALL: RpsCmdCallbackFlagBits = 7;
#[doc = " @brief Bitflags for command callback properties.\n\n These flags control the graphics state setup and teardown behavior that occurs before entering and after\n exiting the callback."]
pub type RpsCmdCallbackFlagBits = ::std::os::raw::c_uint;
#[doc = " @brief Bitmask type for <c><i>RpsCmdCallbackFlagBits</i></c>."]
pub type RpsCmdCallbackFlags = RpsFlags32;
#[doc = " @brief Signature of render graph node callbacks.\n\n @param pContext                     Context for the command callback."]
pub type PFN_rpsCmdCallback =
    ::std::option::Option<unsafe extern "C" fn(pContext: *const RpsCmdCallbackContext)>;
#[doc = " @brief Command callback with usage parameters."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RpsCmdCallback {
    #[doc = "< Pointer to a callback function."]
    pub pfnCallback: PFN_rpsCmdCallback,
    #[doc = "< User context to be passed to the callback."]
    pub pUserContext: *mut ::std::os::raw::c_void,
    #[doc = "< Flags for the callback."]
    pub flags: RpsCmdCallbackFlags,
}
#[test]
fn bindgen_test_layout_RpsCmdCallback() {
    const UNINIT: ::std::mem::MaybeUninit<RpsCmdCallback> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<RpsCmdCallback>(),
        24usize,
        concat!("Size of: ", stringify!(RpsCmdCallback))
    );
    assert_eq!(
        ::std::mem::align_of::<RpsCmdCallback>(),
        8usize,
        concat!("Alignment of ", stringify!(RpsCmdCallback))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pfnCallback) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RpsCmdCallback),
            "::",
            stringify!(pfnCallback)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pUserContext) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(RpsCmdCallback),
            "::",
            stringify!(pUserContext)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(RpsCmdCallback),
            "::",
            stringify!(flags)
        )
    );
}
#[doc = " @brief Parameters for describing a node call parameter."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RpsParameterDesc {
    #[doc = "< Type info of the parameter."]
    pub typeInfo: RpsTypeInfo,
    #[doc = "< Number of array elements for this parameter. 0 indicates not an array (single"]
    pub arraySize: u32,
    #[doc = "< Pointer to a runtime defined structure with attributes of the parameter."]
    pub attr: RpsConstant,
    #[doc = "< Null terminated string with the name of the parameter."]
    pub name: *const ::std::os::raw::c_char,
    #[doc = "< Parameter type flags."]
    pub flags: RpsParameterFlags,
}
#[test]
fn bindgen_test_layout_RpsParameterDesc() {
    const UNINIT: ::std::mem::MaybeUninit<RpsParameterDesc> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<RpsParameterDesc>(),
        32usize,
        concat!("Size of: ", stringify!(RpsParameterDesc))
    );
    assert_eq!(
        ::std::mem::align_of::<RpsParameterDesc>(),
        8usize,
        concat!("Alignment of ", stringify!(RpsParameterDesc))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).typeInfo) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RpsParameterDesc),
            "::",
            stringify!(typeInfo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).arraySize) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(RpsParameterDesc),
            "::",
            stringify!(arraySize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).attr) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(RpsParameterDesc),
            "::",
            stringify!(attr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(RpsParameterDesc),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(RpsParameterDesc),
            "::",
            stringify!(flags)
        )
    );
}
#[doc = " @brief Parameters for describing a render graph node."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RpsNodeDesc {
    #[doc = "< Flags for the type of render graph node."]
    pub flags: RpsNodeDeclFlags,
    #[doc = "< Number of parameters used in the callback."]
    pub numParams: u32,
    #[doc = "< Pointer to an array of <c><i>const RpsParameterDesc</i></c> with"]
    pub pParamDescs: *const RpsParameterDesc,
    #[doc = "< Null terminated string with the name of the callback."]
    pub name: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_RpsNodeDesc() {
    const UNINIT: ::std::mem::MaybeUninit<RpsNodeDesc> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<RpsNodeDesc>(),
        24usize,
        concat!("Size of: ", stringify!(RpsNodeDesc))
    );
    assert_eq!(
        ::std::mem::align_of::<RpsNodeDesc>(),
        8usize,
        concat!("Alignment of ", stringify!(RpsNodeDesc))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RpsNodeDesc),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).numParams) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(RpsNodeDesc),
            "::",
            stringify!(numParams)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pParamDescs) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(RpsNodeDesc),
            "::",
            stringify!(pParamDescs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(RpsNodeDesc),
            "::",
            stringify!(name)
        )
    );
}
#[doc = " @brief Parameters for describing a render graph signature."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RpsRenderGraphSignatureDesc {
    #[doc = "< Number of parameters in the signature."]
    pub numParams: u32,
    #[doc = "< Number of node descriptions in the signature."]
    pub numNodeDescs: u32,
    #[doc = "< Number of resources in the parameters of the signature. Array parameters"]
    pub maxExternalResources: u32,
    #[doc = "< Pointer to an array of <c><i>const RpsParameterDesc</i></c> with"]
    pub pParamDescs: *const RpsParameterDesc,
    #[doc = "< Pointer to an array of <c><i>const RpsNodeDesc</i></c> with numNodeDescs"]
    pub pNodeDescs: *const RpsNodeDesc,
    #[doc = "< Null terminated string with the name of the render graph."]
    pub name: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_RpsRenderGraphSignatureDesc() {
    const UNINIT: ::std::mem::MaybeUninit<RpsRenderGraphSignatureDesc> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<RpsRenderGraphSignatureDesc>(),
        40usize,
        concat!("Size of: ", stringify!(RpsRenderGraphSignatureDesc))
    );
    assert_eq!(
        ::std::mem::align_of::<RpsRenderGraphSignatureDesc>(),
        8usize,
        concat!("Alignment of ", stringify!(RpsRenderGraphSignatureDesc))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).numParams) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RpsRenderGraphSignatureDesc),
            "::",
            stringify!(numParams)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).numNodeDescs) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(RpsRenderGraphSignatureDesc),
            "::",
            stringify!(numNodeDescs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).maxExternalResources) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(RpsRenderGraphSignatureDesc),
            "::",
            stringify!(maxExternalResources)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pParamDescs) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(RpsRenderGraphSignatureDesc),
            "::",
            stringify!(pParamDescs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pNodeDescs) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(RpsRenderGraphSignatureDesc),
            "::",
            stringify!(pNodeDescs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(RpsRenderGraphSignatureDesc),
            "::",
            stringify!(name)
        )
    );
}
extern "C" {
    #[doc = " @brief Reports an error from a command callback context.\n\n @param pContext                         Pointer to the context. Must be the primary context (passed to the command\n                                         callback as argument). This function fails if the context is a secondary\n                                         context (created via rpsCmdCloneContext). Must not be NULL.\n\n @param errorCode                        Error code for the type of error to report. For errorCode == RPS_OK, this\n                                         function does nothing.\n\n @returns                                Result code of the operation. See <c><i>RpsResult</i></c> for more info."]
    pub fn rpsCmdCallbackReportError(
        pContext: *const RpsCmdCallbackContext,
        errorCode: RpsResult,
    ) -> RpsResult;
}
#[doc = "< No node instance properties."]
pub const RpsNodeFlagBits_RPS_NODE_FLAG_NONE: RpsNodeFlagBits = 0;
#[doc = "< Node prefers to be executed asynchronously."]
pub const RpsNodeFlagBits_RPS_NODE_PREFER_ASYNC: RpsNodeFlagBits = 2;
#[doc = " @brief Bitflags for node instance properties."]
pub type RpsNodeFlagBits = ::std::os::raw::c_uint;
#[doc = " @brief Bitmask type for  <c><i>RpsNodeFlagBits</i></c> of properties for a render graph node instance.\n\n While RpsNodeDeclFlags apply to all instances which share the same node declaration, RpsNodeFlags apply to one\n specific node instance."]
pub type RpsNodeFlags = RpsFlags32;
#[doc = " @brief Signature of functions for render graph building.\n\n @param hBuilder                             Handle to the render graph builder to use.\n @param pArgs                                Pointer to an array of <c><i>RpsConstant</i></c> with numArgs constant\n                                             arguments to use for building. Must not be NULL if numArgs != 0.\n @param numArgs                              Number of constant arguments to use for building.\n\n @returns                                    Result code of the operation. See <c><i>RpsResult</i></c> for more info."]
pub type PFN_rpsRenderGraphBuild = ::std::option::Option<
    unsafe extern "C" fn(
        hBuilder: RpsRenderGraphBuilder,
        pArgs: *const RpsConstant,
        numArgs: u32,
    ) -> RpsResult,
>;
#[doc = " @brief Parameters for updating a render graph.\n\n @relates RpsRenderGraph"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RpsRenderGraphUpdateInfo {
    #[doc = " Index of the current frame to be recorded after the update."]
    pub frameIndex: u64,
    #[doc = " Index of the last frame that finished executing on the GPU. Used for resource lifetime management."]
    pub gpuCompletedFrameIndex: u64,
    #[doc = " Flags for scheduling behavior. Used for overriding flags specified at creation."]
    pub scheduleFlags: RpsScheduleFlags,
    #[doc = " Flags for enabling diagnostics systems during the render graph update."]
    pub diagnosticFlags: RpsDiagnosticFlags,
    #[doc = " Number of arguments to pass to the entry. Passing less than the number of values from the render graph entry\n updates only the first numArgs arguments and does not touch any other argument."]
    pub numArgs: u32,
    #[doc = " Pointer to an array of <c><i>RpsConstant</i></c> with numArgs constant arguments to pass to the entry.\n Must not be NULL if numArgs != 0."]
    pub ppArgs: *const RpsConstant,
    #[doc = " Pointer to an array of <c><i>const RpsRuntimeResource* const</i></c> with pointers to externally managed\n resources used in the render graph. Resource arguments in ppArgs have a corresponding runtime resource (or\n array) in ppArgResources, at the same index. If e.g. {&backBufferResourceDescription, value} is passed for\n ppArgs, ppArgResources[0] would have to point to the corresponding <c><i>RpsRuntimeResource</i></c> of the\n backbuffer."]
    pub ppArgResources: *const *const RpsRuntimeResource,
    #[doc = " Pointer to a function for starting the render graph building process."]
    pub pfnBuildCallback: PFN_rpsRenderGraphBuild,
    #[doc = " Pointer to a random number generator. Only required if any randomized behavior is used, e.g.\n RPS_SCHEDULE_RANDOM_ORDER_BIT."]
    pub pRandomNumberGenerator: *const RpsRandomNumberGenerator,
}
#[test]
fn bindgen_test_layout_RpsRenderGraphUpdateInfo() {
    const UNINIT: ::std::mem::MaybeUninit<RpsRenderGraphUpdateInfo> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<RpsRenderGraphUpdateInfo>(),
        64usize,
        concat!("Size of: ", stringify!(RpsRenderGraphUpdateInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<RpsRenderGraphUpdateInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(RpsRenderGraphUpdateInfo))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).frameIndex) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RpsRenderGraphUpdateInfo),
            "::",
            stringify!(frameIndex)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gpuCompletedFrameIndex) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(RpsRenderGraphUpdateInfo),
            "::",
            stringify!(gpuCompletedFrameIndex)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).scheduleFlags) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(RpsRenderGraphUpdateInfo),
            "::",
            stringify!(scheduleFlags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).diagnosticFlags) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(RpsRenderGraphUpdateInfo),
            "::",
            stringify!(diagnosticFlags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).numArgs) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(RpsRenderGraphUpdateInfo),
            "::",
            stringify!(numArgs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ppArgs) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(RpsRenderGraphUpdateInfo),
            "::",
            stringify!(ppArgs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ppArgResources) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(RpsRenderGraphUpdateInfo),
            "::",
            stringify!(ppArgResources)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pfnBuildCallback) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(RpsRenderGraphUpdateInfo),
            "::",
            stringify!(pfnBuildCallback)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pRandomNumberGenerator) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(RpsRenderGraphUpdateInfo),
            "::",
            stringify!(pRandomNumberGenerator)
        )
    );
}
#[doc = " @brief Signature of functions for executing a render graph phase.\n\n @param hRenderGraph             Handle to the render graph to execute the phase for.\n @param pUpdateInfo              Pointer to update parameters.\n @param phase                    Handle to the render graph phase object.\n\n @returns                        Result code of the operation. See <c><i>RpsResult</i></c> for more info."]
pub type PFN_rpsRenderGraphPhaseRun = ::std::option::Option<
    unsafe extern "C" fn(
        hRenderGraph: RpsRenderGraph,
        pUpdateInfo: *const RpsRenderGraphUpdateInfo,
        phase: RpsRenderGraphPhase,
    ) -> RpsResult,
>;
#[doc = " @brief Signature of functions for destroying a render graph phase object.\n\n @param phase                    Handle to the render graph phase object.\n\n @returns                        Result code of the operation. See <c><i>RpsResult</i></c> for more info."]
pub type PFN_rpsRenderGraphPhaseDestroy =
    ::std::option::Option<unsafe extern "C" fn(phase: RpsRenderGraphPhase) -> RpsResult>;
#[doc = " @brief Parameters of a render graph processing phase."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RpsRenderGraphPhaseInfo {
    #[doc = "< Handle to the render graph phase object."]
    pub hPhase: RpsRenderGraphPhase,
    #[doc = "< Pointer to a function for executing the render graph phase."]
    pub pfnRun: PFN_rpsRenderGraphPhaseRun,
    #[doc = "< Pointer to a function for destroying the render graph phase."]
    pub pfnDestroy: PFN_rpsRenderGraphPhaseDestroy,
}
#[test]
fn bindgen_test_layout_RpsRenderGraphPhaseInfo() {
    const UNINIT: ::std::mem::MaybeUninit<RpsRenderGraphPhaseInfo> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<RpsRenderGraphPhaseInfo>(),
        24usize,
        concat!("Size of: ", stringify!(RpsRenderGraphPhaseInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<RpsRenderGraphPhaseInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(RpsRenderGraphPhaseInfo))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hPhase) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RpsRenderGraphPhaseInfo),
            "::",
            stringify!(hPhase)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pfnRun) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(RpsRenderGraphPhaseInfo),
            "::",
            stringify!(pfnRun)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pfnDestroy) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(RpsRenderGraphPhaseInfo),
            "::",
            stringify!(pfnDestroy)
        )
    );
}
#[doc = " @brief Parameters of a memory type."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RpsMemoryTypeInfo {
    #[doc = "< Default size for creating a heap of this type."]
    pub defaultHeapSize: u64,
    #[doc = "< Minimum alignment for heaps of this memory type in bytes."]
    pub minAlignment: u32,
}
#[test]
fn bindgen_test_layout_RpsMemoryTypeInfo() {
    const UNINIT: ::std::mem::MaybeUninit<RpsMemoryTypeInfo> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<RpsMemoryTypeInfo>(),
        16usize,
        concat!("Size of: ", stringify!(RpsMemoryTypeInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<RpsMemoryTypeInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(RpsMemoryTypeInfo))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).defaultHeapSize) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RpsMemoryTypeInfo),
            "::",
            stringify!(defaultHeapSize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).minAlignment) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(RpsMemoryTypeInfo),
            "::",
            stringify!(minAlignment)
        )
    );
}
#[doc = " @brief Required parameters for a GPU memory allocation."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RpsGpuMemoryRequirement {
    #[doc = "< Size of the allocation in bytes."]
    pub size: u64,
    #[doc = "< Minimum alignment required by the allocation in bytes."]
    pub alignment: u32,
    #[doc = "< Index for the type of memory the allocation should be created from. API backend"]
    pub memoryTypeIndex: RpsIndex32,
}
#[test]
fn bindgen_test_layout_RpsGpuMemoryRequirement() {
    const UNINIT: ::std::mem::MaybeUninit<RpsGpuMemoryRequirement> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<RpsGpuMemoryRequirement>(),
        16usize,
        concat!("Size of: ", stringify!(RpsGpuMemoryRequirement))
    );
    assert_eq!(
        ::std::mem::align_of::<RpsGpuMemoryRequirement>(),
        8usize,
        concat!("Alignment of ", stringify!(RpsGpuMemoryRequirement))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RpsGpuMemoryRequirement),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).alignment) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(RpsGpuMemoryRequirement),
            "::",
            stringify!(alignment)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).memoryTypeIndex) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(RpsGpuMemoryRequirement),
            "::",
            stringify!(memoryTypeIndex)
        )
    );
}
#[doc = " @brief Type for heap identifiers.\n\n Internally, these are used as simple indices."]
pub type RpsHeapId = RpsIndex32;
#[doc = " @brief Parameters of a resource placement inside a heap."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RpsHeapPlacement {
    #[doc = "< ID of the heap in the render graph."]
    pub heapId: RpsHeapId,
    #[doc = "< Offset of the resource placement inside the heap in bytes."]
    pub offset: u64,
}
#[test]
fn bindgen_test_layout_RpsHeapPlacement() {
    const UNINIT: ::std::mem::MaybeUninit<RpsHeapPlacement> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<RpsHeapPlacement>(),
        16usize,
        concat!("Size of: ", stringify!(RpsHeapPlacement))
    );
    assert_eq!(
        ::std::mem::align_of::<RpsHeapPlacement>(),
        8usize,
        concat!("Alignment of ", stringify!(RpsHeapPlacement))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).heapId) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RpsHeapPlacement),
            "::",
            stringify!(heapId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).offset) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(RpsHeapPlacement),
            "::",
            stringify!(offset)
        )
    );
}
#[doc = " @brief Parameters of a runtime resource."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct RpsRuntimeResourceInfo {
    #[doc = "< Handle to the resource created by the API backend."]
    pub hResource: RpsRuntimeResource,
    #[doc = "< Resource description."]
    pub resourceDesc: RpsResourceDesc,
    #[doc = "< Number of subresources in the entire resource."]
    pub numSubresources: u32,
    #[doc = "< Range spanning all subresources."]
    pub fullRange: RpsSubresourceRange,
    #[doc = "< ID of the heap its memory is placed in."]
    pub heapId: RpsHeapId,
    #[doc = "< Allocation parameters of the resource."]
    pub allocInfo: RpsGpuMemoryRequirement,
}
#[test]
fn bindgen_test_layout_RpsRuntimeResourceInfo() {
    const UNINIT: ::std::mem::MaybeUninit<RpsRuntimeResourceInfo> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<RpsRuntimeResourceInfo>(),
        80usize,
        concat!("Size of: ", stringify!(RpsRuntimeResourceInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<RpsRuntimeResourceInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(RpsRuntimeResourceInfo))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hResource) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RpsRuntimeResourceInfo),
            "::",
            stringify!(hResource)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).resourceDesc) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(RpsRuntimeResourceInfo),
            "::",
            stringify!(resourceDesc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).numSubresources) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(RpsRuntimeResourceInfo),
            "::",
            stringify!(numSubresources)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fullRange) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(RpsRuntimeResourceInfo),
            "::",
            stringify!(fullRange)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).heapId) as usize - ptr as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(RpsRuntimeResourceInfo),
            "::",
            stringify!(heapId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).allocInfo) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(RpsRuntimeResourceInfo),
            "::",
            stringify!(allocInfo)
        )
    );
}
impl ::std::fmt::Debug for RpsRuntimeResourceInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write ! (f , "RpsRuntimeResourceInfo {{ hResource: {:?}, resourceDesc: {:?}, fullRange: {:?}, allocInfo: {:?} }}" , self . hResource , self . resourceDesc , self . fullRange , self . allocInfo)
    }
}
#[doc = "< No capabilities."]
pub const RpsQueueFlagBits_RPS_QUEUE_FLAG_NONE: RpsQueueFlagBits = 0;
#[doc = "< Graphics capabilities."]
pub const RpsQueueFlagBits_RPS_QUEUE_FLAG_GRAPHICS: RpsQueueFlagBits = 1;
#[doc = "< Compute capabilities."]
pub const RpsQueueFlagBits_RPS_QUEUE_FLAG_COMPUTE: RpsQueueFlagBits = 2;
#[doc = "< Copy capabilities."]
pub const RpsQueueFlagBits_RPS_QUEUE_FLAG_COPY: RpsQueueFlagBits = 4;
#[doc = " @brief Bitflags for queue capabilities."]
pub type RpsQueueFlagBits = ::std::os::raw::c_uint;
#[doc = " @brief Bitmask type for <c><i>RpsQueueFlagBits</i></c>."]
pub type RpsQueueFlags = RpsFlags32;
#[doc = " @brief Parameters for creating a custom GPU memory heap."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RpsRuntimeOpCreateHeapArgs {
    #[doc = "< Index of the type of memory the allocation should be created from. API"]
    pub memoryTypeIndex: u32,
    #[doc = "< Size of the heap in bytes."]
    pub size: usize,
    #[doc = "< Alignment of the heap in bytes."]
    pub alignment: usize,
    #[doc = "< Null terminated string with the debug name of the heap. Passing NULL sets no name."]
    pub debugName: *const ::std::os::raw::c_char,
    #[doc = "< Pointer to a handle in which the heap is returned. Must not be NULL."]
    pub phHeap: *mut RpsRuntimeHeap,
}
#[test]
fn bindgen_test_layout_RpsRuntimeOpCreateHeapArgs() {
    const UNINIT: ::std::mem::MaybeUninit<RpsRuntimeOpCreateHeapArgs> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<RpsRuntimeOpCreateHeapArgs>(),
        40usize,
        concat!("Size of: ", stringify!(RpsRuntimeOpCreateHeapArgs))
    );
    assert_eq!(
        ::std::mem::align_of::<RpsRuntimeOpCreateHeapArgs>(),
        8usize,
        concat!("Alignment of ", stringify!(RpsRuntimeOpCreateHeapArgs))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).memoryTypeIndex) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RpsRuntimeOpCreateHeapArgs),
            "::",
            stringify!(memoryTypeIndex)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(RpsRuntimeOpCreateHeapArgs),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).alignment) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(RpsRuntimeOpCreateHeapArgs),
            "::",
            stringify!(alignment)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).debugName) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(RpsRuntimeOpCreateHeapArgs),
            "::",
            stringify!(debugName)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).phHeap) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(RpsRuntimeOpCreateHeapArgs),
            "::",
            stringify!(phHeap)
        )
    );
}
#[doc = " @brief Parameters for destroying an array of runtime GPU memory heaps."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RpsRuntimeOpDestroyHeapArgs {
    #[doc = "< Number of heaps to destroy."]
    pub numHeaps: u32,
    #[doc = "< Pointer to an array of <c><i>RpsRuntimeHeap</i></c> with numHeaps heap handles to"]
    pub phRtHeaps: *mut RpsRuntimeHeap,
}
#[test]
fn bindgen_test_layout_RpsRuntimeOpDestroyHeapArgs() {
    const UNINIT: ::std::mem::MaybeUninit<RpsRuntimeOpDestroyHeapArgs> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<RpsRuntimeOpDestroyHeapArgs>(),
        16usize,
        concat!("Size of: ", stringify!(RpsRuntimeOpDestroyHeapArgs))
    );
    assert_eq!(
        ::std::mem::align_of::<RpsRuntimeOpDestroyHeapArgs>(),
        8usize,
        concat!("Alignment of ", stringify!(RpsRuntimeOpDestroyHeapArgs))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).numHeaps) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RpsRuntimeOpDestroyHeapArgs),
            "::",
            stringify!(numHeaps)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).phRtHeaps) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(RpsRuntimeOpDestroyHeapArgs),
            "::",
            stringify!(phRtHeaps)
        )
    );
}
#[doc = " @brief Parameters for creating a runtime resource."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct RpsRuntimeOpCreateResourceArgs {
    #[doc = "< ID of the resource declaration."]
    pub resourceId: RpsResourceId,
    #[doc = "< Resource description."]
    pub desc: RpsResourceDesc,
    #[doc = "< Unmodified resource description as originally defined by the user."]
    pub originalDesc: RpsVariable,
    #[doc = "< Default value for clearing the resource."]
    pub clearValue: RpsClearValue,
    #[doc = "< GPU memory allocation requirements."]
    pub allocRequirement: RpsGpuMemoryRequirement,
    #[doc = "< Allocation placement parameters."]
    pub allocPlacement: RpsHeapPlacement,
    #[doc = "< Combined accesses of the resource."]
    pub allAccesses: RpsAccessAttr,
    #[doc = "< Inital access of the resource in a frame."]
    pub initialAccess: RpsAccessAttr,
    #[doc = "< Number of mutable formats the resource can be used with."]
    pub numMutableFormats: u32,
    #[doc = "< Pointer to an array of <c><i>RpsFormat</i></c> with"]
    pub mutableFormats: *mut RpsFormat,
    #[doc = "< Indicator for a formatted texel buffer (maps to"]
    pub bBufferFormattedWrite: RpsBool,
    #[doc = "< Indicator for a formatted texel buffer (maps to"]
    pub bBufferFormattedRead: RpsBool,
    #[doc = "< Pointer to a handle to the runtime resource to be returned."]
    pub phRuntimeResource: *mut RpsRuntimeResource,
}
#[test]
fn bindgen_test_layout_RpsRuntimeOpCreateResourceArgs() {
    const UNINIT: ::std::mem::MaybeUninit<RpsRuntimeOpCreateResourceArgs> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<RpsRuntimeOpCreateResourceArgs>(),
        144usize,
        concat!("Size of: ", stringify!(RpsRuntimeOpCreateResourceArgs))
    );
    assert_eq!(
        ::std::mem::align_of::<RpsRuntimeOpCreateResourceArgs>(),
        8usize,
        concat!("Alignment of ", stringify!(RpsRuntimeOpCreateResourceArgs))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).resourceId) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RpsRuntimeOpCreateResourceArgs),
            "::",
            stringify!(resourceId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).desc) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(RpsRuntimeOpCreateResourceArgs),
            "::",
            stringify!(desc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).originalDesc) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(RpsRuntimeOpCreateResourceArgs),
            "::",
            stringify!(originalDesc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).clearValue) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(RpsRuntimeOpCreateResourceArgs),
            "::",
            stringify!(clearValue)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).allocRequirement) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(RpsRuntimeOpCreateResourceArgs),
            "::",
            stringify!(allocRequirement)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).allocPlacement) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(RpsRuntimeOpCreateResourceArgs),
            "::",
            stringify!(allocPlacement)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).allAccesses) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(RpsRuntimeOpCreateResourceArgs),
            "::",
            stringify!(allAccesses)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).initialAccess) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(RpsRuntimeOpCreateResourceArgs),
            "::",
            stringify!(initialAccess)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).numMutableFormats) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(RpsRuntimeOpCreateResourceArgs),
            "::",
            stringify!(numMutableFormats)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mutableFormats) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(RpsRuntimeOpCreateResourceArgs),
            "::",
            stringify!(mutableFormats)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bBufferFormattedWrite) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(RpsRuntimeOpCreateResourceArgs),
            "::",
            stringify!(bBufferFormattedWrite)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bBufferFormattedRead) as usize - ptr as usize },
        132usize,
        concat!(
            "Offset of field: ",
            stringify!(RpsRuntimeOpCreateResourceArgs),
            "::",
            stringify!(bBufferFormattedRead)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).phRuntimeResource) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(RpsRuntimeOpCreateResourceArgs),
            "::",
            stringify!(phRuntimeResource)
        )
    );
}
impl ::std::fmt::Debug for RpsRuntimeOpCreateResourceArgs {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write ! (f , "RpsRuntimeOpCreateResourceArgs {{ desc: {:?}, originalDesc: {:?}, clearValue: {:?}, allocRequirement: {:?}, allocPlacement: {:?}, allAccesses: {:?}, initialAccess: {:?}, mutableFormats: {:?}, phRuntimeResource: {:?} }}" , self . desc , self . originalDesc , self . clearValue , self . allocRequirement , self . allocPlacement , self . allAccesses , self . initialAccess , self . mutableFormats , self . phRuntimeResource)
    }
}
#[doc = " @brief Parameters for destroying an array of runtime resources."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RpsRuntimeOpDestroyResourceArgs {
    #[doc = "< Type of the resources."]
    pub type_: RpsResourceType,
    #[doc = "< Number of resources."]
    pub numResources: u32,
    #[doc = "< Pointer to an array of <c><i>RpsRuntimeResource</i></c> with"]
    pub phRuntimeResources: *const RpsRuntimeResource,
}
#[test]
fn bindgen_test_layout_RpsRuntimeOpDestroyResourceArgs() {
    const UNINIT: ::std::mem::MaybeUninit<RpsRuntimeOpDestroyResourceArgs> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<RpsRuntimeOpDestroyResourceArgs>(),
        16usize,
        concat!("Size of: ", stringify!(RpsRuntimeOpDestroyResourceArgs))
    );
    assert_eq!(
        ::std::mem::align_of::<RpsRuntimeOpDestroyResourceArgs>(),
        8usize,
        concat!("Alignment of ", stringify!(RpsRuntimeOpDestroyResourceArgs))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RpsRuntimeOpDestroyResourceArgs),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).numResources) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(RpsRuntimeOpDestroyResourceArgs),
            "::",
            stringify!(numResources)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).phRuntimeResources) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(RpsRuntimeOpDestroyResourceArgs),
            "::",
            stringify!(phRuntimeResources)
        )
    );
}
#[doc = " @brief Parameters for creating the used defined resources associated with a node.\n\n These can be e.g. descriptor set allocations, PSOs or custom viewports."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RpsRuntimeOpCreateNodeUserResourcesArgs {
    #[doc = "< User defined context to pass to the node."]
    pub pUserContext: *mut ::std::os::raw::c_void,
    #[doc = "< Pointer to an array of <c><i>void*</i></c> with numArgs arguments to be passed to"]
    pub ppArgs: *const *mut ::std::os::raw::c_void,
    #[doc = "< Number of arguments of the node."]
    pub numArgs: u32,
    #[doc = "< User defined node tag to be used for node associations."]
    pub nodeTag: u32,
}
#[test]
fn bindgen_test_layout_RpsRuntimeOpCreateNodeUserResourcesArgs() {
    const UNINIT: ::std::mem::MaybeUninit<RpsRuntimeOpCreateNodeUserResourcesArgs> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<RpsRuntimeOpCreateNodeUserResourcesArgs>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(RpsRuntimeOpCreateNodeUserResourcesArgs)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<RpsRuntimeOpCreateNodeUserResourcesArgs>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(RpsRuntimeOpCreateNodeUserResourcesArgs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pUserContext) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RpsRuntimeOpCreateNodeUserResourcesArgs),
            "::",
            stringify!(pUserContext)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ppArgs) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(RpsRuntimeOpCreateNodeUserResourcesArgs),
            "::",
            stringify!(ppArgs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).numArgs) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(RpsRuntimeOpCreateNodeUserResourcesArgs),
            "::",
            stringify!(numArgs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nodeTag) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(RpsRuntimeOpCreateNodeUserResourcesArgs),
            "::",
            stringify!(nodeTag)
        )
    );
}
#[doc = "< Beginning of a marker region."]
pub const RpsRuntimeDebugMarkerMode_RPS_RUNTIME_DEBUG_MARKER_BEGIN: RpsRuntimeDebugMarkerMode = 0;
#[doc = "< Standalone label."]
pub const RpsRuntimeDebugMarkerMode_RPS_RUNTIME_DEBUG_MARKER_LABEL: RpsRuntimeDebugMarkerMode = 1;
#[doc = "< End of a marker region."]
pub const RpsRuntimeDebugMarkerMode_RPS_RUNTIME_DEBUG_MARKER_END: RpsRuntimeDebugMarkerMode = 2;
#[doc = " @brief Debug marker modes."]
pub type RpsRuntimeDebugMarkerMode = ::std::os::raw::c_uint;
#[doc = "< No special behavior."]
pub const RpsRuntimeRenderPassFlagBits_RPS_RUNTIME_RENDER_PASS_FLAG_NONE:
    RpsRuntimeRenderPassFlagBits = 0;
#[doc = "< Suspending render pass in D3D12."]
pub const RpsRuntimeRenderPassFlagBits_RPS_RUNTIME_RENDER_PASS_SUSPENDING:
    RpsRuntimeRenderPassFlagBits = 1;
#[doc = "< Resuming render pass in D3D12."]
pub const RpsRuntimeRenderPassFlagBits_RPS_RUNTIME_RENDER_PASS_RESUMING:
    RpsRuntimeRenderPassFlagBits = 2;
#[doc = "< Render pass executes secondary command"]
pub const RpsRuntimeRenderPassFlagBits_RPS_RUNTIME_RENDER_PASS_EXECUTE_SECONDARY_COMMAND_BUFFERS:
    RpsRuntimeRenderPassFlagBits = 4;
#[doc = "< Current render pass is on a secondary"]
pub const RpsRuntimeRenderPassFlagBits_RPS_RUNTIME_RENDER_PASS_SECONDARY_COMMAND_BUFFER:
    RpsRuntimeRenderPassFlagBits = 8;
#[doc = " @brief Bitflags for render pass behavior."]
pub type RpsRuntimeRenderPassFlagBits = ::std::os::raw::c_uint;
#[doc = " @brief Bitmask type for  <c><i>RpsRuntimeRenderPassFlagBits</i></c>."]
pub type RpsRuntimeRenderPassFlags = RpsFlags32;
#[doc = " @brief Parameters for recording a debug marker command."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RpsRuntimeOpRecordDebugMarkerArgs {
    #[doc = "< Handle to the runtime command buffer to record the command for."]
    pub hCommandBuffer: RpsRuntimeCommandBuffer,
    #[doc = "< User context passed as RpsRenderGraphRecordCommandInfo::pUserContext."]
    pub pUserRecordContext: *mut ::std::os::raw::c_void,
    #[doc = "< Marker mode."]
    pub mode: RpsRuntimeDebugMarkerMode,
    #[doc = "< String payload of the marker. Ignored for"]
    pub text: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_RpsRuntimeOpRecordDebugMarkerArgs() {
    const UNINIT: ::std::mem::MaybeUninit<RpsRuntimeOpRecordDebugMarkerArgs> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<RpsRuntimeOpRecordDebugMarkerArgs>(),
        32usize,
        concat!("Size of: ", stringify!(RpsRuntimeOpRecordDebugMarkerArgs))
    );
    assert_eq!(
        ::std::mem::align_of::<RpsRuntimeOpRecordDebugMarkerArgs>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(RpsRuntimeOpRecordDebugMarkerArgs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hCommandBuffer) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RpsRuntimeOpRecordDebugMarkerArgs),
            "::",
            stringify!(hCommandBuffer)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pUserRecordContext) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(RpsRuntimeOpRecordDebugMarkerArgs),
            "::",
            stringify!(pUserRecordContext)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mode) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(RpsRuntimeOpRecordDebugMarkerArgs),
            "::",
            stringify!(mode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).text) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(RpsRuntimeOpRecordDebugMarkerArgs),
            "::",
            stringify!(text)
        )
    );
}
#[doc = " @brief Parameters for setting a resource debug name."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RpsRuntimeOpSetDebugNameArgs {
    #[doc = "< Handle to the runtime resource. Only support resource objects at the moment."]
    pub hResource: RpsRuntimeResource,
    #[doc = "< Resource type."]
    pub resourceType: RpsResourceType,
    #[doc = "< Null terminated string with the resource name."]
    pub name: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_RpsRuntimeOpSetDebugNameArgs() {
    const UNINIT: ::std::mem::MaybeUninit<RpsRuntimeOpSetDebugNameArgs> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<RpsRuntimeOpSetDebugNameArgs>(),
        24usize,
        concat!("Size of: ", stringify!(RpsRuntimeOpSetDebugNameArgs))
    );
    assert_eq!(
        ::std::mem::align_of::<RpsRuntimeOpSetDebugNameArgs>(),
        8usize,
        concat!("Alignment of ", stringify!(RpsRuntimeOpSetDebugNameArgs))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hResource) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RpsRuntimeOpSetDebugNameArgs),
            "::",
            stringify!(hResource)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).resourceType) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(RpsRuntimeOpSetDebugNameArgs),
            "::",
            stringify!(resourceType)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(RpsRuntimeOpSetDebugNameArgs),
            "::",
            stringify!(name)
        )
    );
}
#[doc = " @brief Signature of functions for defining an array of render graph phases.\n\n @param pUserContext                     User defined context.\n @param hRenderGraph                     Handle to the render graph to build the phases for.\n                                         Must not be RPS_NULL_HANDLE.\n @param ppPhaseInfo                      Pointer to an array of <c><i>const RpsRenderGraphPhaseInfo*</i></c> in which\n                                         *pNumPhases render graph phase objects are returned. Must not be NULL.\n @param pNumPhases                       Pointer to write the number of created phases to. Must not be NULL.\n\n @returns                                Result code of the operation. See <c><i>RpsResult</i></c> for more info."]
pub type PFN_rpsRuntimeDeviceBuildRenderGraphPhases = ::std::option::Option<
    unsafe extern "C" fn(
        pUserContext: *mut ::std::os::raw::c_void,
        hRenderGraph: RpsRenderGraph,
        ppPhaseInfo: *mut *const RpsRenderGraphPhaseInfo,
        pNumPhases: *mut u32,
    ) -> RpsResult,
>;
#[doc = " @brief Signature of functions for destroying a runtime device.\n\n @param pUserContext                     User defined context."]
pub type PFN_rpsRuntimeDeviceDestroy =
    ::std::option::Option<unsafe extern "C" fn(pUserContext: *mut ::std::os::raw::c_void)>;
#[doc = " @brief Signature of functions for creating a runtime heap.\n\n @param pUserContext                     User defined context.\n @param pArgs                            Pointer to heap creation parameters. Must not be NULL.\n\n @returns                                Result code of the operation. See <c><i>RpsResult</i></c> for more info."]
pub type PFN_rpsRuntimeCreateHeap = ::std::option::Option<
    unsafe extern "C" fn(
        pUserContext: *mut ::std::os::raw::c_void,
        pArgs: *const RpsRuntimeOpCreateHeapArgs,
    ) -> RpsResult,
>;
#[doc = " @brief Signature of functions for destroying runtime heaps.\n\n @param pUserContext                     User defined context.\n @param pArgs                            Pointer to heap destruction parameters. Must not be NULL."]
pub type PFN_rpsRuntimeDestroyHeap = ::std::option::Option<
    unsafe extern "C" fn(
        pUserContext: *mut ::std::os::raw::c_void,
        pArgs: *const RpsRuntimeOpDestroyHeapArgs,
    ),
>;
#[doc = " @brief Signature of functions for creating a runtime resource.\n\n @param pUserContext                     User defined context.\n @param pArgs                            Pointer to resource creation parameters. Must not be NULL.\n\n @returns                                Result code of the operation. See <c><i>RpsResult</i></c> for more info."]
pub type PFN_rpsRuntimeCreateResource = ::std::option::Option<
    unsafe extern "C" fn(
        pUserContext: *mut ::std::os::raw::c_void,
        pArgs: *const RpsRuntimeOpCreateResourceArgs,
    ) -> RpsResult,
>;
#[doc = " @brief Signature of functions for destroying runtime resources.\n\n @param pUserContext                     User defined context.\n @param pArgs                            Pointer to heap destruction parameters. Must not be NULL."]
pub type PFN_rpsRuntimeDestroyResource = ::std::option::Option<
    unsafe extern "C" fn(
        pUserContext: *mut ::std::os::raw::c_void,
        pArgs: *const RpsRuntimeOpDestroyResourceArgs,
    ),
>;
#[doc = " @brief Creates the user defined resources associated with a node.\n\n These can be e.g. descriptor set allocations, PSOs or custom viewports.\n\n @param pUserContext                     User defined context.\n @param pArgs                            Pointer to node arg creation parameters. Must not be NULL.\n\n @returns                                Result code of the operation. See <c><i>RpsResult</i></c> for more info."]
pub type PFN_rpsRuntimeOpCreateNodeUserResources = ::std::option::Option<
    unsafe extern "C" fn(
        pUserContext: *mut ::std::os::raw::c_void,
        pArgs: *const RpsRuntimeOpCreateNodeUserResourcesArgs,
    ) -> RpsResult,
>;
#[doc = " @brief Destroys the user defined resources associated with a node.\n\n These can be e.g. descriptor set allocations, PSOs or custom viewports.\n\n @param pUserContext                     User defined context."]
pub type PFN_rpsRuntimeOpDestroyNodeUserResources =
    ::std::option::Option<unsafe extern "C" fn(pUserContext: *mut ::std::os::raw::c_void)>;
#[doc = " @brief Signature of functions for recording runtime debug markers.\n\n @param pUserContext                     User defined context.\n @param pArgs                            Pointer to debug marker parameters. Must not be NULL."]
pub type PFN_rpsRuntimeOpRecordDebugMarker = ::std::option::Option<
    unsafe extern "C" fn(
        pUserContext: *mut ::std::os::raw::c_void,
        pArgs: *const RpsRuntimeOpRecordDebugMarkerArgs,
    ),
>;
#[doc = " @brief Signature of functions for setting runtime debug names.\n\n @param pUserContext                     User defined context.\n @param pArgs                            Pointer to debug name parameters. Must not be NULL."]
pub type PFN_rpsRuntimeOpSetDebugName = ::std::option::Option<
    unsafe extern "C" fn(
        pUserContext: *mut ::std::os::raw::c_void,
        pArgs: *const RpsRuntimeOpSetDebugNameArgs,
    ),
>;
#[doc = " @brief Callback functions of a runtime."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RpsRuntimeCallbacks {
    #[doc = "< Render graph phase build callback."]
    pub pfnBuildRenderGraphPhases: PFN_rpsRuntimeDeviceBuildRenderGraphPhases,
    #[doc = "< Runtime destruction callback."]
    pub pfnDestroyRuntime: PFN_rpsRuntimeDeviceDestroy,
    #[doc = "< Heap creation callback."]
    pub pfnCreateHeap: PFN_rpsRuntimeCreateHeap,
    #[doc = "< Heap destruction callback."]
    pub pfnDestroyHeap: PFN_rpsRuntimeDestroyHeap,
    #[doc = "< Resource creation callback."]
    pub pfnCreateResource: PFN_rpsRuntimeCreateResource,
    #[doc = "< Resource destruction callback."]
    pub pfnDestroyResource: PFN_rpsRuntimeDestroyResource,
    #[doc = "< Node resource creation callback."]
    pub pfnCreateNodeResources: PFN_rpsRuntimeOpCreateNodeUserResources,
    #[doc = "< Node argument destruction callback."]
    pub pfnDestroyNodeResources: PFN_rpsRuntimeOpDestroyNodeUserResources,
    #[doc = "< Debug marker recording callback."]
    pub pfnRecordDebugMarker: PFN_rpsRuntimeOpRecordDebugMarker,
    #[doc = "< Debug name setting callback."]
    pub pfnSetDebugName: PFN_rpsRuntimeOpSetDebugName,
}
#[test]
fn bindgen_test_layout_RpsRuntimeCallbacks() {
    const UNINIT: ::std::mem::MaybeUninit<RpsRuntimeCallbacks> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<RpsRuntimeCallbacks>(),
        80usize,
        concat!("Size of: ", stringify!(RpsRuntimeCallbacks))
    );
    assert_eq!(
        ::std::mem::align_of::<RpsRuntimeCallbacks>(),
        8usize,
        concat!("Alignment of ", stringify!(RpsRuntimeCallbacks))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pfnBuildRenderGraphPhases) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RpsRuntimeCallbacks),
            "::",
            stringify!(pfnBuildRenderGraphPhases)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pfnDestroyRuntime) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(RpsRuntimeCallbacks),
            "::",
            stringify!(pfnDestroyRuntime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pfnCreateHeap) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(RpsRuntimeCallbacks),
            "::",
            stringify!(pfnCreateHeap)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pfnDestroyHeap) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(RpsRuntimeCallbacks),
            "::",
            stringify!(pfnDestroyHeap)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pfnCreateResource) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(RpsRuntimeCallbacks),
            "::",
            stringify!(pfnCreateResource)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pfnDestroyResource) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(RpsRuntimeCallbacks),
            "::",
            stringify!(pfnDestroyResource)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pfnCreateNodeResources) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(RpsRuntimeCallbacks),
            "::",
            stringify!(pfnCreateNodeResources)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pfnDestroyNodeResources) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(RpsRuntimeCallbacks),
            "::",
            stringify!(pfnDestroyNodeResources)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pfnRecordDebugMarker) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(RpsRuntimeCallbacks),
            "::",
            stringify!(pfnRecordDebugMarker)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pfnSetDebugName) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(RpsRuntimeCallbacks),
            "::",
            stringify!(pfnSetDebugName)
        )
    );
}
#[doc = " @brief Parameters for creating a runtime device."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RpsRuntimeDeviceCreateInfo {
    #[doc = "< User defined context to be passed to the callback functions."]
    pub pUserContext: *mut ::std::os::raw::c_void,
    #[doc = "< Callback functions."]
    pub callbacks: RpsRuntimeCallbacks,
}
#[test]
fn bindgen_test_layout_RpsRuntimeDeviceCreateInfo() {
    const UNINIT: ::std::mem::MaybeUninit<RpsRuntimeDeviceCreateInfo> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<RpsRuntimeDeviceCreateInfo>(),
        88usize,
        concat!("Size of: ", stringify!(RpsRuntimeDeviceCreateInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<RpsRuntimeDeviceCreateInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(RpsRuntimeDeviceCreateInfo))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pUserContext) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RpsRuntimeDeviceCreateInfo),
            "::",
            stringify!(pUserContext)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).callbacks) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(RpsRuntimeDeviceCreateInfo),
            "::",
            stringify!(callbacks)
        )
    );
}
#[doc = " @brief Parameters for creating a dummy runtime device.\n\n A <c><i>NullRuntimeDevice</i></c> is a default implementation of the RuntimeDevice interface without any real GPU\n device associated."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RpsNullRuntimeDeviceCreateInfo {
    #[doc = "< Pointer to parameters for creating the core device"]
    pub pDeviceCreateInfo: *const RpsDeviceCreateInfo,
    #[doc = "< Pointer to parameters for creating the runtime device."]
    pub pRuntimeCreateInfo: *const RpsRuntimeDeviceCreateInfo,
}
#[test]
fn bindgen_test_layout_RpsNullRuntimeDeviceCreateInfo() {
    const UNINIT: ::std::mem::MaybeUninit<RpsNullRuntimeDeviceCreateInfo> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<RpsNullRuntimeDeviceCreateInfo>(),
        16usize,
        concat!("Size of: ", stringify!(RpsNullRuntimeDeviceCreateInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<RpsNullRuntimeDeviceCreateInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(RpsNullRuntimeDeviceCreateInfo))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pDeviceCreateInfo) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RpsNullRuntimeDeviceCreateInfo),
            "::",
            stringify!(pDeviceCreateInfo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pRuntimeCreateInfo) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(RpsNullRuntimeDeviceCreateInfo),
            "::",
            stringify!(pRuntimeCreateInfo)
        )
    );
}
extern "C" {
    #[doc = " @brief Creates a dummy runtime.\n\n For more info see <c><i>RpsNullRuntimeDeviceCreateInfo</i></c>.\n\n @param pCreateInfo                                      Pointer to parameters for creating a dummy runtime. Passing\n                                                         NULL uses default parameters for creation instead.\n @param phDevice                                         Pointer a handle in which the device is returned. Must\n                                                         not be NULL.\n\n @returns                                                Result code of the operation. See <c><i>RpsResult</i></c>\n                                                         for more info."]
    pub fn rpsNullRuntimeDeviceCreate(
        pCreateInfo: *const RpsNullRuntimeDeviceCreateInfo,
        phDevice: *mut RpsDevice,
    ) -> RpsResult;
}
#[doc = " Parameters for creating an RPS program."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RpsProgramCreateInfo {
    #[doc = " Pointer to signature parameters for the program entry. If hRpslEntryPoint is specified, this parameter will be\n ignored and the signature will be taken from the RpslEntry definition.\n Must not be NULL if hRpslEntryPoint == RPS_NULL_HANDLE."]
    pub pSignatureDesc: *const RpsRenderGraphSignatureDesc,
    #[doc = " Handle to the program entry point."]
    pub hRpslEntryPoint: RpsRpslEntry,
    #[doc = " Default node callback. Used when a node is called for which no implementation is bound."]
    pub defaultNodeCallback: RpsCmdCallback,
}
#[test]
fn bindgen_test_layout_RpsProgramCreateInfo() {
    const UNINIT: ::std::mem::MaybeUninit<RpsProgramCreateInfo> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<RpsProgramCreateInfo>(),
        40usize,
        concat!("Size of: ", stringify!(RpsProgramCreateInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<RpsProgramCreateInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(RpsProgramCreateInfo))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pSignatureDesc) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RpsProgramCreateInfo),
            "::",
            stringify!(pSignatureDesc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hRpslEntryPoint) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(RpsProgramCreateInfo),
            "::",
            stringify!(hRpslEntryPoint)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).defaultNodeCallback) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(RpsProgramCreateInfo),
            "::",
            stringify!(defaultNodeCallback)
        )
    );
}
extern "C" {
    #[doc = " @brief Gets the signature description of an RPSL entry point.\n\n @param hRpslEntry               Handle to the RPSL entry point.\n @param pDesc                    Pointer in which the signature description is returned. Must not be NULL.\n\n @returns                        Result code of the operation. See <c><i>RpsResult</i></c> for more info."]
    pub fn rpsRpslEntryGetSignatureDesc(
        hRpslEntry: RpsRpslEntry,
        pDesc: *mut RpsRenderGraphSignatureDesc,
    ) -> RpsResult;
}
extern "C" {
    #[doc = " @brief Creates a subprogram.\n\n @param hDevice                  Handle to the device to use for creation.\n @param pCreateInfo              Pointer to the creation parameters. Must not be NULL.\n @param phProgram                Pointer to a handle in which the subprogram is returned. Must not be NULL.\n\n @returns                        Result code of the operation. See <c><i>RpsResult</i></c> for more info."]
    pub fn rpsProgramCreate(
        hDevice: RpsDevice,
        pCreateInfo: *const RpsProgramCreateInfo,
        phProgram: *mut RpsSubprogram,
    ) -> RpsResult;
}
extern "C" {
    #[doc = " @brief Destroys a subprogram instance.\n\n @param hProgram                 Handle to the subprogram object."]
    pub fn rpsProgramDestroy(hProgram: RpsSubprogram);
}
extern "C" {
    #[doc = " @brief Binds a command node callback to a node declaration specified by name.\n\n Node instances generated from the program with the specified node declaration will call the same callback during\n render graph command recording.\n\n @param hProgram                 Handle to the program to bind a node for.\n @param name                     Null terminated string with the name of the node.\n @param pCallback                Pointer to callback parameters. Passing NULL uses default callback parameters.\n\n @returns                        Result code of the operation. See <c><i>RpsResult</i></c> for more info."]
    pub fn rpsProgramBindNodeCallback(
        hProgram: RpsSubprogram,
        name: *const ::std::os::raw::c_char,
        pCallback: *const RpsCmdCallback,
    ) -> RpsResult;
}
extern "C" {
    #[doc = " @brief Binds a subprogram to a node declaration specified by name.\n\n The subprogram will be executed during render graph update as if inlined into the parent program.\n During render graph command recording, node instances generated from the subprogram will call the subprogram node\n callbacks bindings. Subprograms can be nested recursively.\n\n @param hProgram                 Handle to the program to bind the subprogram to.\n @param name                     Null terminated string with the name of the node.\n @param hSubprogram              Handle to the subprogram to bind.\n\n @returns                        Result code of the operation. See <c><i>RpsResult</i></c> for more info."]
    pub fn rpsProgramBindNodeSubprogram(
        hProgram: RpsSubprogram,
        name: *const ::std::os::raw::c_char,
        hSubprogram: RpsSubprogram,
    ) -> RpsResult;
}
#[doc = " @brief Parameters for creating a render graph."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RpsRenderGraphCreateInfo {
    pub scheduleInfo: RpsRenderGraphCreateInfo__bindgen_ty_1,
    pub memoryInfo: RpsRenderGraphCreateInfo__bindgen_ty_2,
    #[doc = "< Creation parameters for the main entry RPS program."]
    pub mainEntryCreateInfo: RpsProgramCreateInfo,
    #[doc = "< Flags for render graph properties."]
    pub renderGraphFlags: RpsRenderGraphFlags,
    #[doc = " Number of render graph phase objects used by the render graph."]
    pub numPhases: u32,
    #[doc = " Pointer to an array of <c><i>const RpsRenderGraphPhaseInfo</i></c> with numPhases render graph phase objects\n used by the render graph. If null, RPS uses the runtime specified default pipeline to process the render graph."]
    pub pPhases: *const RpsRenderGraphPhaseInfo,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RpsRenderGraphCreateInfo__bindgen_ty_1 {
    #[doc = "< Flags for scheduling behavior."]
    pub scheduleFlags: RpsScheduleFlags,
    #[doc = "< Number of queues available to the render graph. If 0, RPS assumes there"]
    pub numQueues: u32,
    #[doc = "< Pointer to an array of <c><i>RpsQueueFlags</i></c> with numQueues queue"]
    pub pQueueInfos: *const RpsQueueFlags,
}
#[test]
fn bindgen_test_layout_RpsRenderGraphCreateInfo__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<RpsRenderGraphCreateInfo__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<RpsRenderGraphCreateInfo__bindgen_ty_1>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(RpsRenderGraphCreateInfo__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<RpsRenderGraphCreateInfo__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(RpsRenderGraphCreateInfo__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).scheduleFlags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RpsRenderGraphCreateInfo__bindgen_ty_1),
            "::",
            stringify!(scheduleFlags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).numQueues) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(RpsRenderGraphCreateInfo__bindgen_ty_1),
            "::",
            stringify!(numQueues)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pQueueInfos) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(RpsRenderGraphCreateInfo__bindgen_ty_1),
            "::",
            stringify!(pQueueInfos)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RpsRenderGraphCreateInfo__bindgen_ty_2 {
    #[doc = "< Number of memory heaps available to the render graph."]
    pub numHeaps: u32,
    #[doc = "< Pointer to an array of <c><i>uint32_t</i></c> numHeaps memory sizes as"]
    pub heapBudgetMiBs: *const u32,
}
#[test]
fn bindgen_test_layout_RpsRenderGraphCreateInfo__bindgen_ty_2() {
    const UNINIT: ::std::mem::MaybeUninit<RpsRenderGraphCreateInfo__bindgen_ty_2> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<RpsRenderGraphCreateInfo__bindgen_ty_2>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(RpsRenderGraphCreateInfo__bindgen_ty_2)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<RpsRenderGraphCreateInfo__bindgen_ty_2>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(RpsRenderGraphCreateInfo__bindgen_ty_2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).numHeaps) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RpsRenderGraphCreateInfo__bindgen_ty_2),
            "::",
            stringify!(numHeaps)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).heapBudgetMiBs) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(RpsRenderGraphCreateInfo__bindgen_ty_2),
            "::",
            stringify!(heapBudgetMiBs)
        )
    );
}
#[test]
fn bindgen_test_layout_RpsRenderGraphCreateInfo() {
    const UNINIT: ::std::mem::MaybeUninit<RpsRenderGraphCreateInfo> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<RpsRenderGraphCreateInfo>(),
        88usize,
        concat!("Size of: ", stringify!(RpsRenderGraphCreateInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<RpsRenderGraphCreateInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(RpsRenderGraphCreateInfo))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).scheduleInfo) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RpsRenderGraphCreateInfo),
            "::",
            stringify!(scheduleInfo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).memoryInfo) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(RpsRenderGraphCreateInfo),
            "::",
            stringify!(memoryInfo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mainEntryCreateInfo) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(RpsRenderGraphCreateInfo),
            "::",
            stringify!(mainEntryCreateInfo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).renderGraphFlags) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(RpsRenderGraphCreateInfo),
            "::",
            stringify!(renderGraphFlags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).numPhases) as usize - ptr as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(RpsRenderGraphCreateInfo),
            "::",
            stringify!(numPhases)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pPhases) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(RpsRenderGraphCreateInfo),
            "::",
            stringify!(pPhases)
        )
    );
}
extern "C" {
    #[doc = " @brief Creates a render graph.\n\n @param hDevice                              Handle to the device to use for creation. Must not be RPS_NULL_HANDLE.\n @param pCreateInfo                          Pointer to creation parameters. Must not be NULL.\n @param phRenderGraph                        Pointer a handle in which the render graph is returned.\n                                             Must not be NULL.\n\n @returns                                    Result code of the operation. See <c><i>RpsResult</i></c> for more info."]
    pub fn rpsRenderGraphCreate(
        hDevice: RpsDevice,
        pCreateInfo: *const RpsRenderGraphCreateInfo,
        phRenderGraph: *mut RpsRenderGraph,
    ) -> RpsResult;
}
extern "C" {
    #[doc = " @brief Updates a render graph.\n\n @param hRenderGraph                         Handle to the render graph to update. Must not be RPS_NULL_HANDLE.\n @param pUpdateInfo                          Pointer to update parameters. Must not be NULL.\n\n @returns                                    RpsResult indicating potential errors during the execution. See\n                                             <c><i>RpsResult</i></c> for more info."]
    pub fn rpsRenderGraphUpdate(
        hRenderGraph: RpsRenderGraph,
        pUpdateInfo: *const RpsRenderGraphUpdateInfo,
    ) -> RpsResult;
}
extern "C" {
    #[doc = " @brief Destroys a render graph.\n\n @param hRenderGraph                         Handle to the render graph object to destroy."]
    pub fn rpsRenderGraphDestroy(hRenderGraph: RpsRenderGraph);
}
extern "C" {
    #[doc = " @brief Allocates memory from a render graph builder.\n\n @param hRenderGraphBuilder      Handle to the render graph builder. Must not be RPS_NULL_HANDLE.\n @param size                     Required size of the allocation.\n\n @returns                        Pointer to the allocated memory if the allocation was successful, NULL otherwise.\n                                 Only valid until the next render graph update."]
    pub fn rpsRenderGraphAllocateData(
        hRenderGraphBuilder: RpsRenderGraphBuilder,
        size: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " @brief Allocates memory from a render graph builder with alignment requirements.\n\n @param hRenderGraphBuilder      Handle to the render graph builder. Must not be RPS_NULL_HANDLE.\n @param size                     Required size of the allocation.\n @param alignment                Minimum alignment requirement of the allocation in bytes.\n\n @returns                        Pointer to the allocated memory if allocation was successful, NULL otherwise.\n                                 Only valid until the next render graph update."]
    pub fn rpsRenderGraphAllocateDataAligned(
        hRenderGraphBuilder: RpsRenderGraphBuilder,
        size: usize,
        alignment: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " @brief Declare an on-demand node type during the render graph construction.\n\n Normally, node declarations are specified in the RenderGraphSignature ahead of time. This function allows\n additional node declarations to be added. Note: The lifetime of the dynamic node declaration is temporary\n and it is only valid until the next render graph update.\n\n @param hRenderGraphBuilder      Handle to the render graph builder. Must not be RPS_NULL_HANDLE.\n @param pNodeDesc                Pointer to a node description. Passing NULL for the name of the description\n                                 registers the node as a fallback for calling unknown nodes.\n\n @returns                        ID of the node declaration if successful, RPS_NODEDECL_ID_INVALID otherwise."]
    pub fn rpsRenderGraphDeclareDynamicNode(
        hRenderGraphBuilder: RpsRenderGraphBuilder,
        pNodeDesc: *const RpsNodeDesc,
    ) -> RpsNodeDeclId;
}
extern "C" {
    #[doc = " @brief Gets a variable from the render graph builder by its ID.\n\n @param hRenderGraphBuilder      Handle to the render graph builder to get the variable from.\n @param paramId                  Index of the parameter.\n\n @returns                        Variable identified by its ID."]
    pub fn rpsRenderGraphGetParamVariable(
        hRenderGraphBuilder: RpsRenderGraphBuilder,
        paramId: RpsParamId,
    ) -> RpsVariable;
}
extern "C" {
    #[doc = " @brief Gets the resource ID of a resource parameter by the parameter ID.\n\n Resource parameters have RPS_PARAMETER_FLAG_RESOURCE_BIT set and Resources are expected to be provided externally\n to the render graph.\n\n @param hRenderGraphBuilder      Handle to the render graph builder. Must not be RPS_NULL_HANDLE.\n @param paramId                  Index of the parameter.\n\n @returns                        ID of the resource identified by its parameter ID."]
    pub fn rpsRenderGraphGetParamResourceId(
        hRenderGraphBuilder: RpsRenderGraphBuilder,
        paramId: RpsParamId,
    ) -> RpsResourceId;
}
extern "C" {
    #[doc = " @brief Declare a render graph managed resource.\n\n @param hRenderGraphBuilder      Handle to the render graph builder. Must not be RPS_NULL_HANDLE.\n @param name                     Null terminated string with the name of the resource.\n @param localId                  Subprogram local ID of the resource.\n @param hDesc                    Handle to the description of the resource.\n\n @returns                        ID of the declared resource."]
    pub fn rpsRenderGraphDeclareResource(
        hRenderGraphBuilder: RpsRenderGraphBuilder,
        name: *const ::std::os::raw::c_char,
        localId: RpsResourceId,
        hDesc: RpsVariable,
    ) -> RpsResourceId;
}
extern "C" {
    #[doc = " @brief Adds a render graph node to a render graph.\n\n @param hRenderGraphBuilder              Handle to the render graph builder. Must not be RPS_NULL_HANDLE.\n @param nodeDeclId                       Node declaration ID.\n @param userTag                          User controlled tag for associations with a node call. Is accessible through\n                                         <c><i>RpsCmdCallbackContext</i></c>.\n @param callback                         Pointer to the callback function.\n @param pCallbackUserContext             Pointer to a user controlled structure to be passed to the callback.\n @param callbackFlags                    Flags controlling the callback behavior.\n @param pArgs                            Pointer to the parameters used for the callback.\n                                         Must not be NULL if numArgs != 0.\n @param numArgs                          Number of parameters used for the callback.\n\n @returns                                ID of the command node."]
    pub fn rpsRenderGraphAddNode(
        hRenderGraphBuilder: RpsRenderGraphBuilder,
        nodeDeclId: RpsNodeDeclId,
        userTag: u32,
        callback: PFN_rpsCmdCallback,
        pCallbackUserContext: *mut ::std::os::raw::c_void,
        callbackFlags: RpsCmdCallbackFlags,
        pArgs: *const RpsVariable,
        numArgs: u32,
    ) -> RpsNodeId;
}
extern "C" {
    #[doc = " @brief Gets the runtime resource info from a resource ID.\n\n Can be used to retrieve information such as the API resource handle, resource description and subresource info.\n\n @param hRenderGraph                         Handle to the render graph to get the resource info from. Must not be\n                                             RPS_NULL_HANDLE.\n @param resourceId                           The index to the resource to get. This can be the index returned by\n                                             rpsRenderGraphDeclareResource or rpsRenderGraphGetParamResourceId.\n @param temporalLayerIndex                   The temporal layer index. Ignored for non-temporal resource.\n @param pResourceInfo                        Pointer in which the runtime resource info is returned. Must not be NULL.\n\n @returns                                    Result code of the operation. See <c><i>RpsResult</i></c> for more info."]
    pub fn rpsRenderGraphGetResourceInfo(
        hRenderGraph: RpsRenderGraph,
        resourceId: RpsResourceId,
        temporalLayerIndex: u32,
        pResourceInfo: *mut RpsRuntimeResourceInfo,
    ) -> RpsResult;
}
extern "C" {
    #[doc = " @brief Gets the runtime resource info of an output parameter.\n\n When updating a render graph, any resource handle returned through pResourceInfos will have updated if there was\n an update to the corresponding output resource description. Make sure to call this function after updating a render\n graph to get any updated handles.\n\n @param hRenderGraph                         Handle to the render graph to get the resource info from.\n @param paramId                              Index of the resource parameter. Must be an output resource parameter\n                                             of a render graph entry (Declared as 'out [...] texture / buffer' in\n                                             RPSL or with\n                                             (RPS_PARAMETER_FLAG_OUT_BIT | RPS_PARAMETER_FLAG_RESOURCE_BIT) set.\n @param arrayOffset                          Offset of the first parameters for array parameters. Must be 0\n                                             otherwise.\n @param numResources                         Number of resources to get infos for.\n @param pResourceInfos                       Pointer to an array of <c><i>RpsRuntimeResourceInfo</i></c> in which the\n                                             numResources resource infos are returned. Must not be NULL if\n                                             numResources != 0.\n\n @returns                                    Result code of the operation. See <c><i>RpsResult</i></c> for more info."]
    pub fn rpsRenderGraphGetOutputParameterResourceInfos(
        hRenderGraph: RpsRenderGraph,
        paramId: RpsParamId,
        arrayOffset: u32,
        numResources: u32,
        pResourceInfos: *mut RpsRuntimeResourceInfo,
    ) -> RpsResult;
}
extern "C" {
    #[doc = " @brief Gets the main entry of a render graph.\n\n @param hRenderGraph             Handle to the render graph. Must not be RPS_NULL_HANDLE.\n\n @returns                        Result code of the operation. See <c><i>RpsResult</i></c> for more info."]
    pub fn rpsRenderGraphGetMainEntry(hRenderGraph: RpsRenderGraph) -> RpsSubprogram;
}
#[doc = " @brief Parameters of a batch of commands to be recorded by the graphics API in use.\n\n These commands are the result of scheduling and have to be executed on the same queue."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RpsCommandBatch {
    #[doc = "< Index of the queue to submit the current batch to."]
    pub queueIndex: u32,
    #[doc = "< Offset of the range of fence IDs into the"]
    pub waitFencesBegin: u32,
    #[doc = "< Number of fence IDs to wait for before submitting."]
    pub numWaitFences: u32,
    #[doc = "< Index of the fence to signal after submitting."]
    pub signalFenceIndex: u32,
    #[doc = "< Index of the first runtime command in the batch."]
    pub cmdBegin: u32,
    #[doc = "< Number of runtime commands in the batch."]
    pub numCmds: u32,
}
#[test]
fn bindgen_test_layout_RpsCommandBatch() {
    const UNINIT: ::std::mem::MaybeUninit<RpsCommandBatch> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<RpsCommandBatch>(),
        24usize,
        concat!("Size of: ", stringify!(RpsCommandBatch))
    );
    assert_eq!(
        ::std::mem::align_of::<RpsCommandBatch>(),
        4usize,
        concat!("Alignment of ", stringify!(RpsCommandBatch))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).queueIndex) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RpsCommandBatch),
            "::",
            stringify!(queueIndex)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).waitFencesBegin) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(RpsCommandBatch),
            "::",
            stringify!(waitFencesBegin)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).numWaitFences) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(RpsCommandBatch),
            "::",
            stringify!(numWaitFences)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).signalFenceIndex) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(RpsCommandBatch),
            "::",
            stringify!(signalFenceIndex)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cmdBegin) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(RpsCommandBatch),
            "::",
            stringify!(cmdBegin)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).numCmds) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(RpsCommandBatch),
            "::",
            stringify!(numCmds)
        )
    );
}
#[doc = " @brief Parameters of the command batch layout of a render graph."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RpsRenderGraphBatchLayout {
    #[doc = "< Number of command batches."]
    pub numCmdBatches: u32,
    #[doc = "< Number of fence signals in the pipeline."]
    pub numFenceSignals: u32,
    #[doc = "< Pointer to an array of <c><i>const RpsCommandBatch</i></c> with"]
    pub pCmdBatches: *const RpsCommandBatch,
    #[doc = "< Pointer to an array of <c><i>const uint32_t</i></c> numFenceSignals"]
    pub pWaitFenceIndices: *const u32,
}
#[test]
fn bindgen_test_layout_RpsRenderGraphBatchLayout() {
    const UNINIT: ::std::mem::MaybeUninit<RpsRenderGraphBatchLayout> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<RpsRenderGraphBatchLayout>(),
        24usize,
        concat!("Size of: ", stringify!(RpsRenderGraphBatchLayout))
    );
    assert_eq!(
        ::std::mem::align_of::<RpsRenderGraphBatchLayout>(),
        8usize,
        concat!("Alignment of ", stringify!(RpsRenderGraphBatchLayout))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).numCmdBatches) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RpsRenderGraphBatchLayout),
            "::",
            stringify!(numCmdBatches)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).numFenceSignals) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(RpsRenderGraphBatchLayout),
            "::",
            stringify!(numFenceSignals)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pCmdBatches) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(RpsRenderGraphBatchLayout),
            "::",
            stringify!(pCmdBatches)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pWaitFenceIndices) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(RpsRenderGraphBatchLayout),
            "::",
            stringify!(pWaitFenceIndices)
        )
    );
}
#[doc = "< No recording options."]
pub const RpsRecordCommandFlagBits_RPS_RECORD_COMMAND_FLAG_NONE: RpsRecordCommandFlagBits = 0;
#[doc = "< Enables per-command debug markers during"]
pub const RpsRecordCommandFlagBits_RPS_RECORD_COMMAND_FLAG_ENABLE_COMMAND_DEBUG_MARKERS:
    RpsRecordCommandFlagBits = 1;
#[doc = " @brief Bitflags for recording commands."]
pub type RpsRecordCommandFlagBits = ::std::os::raw::c_uint;
#[doc = " @brief Bitmask type for <c><i>RpsRecordCommandFlagBits</i></c>."]
pub type RpsRecordCommandFlags = RpsFlags32;
#[doc = " @brief Parameters for recording commands using a processed render graph."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RpsRenderGraphRecordCommandInfo {
    #[doc = "< Handle to the runtime command buffer object."]
    pub hCmdBuffer: RpsRuntimeCommandBuffer,
    #[doc = "< User defined context to be passed to the callbacks during recording."]
    pub pUserContext: *mut ::std::os::raw::c_void,
    #[doc = "< Index of the frame to record commands for."]
    pub frameIndex: u64,
    #[doc = "< Index of the first command to be recorded."]
    pub cmdBeginIndex: u32,
    #[doc = "< Number of commands to record."]
    pub numCmds: u32,
    #[doc = "< Flags for specifying recording behavior."]
    pub flags: RpsRecordCommandFlags,
}
#[test]
fn bindgen_test_layout_RpsRenderGraphRecordCommandInfo() {
    const UNINIT: ::std::mem::MaybeUninit<RpsRenderGraphRecordCommandInfo> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<RpsRenderGraphRecordCommandInfo>(),
        40usize,
        concat!("Size of: ", stringify!(RpsRenderGraphRecordCommandInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<RpsRenderGraphRecordCommandInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(RpsRenderGraphRecordCommandInfo))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hCmdBuffer) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RpsRenderGraphRecordCommandInfo),
            "::",
            stringify!(hCmdBuffer)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pUserContext) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(RpsRenderGraphRecordCommandInfo),
            "::",
            stringify!(pUserContext)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).frameIndex) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(RpsRenderGraphRecordCommandInfo),
            "::",
            stringify!(frameIndex)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cmdBeginIndex) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(RpsRenderGraphRecordCommandInfo),
            "::",
            stringify!(cmdBeginIndex)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).numCmds) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(RpsRenderGraphRecordCommandInfo),
            "::",
            stringify!(numCmds)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(RpsRenderGraphRecordCommandInfo),
            "::",
            stringify!(flags)
        )
    );
}
extern "C" {
    #[doc = " @brief Gets the command batch layout of a render graph.\n\n @param hRenderGraph                         Handle to the render graph. Must not be RPS_NULL_HANDLE.\n @param pBatchLayout                         Pointer to return the batch layout in. Must not be NULL.\n\n @returns                                    Result code of the operation. See <c><i>RpsResult</i></c> for more info."]
    pub fn rpsRenderGraphGetBatchLayout(
        hRenderGraph: RpsRenderGraph,
        pBatchLayout: *mut RpsRenderGraphBatchLayout,
    ) -> RpsResult;
}
extern "C" {
    #[doc = " @brief Records graphics API commands from a processed render graph.\n\n @param hRenderGraph                         Handle to the render graph. Must not be RPS_NULL_HANDLE.\n @param pRecordInfo                          Pointer to recording parameters. Must not be NULL.\n\n @returns                                    Result code of the operation. See <c><i>RpsResult</i></c> for more info."]
    pub fn rpsRenderGraphRecordCommands(
        hRenderGraph: RpsRenderGraph,
        pRecordInfo: *const RpsRenderGraphRecordCommandInfo,
    ) -> RpsResult;
}
#[doc = " @brief Diagnostic information for a command of the render graph command stream."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct RpsCmdDiagnosticInfo {
    #[doc = "< Index of the command in the scheduled command stream. Also used for"]
    pub cmdIndex: u32,
    #[doc = "< Indicator for transition commands."]
    pub isTransition: RpsBool,
    pub __bindgen_anon_1: RpsCmdDiagnosticInfo__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union RpsCmdDiagnosticInfo__bindgen_ty_1 {
    pub cmd: RpsCmdDiagnosticInfo__bindgen_ty_1__bindgen_ty_1,
    pub transition: RpsCmdDiagnosticInfo__bindgen_ty_1__bindgen_ty_2,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RpsCmdDiagnosticInfo__bindgen_ty_1__bindgen_ty_1 {
    #[doc = "< Dummy value to avoid an empty struct."]
    pub dummy: u32,
}
#[test]
fn bindgen_test_layout_RpsCmdDiagnosticInfo__bindgen_ty_1__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<RpsCmdDiagnosticInfo__bindgen_ty_1__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<RpsCmdDiagnosticInfo__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(RpsCmdDiagnosticInfo__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<RpsCmdDiagnosticInfo__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(RpsCmdDiagnosticInfo__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dummy) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RpsCmdDiagnosticInfo__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(dummy)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RpsCmdDiagnosticInfo__bindgen_ty_1__bindgen_ty_2 {
    #[doc = "< Access before the current transition."]
    pub prevAccess: RpsAccessAttr,
    #[doc = "< Access after the current transition."]
    pub nextAccess: RpsAccessAttr,
    #[doc = "< Access range for the transition."]
    pub range: RpsSubresourceRange,
    #[doc = "< Index of the resource to transition."]
    pub resourceIndex: u32,
}
#[test]
fn bindgen_test_layout_RpsCmdDiagnosticInfo__bindgen_ty_1__bindgen_ty_2() {
    const UNINIT: ::std::mem::MaybeUninit<RpsCmdDiagnosticInfo__bindgen_ty_1__bindgen_ty_2> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<RpsCmdDiagnosticInfo__bindgen_ty_1__bindgen_ty_2>(),
        32usize,
        concat!(
            "Size of: ",
            stringify!(RpsCmdDiagnosticInfo__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<RpsCmdDiagnosticInfo__bindgen_ty_1__bindgen_ty_2>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(RpsCmdDiagnosticInfo__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).prevAccess) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RpsCmdDiagnosticInfo__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(prevAccess)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nextAccess) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(RpsCmdDiagnosticInfo__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(nextAccess)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).range) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(RpsCmdDiagnosticInfo__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(range)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).resourceIndex) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(RpsCmdDiagnosticInfo__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(resourceIndex)
        )
    );
}
#[test]
fn bindgen_test_layout_RpsCmdDiagnosticInfo__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<RpsCmdDiagnosticInfo__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<RpsCmdDiagnosticInfo__bindgen_ty_1>(),
        32usize,
        concat!("Size of: ", stringify!(RpsCmdDiagnosticInfo__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<RpsCmdDiagnosticInfo__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(RpsCmdDiagnosticInfo__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cmd) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RpsCmdDiagnosticInfo__bindgen_ty_1),
            "::",
            stringify!(cmd)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).transition) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RpsCmdDiagnosticInfo__bindgen_ty_1),
            "::",
            stringify!(transition)
        )
    );
}
impl ::std::fmt::Debug for RpsCmdDiagnosticInfo__bindgen_ty_1 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(f, "RpsCmdDiagnosticInfo__bindgen_ty_1 {{ union }}")
    }
}
#[test]
fn bindgen_test_layout_RpsCmdDiagnosticInfo() {
    const UNINIT: ::std::mem::MaybeUninit<RpsCmdDiagnosticInfo> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<RpsCmdDiagnosticInfo>(),
        40usize,
        concat!("Size of: ", stringify!(RpsCmdDiagnosticInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<RpsCmdDiagnosticInfo>(),
        4usize,
        concat!("Alignment of ", stringify!(RpsCmdDiagnosticInfo))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cmdIndex) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RpsCmdDiagnosticInfo),
            "::",
            stringify!(cmdIndex)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).isTransition) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(RpsCmdDiagnosticInfo),
            "::",
            stringify!(isTransition)
        )
    );
}
impl ::std::fmt::Debug for RpsCmdDiagnosticInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(
            f,
            "RpsCmdDiagnosticInfo {{ __bindgen_anon_1: {:?} }}",
            self.__bindgen_anon_1
        )
    }
}
#[doc = " @brief Diagnostic information for a resource."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct RpsResourceDiagnosticInfo {
    #[doc = "< Null terminated string with the name of the resource."]
    pub name: *const ::std::os::raw::c_char,
    #[doc = "< Index to the first temporal child of the temporal parent. Only for"]
    pub temporalChildIndex: u32,
    #[doc = "< Indicator for external resources."]
    pub isExternal: RpsBool,
    #[doc = "< Description of the resource."]
    pub desc: RpsResourceDesc,
    #[doc = "< Clear value of the resource."]
    pub clearValue: RpsClearValue,
    #[doc = "< Combination of all accesses of the resource throughout the frame."]
    pub allAccesses: RpsAccessAttr,
    #[doc = "< Initial access of the resource."]
    pub initialAccess: RpsAccessAttr,
    #[doc = "< Index of the first command to which the runtime resource is active"]
    pub lifetimeBegin: u32,
    #[doc = "< Index of the last command to which the runtime resource is active"]
    pub lifetimeEnd: u32,
    #[doc = "< Allocation requirements for the memory of the resource."]
    pub allocRequirement: RpsGpuMemoryRequirement,
    #[doc = "< Allocation placement for the memory of the resource."]
    pub allocPlacement: RpsHeapPlacement,
    #[doc = "< Handle to the backend specific resource."]
    pub hRuntimeResource: RpsRuntimeResource,
}
#[test]
fn bindgen_test_layout_RpsResourceDiagnosticInfo() {
    const UNINIT: ::std::mem::MaybeUninit<RpsResourceDiagnosticInfo> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<RpsResourceDiagnosticInfo>(),
        136usize,
        concat!("Size of: ", stringify!(RpsResourceDiagnosticInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<RpsResourceDiagnosticInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(RpsResourceDiagnosticInfo))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RpsResourceDiagnosticInfo),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).temporalChildIndex) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(RpsResourceDiagnosticInfo),
            "::",
            stringify!(temporalChildIndex)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).isExternal) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(RpsResourceDiagnosticInfo),
            "::",
            stringify!(isExternal)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).desc) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(RpsResourceDiagnosticInfo),
            "::",
            stringify!(desc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).clearValue) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(RpsResourceDiagnosticInfo),
            "::",
            stringify!(clearValue)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).allAccesses) as usize - ptr as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(RpsResourceDiagnosticInfo),
            "::",
            stringify!(allAccesses)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).initialAccess) as usize - ptr as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(RpsResourceDiagnosticInfo),
            "::",
            stringify!(initialAccess)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).lifetimeBegin) as usize - ptr as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(RpsResourceDiagnosticInfo),
            "::",
            stringify!(lifetimeBegin)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).lifetimeEnd) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(RpsResourceDiagnosticInfo),
            "::",
            stringify!(lifetimeEnd)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).allocRequirement) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(RpsResourceDiagnosticInfo),
            "::",
            stringify!(allocRequirement)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).allocPlacement) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(RpsResourceDiagnosticInfo),
            "::",
            stringify!(allocPlacement)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hRuntimeResource) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(RpsResourceDiagnosticInfo),
            "::",
            stringify!(hRuntimeResource)
        )
    );
}
impl ::std::fmt::Debug for RpsResourceDiagnosticInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write ! (f , "RpsResourceDiagnosticInfo {{ name: {:?}, desc: {:?}, clearValue: {:?}, allAccesses: {:?}, initialAccess: {:?}, allocRequirement: {:?}, allocPlacement: {:?}, hRuntimeResource: {:?} }}" , self . name , self . desc , self . clearValue , self . allAccesses , self . initialAccess , self . allocRequirement , self . allocPlacement , self . hRuntimeResource)
    }
}
#[doc = " @brief Diagnostic information for a heap."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RpsHeapDiagnosticInfo {
    #[doc = "< Total size of the heap. May be 0 if the heap is not created in the backend"]
    pub size: u64,
    #[doc = "< Amount of memory allocated from the heap."]
    pub usedSize: u64,
    #[doc = "< Maximum amount of memory ever allocated from the heap."]
    pub maxUsedSize: u64,
    #[doc = "< Alignment of the heap in bytes."]
    pub alignment: u32,
    #[doc = "< Index of the backend specific memory type of the heap."]
    pub memoryTypeIndex: u32,
    #[doc = "< Handle to the backend specific heap implementation."]
    pub hRuntimeHeap: RpsRuntimeHeap,
}
#[test]
fn bindgen_test_layout_RpsHeapDiagnosticInfo() {
    const UNINIT: ::std::mem::MaybeUninit<RpsHeapDiagnosticInfo> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<RpsHeapDiagnosticInfo>(),
        40usize,
        concat!("Size of: ", stringify!(RpsHeapDiagnosticInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<RpsHeapDiagnosticInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(RpsHeapDiagnosticInfo))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RpsHeapDiagnosticInfo),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).usedSize) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(RpsHeapDiagnosticInfo),
            "::",
            stringify!(usedSize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).maxUsedSize) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(RpsHeapDiagnosticInfo),
            "::",
            stringify!(maxUsedSize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).alignment) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(RpsHeapDiagnosticInfo),
            "::",
            stringify!(alignment)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).memoryTypeIndex) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(RpsHeapDiagnosticInfo),
            "::",
            stringify!(memoryTypeIndex)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hRuntimeHeap) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(RpsHeapDiagnosticInfo),
            "::",
            stringify!(hRuntimeHeap)
        )
    );
}
#[doc = " @brief Diagnostic information for parts of a render graph."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RpsRenderGraphDiagnosticInfo {
    #[doc = "< Number of resource infos."]
    pub numResourceInfos: u32,
    #[doc = "< Number of command infos."]
    pub numCommandInfos: u32,
    #[doc = "< Number of heap infos."]
    pub numHeapInfos: u32,
    #[doc = " Pointer to an array of <c><i>RpsResourceDiagnosticInfo</i></c> with numResourceInfos resource infos."]
    pub pResourceDiagInfos: *const RpsResourceDiagnosticInfo,
    #[doc = " Pointer to an array of <c><i>RpsCmdDiagnosticInfo</i></c> with numCommandInfos command infos."]
    pub pCmdDiagInfos: *const RpsCmdDiagnosticInfo,
    #[doc = " Pointer to an array of <c><i>RpsHeapDiagnosticInfo</i></c> with numHeapInfos heap infos."]
    pub pHeapDiagInfos: *const RpsHeapDiagnosticInfo,
}
#[test]
fn bindgen_test_layout_RpsRenderGraphDiagnosticInfo() {
    const UNINIT: ::std::mem::MaybeUninit<RpsRenderGraphDiagnosticInfo> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<RpsRenderGraphDiagnosticInfo>(),
        40usize,
        concat!("Size of: ", stringify!(RpsRenderGraphDiagnosticInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<RpsRenderGraphDiagnosticInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(RpsRenderGraphDiagnosticInfo))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).numResourceInfos) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RpsRenderGraphDiagnosticInfo),
            "::",
            stringify!(numResourceInfos)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).numCommandInfos) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(RpsRenderGraphDiagnosticInfo),
            "::",
            stringify!(numCommandInfos)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).numHeapInfos) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(RpsRenderGraphDiagnosticInfo),
            "::",
            stringify!(numHeapInfos)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pResourceDiagInfos) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(RpsRenderGraphDiagnosticInfo),
            "::",
            stringify!(pResourceDiagInfos)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pCmdDiagInfos) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(RpsRenderGraphDiagnosticInfo),
            "::",
            stringify!(pCmdDiagInfos)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pHeapDiagInfos) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(RpsRenderGraphDiagnosticInfo),
            "::",
            stringify!(pHeapDiagInfos)
        )
    );
}
#[doc = "< Diagnostic info is taken from the latest frame."]
pub const RpsRenderGraphDiagnosticInfoFlagBits_RPS_RENDER_GRAPH_DIAGNOSTIC_INFO_DEFAULT:
    RpsRenderGraphDiagnosticInfoFlagBits = 0;
#[doc = "< The previously cached diagnostic info is returned\n< if not called for the first time."]
pub const RpsRenderGraphDiagnosticInfoFlagBits_RPS_RENDER_GRAPH_DIAGNOSTIC_INFO_USE_CACHED_BIT:
    RpsRenderGraphDiagnosticInfoFlagBits = 1;
#[doc = " @brief Bitflags for diagnostic info modes."]
pub type RpsRenderGraphDiagnosticInfoFlagBits = ::std::os::raw::c_uint;
#[doc = " @brief Bitmask type for <c><i>RpsRenderGraphDiagnosticInfoFlagBits</i></c>."]
pub type RpsRenderGraphDiagnosticInfoFlags = RpsFlags32;
extern "C" {
    #[doc = " @brief Gets diagnostic information from a render graph.\n\n Diagnostic information is intended to be consumed by tools related to RPS, e.g. the visualizer tool set.\n\n @param hRenderGraph                      Handle to the render graph. Must not be RPS_NULL_HANDLE.\n @param pDiagInfo                         Pointer in which the diagnostic information is returned. Must not be NULL.\n @param diagnosticFlags                   Flags for the diagnostic mode.\n\n @returns                                 Result code of the operation. See <c><i>RpsResult</i></c> for more info."]
    pub fn rpsRenderGraphGetDiagnosticInfo(
        hRenderGraph: RpsRenderGraph,
        pDiagInfo: *mut RpsRenderGraphDiagnosticInfo,
        diagnosticFlags: RpsRenderGraphDiagnosticInfoFlags,
    ) -> RpsResult;
}
#[doc = " @brief Parameters of a command callback context."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RpsCmdCallbackContext {
    #[doc = " Handle to the command buffer for command recording."]
    pub hCommandBuffer: RpsRuntimeCommandBuffer,
    #[doc = " User context passed as RpsRenderGraphRecordCommandInfo::pUserContext. Can vary per rpsRenderGraphRecordCommands\n call and can e.g. be used as per-thread context if doing multi-threaded recording."]
    pub pUserRecordContext: *mut ::std::os::raw::c_void,
    #[doc = " User context specified with the command node callback function, for example via a rpsProgramBindNode call. Can\n vary per callback."]
    pub pCmdCallbackContext: *mut ::std::os::raw::c_void,
    #[doc = " Pointer to an array of <c><i>void* const</i></c> with numArgs pointers to arguments to use for the callback.\n Must not be NULL if numArgs != 0."]
    pub ppArgs: *const *mut ::std::os::raw::c_void,
    #[doc = " Number of arguments defined for the callback."]
    pub numArgs: u32,
    #[doc = " User defined tag for associations with a specific node. Can be set by passing a value to\n <c><i>rpsCmdCallNode</i></c>."]
    pub userTag: u32,
}
#[test]
fn bindgen_test_layout_RpsCmdCallbackContext() {
    const UNINIT: ::std::mem::MaybeUninit<RpsCmdCallbackContext> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<RpsCmdCallbackContext>(),
        40usize,
        concat!("Size of: ", stringify!(RpsCmdCallbackContext))
    );
    assert_eq!(
        ::std::mem::align_of::<RpsCmdCallbackContext>(),
        8usize,
        concat!("Alignment of ", stringify!(RpsCmdCallbackContext))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hCommandBuffer) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RpsCmdCallbackContext),
            "::",
            stringify!(hCommandBuffer)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pUserRecordContext) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(RpsCmdCallbackContext),
            "::",
            stringify!(pUserRecordContext)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pCmdCallbackContext) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(RpsCmdCallbackContext),
            "::",
            stringify!(pCmdCallbackContext)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ppArgs) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(RpsCmdCallbackContext),
            "::",
            stringify!(ppArgs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).numArgs) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(RpsCmdCallbackContext),
            "::",
            stringify!(numArgs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).userTag) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(RpsCmdCallbackContext),
            "::",
            stringify!(userTag)
        )
    );
}
#[doc = " @brief Parameters for accessing a resource."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RpsResourceAccessInfo {
    #[doc = "< ID of the resource to access."]
    pub resourceId: RpsResourceId,
    #[doc = "< Subresource range to access."]
    pub range: RpsSubresourceRange,
    #[doc = "< Attributes for access type and shader stages."]
    pub access: RpsAccessAttr,
    #[doc = "< Format to use for accessing."]
    pub viewFormat: RpsFormat,
}
#[test]
fn bindgen_test_layout_RpsResourceAccessInfo() {
    const UNINIT: ::std::mem::MaybeUninit<RpsResourceAccessInfo> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<RpsResourceAccessInfo>(),
        28usize,
        concat!("Size of: ", stringify!(RpsResourceAccessInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<RpsResourceAccessInfo>(),
        4usize,
        concat!("Alignment of ", stringify!(RpsResourceAccessInfo))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).resourceId) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RpsResourceAccessInfo),
            "::",
            stringify!(resourceId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).range) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(RpsResourceAccessInfo),
            "::",
            stringify!(range)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).access) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(RpsResourceAccessInfo),
            "::",
            stringify!(access)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).viewFormat) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(RpsResourceAccessInfo),
            "::",
            stringify!(viewFormat)
        )
    );
}
extern "C" {
    #[doc = " @brief Gets the render targets parameters from the current recording context.\n\n Must only be called from a graphics node callback.\n\n @param pContext                             Pointer to the current recording context. Must not be NULL.\n @param pRenderTargetInfo                    Pointer in which the render target parameters are returned.\n                                             Must not be NULL.\n\n @returns                                    Result code of the operation. See <c><i>RpsResult</i></c> for more info."]
    pub fn rpsCmdGetRenderTargetsInfo(
        pContext: *const RpsCmdCallbackContext,
        pRenderTargetInfo: *mut RpsCmdRenderTargetInfo,
    ) -> RpsResult;
}
extern "C" {
    #[doc = " @brief Gets the viewport info from the current recording context.\n\n Must only be called from a graphics node callback.\n\n @param pContext                             Pointer to the current recording context. Must not be NULL\n @param pViewportInfo                        Pointer in which the viewport parameters are returned to.\n                                             Must not be NULL.\n\n @returns                                    Result code of the operation. See <c><i>RpsResult</i></c> for more info."]
    pub fn rpsCmdGetViewportInfo(
        pContext: *const RpsCmdCallbackContext,
        pViewportInfo: *mut RpsCmdViewportInfo,
    ) -> RpsResult;
}
#[doc = " @brief Parameters for explicitly beginning a render pass from a command callback.\n\n Intended for controlling RenderPass suspend / resume & secondary command buffer behaviors."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RpsCmdRenderPassBeginInfo {
    #[doc = "< Flags for render pass properties."]
    pub flags: RpsRuntimeRenderPassFlags,
}
#[test]
fn bindgen_test_layout_RpsCmdRenderPassBeginInfo() {
    const UNINIT: ::std::mem::MaybeUninit<RpsCmdRenderPassBeginInfo> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<RpsCmdRenderPassBeginInfo>(),
        4usize,
        concat!("Size of: ", stringify!(RpsCmdRenderPassBeginInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<RpsCmdRenderPassBeginInfo>(),
        4usize,
        concat!("Alignment of ", stringify!(RpsCmdRenderPassBeginInfo))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RpsCmdRenderPassBeginInfo),
            "::",
            stringify!(flags)
        )
    );
}
extern "C" {
    #[doc = " @brief Clones a command callback context to create a secondary context and assigns it a new command buffer.\n\n The cloned context inherits states from the context being cloned, such as current command info and command\n arguments. The typical use case is multi-threaded command recording from within a node callback.\n Must be synchronized by the caller if called from multiple threads. The created context pointer is valid until the\n next render graph update.\n\n @param pContext                             Pointer to the current command callback context.\n @param hCmdBufferForDerivedContext          Handle to the command buffer to be associated with the new context.\n @param ppDerivedContext                     Pointer in which a pointer to the cloned command callback context is\n                                             returned. Must not be NULL.\n\n @returns                                    Result code of the operation. See <c><i>RpsResult</i></c> for more info."]
    pub fn rpsCmdCloneContext(
        pContext: *const RpsCmdCallbackContext,
        hCmdBufferForDerivedContext: RpsRuntimeCommandBuffer,
        ppDerivedContext: *mut *const RpsCmdCallbackContext,
    ) -> RpsResult;
}
extern "C" {
    #[doc = " @brief Begins a rasterization rendering pass.\n\n This may begin e.g. a VkRenderPass or set up render targets and viewport/scissor rect states for APIs that do not\n support a render pass objects. Usually used for multi-threaded rendering from within a command callback.\n\n @param pContext                             Pointer to the current command callback context. Must not be NULL.\n @param pBeginInfo                           Pointer to render pass parameters. Must not be NULL.\n\n @returns                                    Result code of the operation. See <c><i>RpsResult</i></c> for more info."]
    pub fn rpsCmdBeginRenderPass(
        pContext: *const RpsCmdCallbackContext,
        pBeginInfo: *const RpsCmdRenderPassBeginInfo,
    ) -> RpsResult;
}
extern "C" {
    #[doc = " @brief Ends a rasterization rendering pass.\n\n Must be paired with rpsCmdBeginRenderPass. Usually used for multi-threaded rendering from within a command callback.\n\n @param pContext                             Pointer to the current command callback context. Must not be NULL.\n\n @returns                                    Result code of the operation. See <c><i>RpsResult</i></c> for more info."]
    pub fn rpsCmdEndRenderPass(pContext: *const RpsCmdCallbackContext) -> RpsResult;
}
extern "C" {
    #[doc = " @brief Sets a new command buffer to be used for command recording.\n\n RPS does not track previously used command buffers. It is the responsibility of the application to track and\n submit them in order accordingly. Usually used for multi-threaded rendering.\n\n @param pContext                             Pointer to the current command callback context. Must not be NULL.\n @param hCmdBuffer                           Handle to the new command buffer.\n\n @returns                                    Result code of the operation. See <c><i>RpsResult</i></c> for more info."]
    pub fn rpsCmdSetCommandBuffer(
        pContext: *const RpsCmdCallbackContext,
        hCmdBuffer: RpsRuntimeCommandBuffer,
    ) -> RpsResult;
}
extern "C" {
    #[doc = " @brief Gets the description of the current cmd node.\n\n @param pContext                             Pointer to the current command callback context. Must not be NULL.\n @param ppNodeName                           Pointer in which a null terminated string with the name of the node\n                                             is returned. Must not be NULL.\n @param pNodeNameLength                      Pointer in which the node name length is returned. Can be NULL.\n\n @return                                     Result code of the operation. See <c><i>RpsResult</i></c> for more info."]
    pub fn rpsCmdGetNodeName(
        pContext: *const RpsCmdCallbackContext,
        ppNodeName: *mut *const ::std::os::raw::c_char,
        pNodeNameLength: *mut usize,
    ) -> RpsResult;
}
extern "C" {
    #[doc = " @brief Gets the description of a node argument.\n\n @param pContext                             Pointer to the current command callback context. Must not be NULL.\n @param paramID                              Index of the parameter in the current command node callback.\n @param pDesc                                Pointer in which the parameter description is returned.\n                                             Must not be NULL.\n\n @returns                                    Result code of the operation. See <c><i>RpsResult</i></c> for more info."]
    pub fn rpsCmdGetParamDesc(
        pContext: *const RpsCmdCallbackContext,
        paramID: RpsParamId,
        pDesc: *mut RpsParameterDesc,
    ) -> RpsResult;
}
extern "C" {
    #[doc = " @brief Gets an array of resource descriptions of a resource node argument.\n\n @param pContext                     Callback context of the current command.\n @param argIndex                     Index of the argument to get the resource descriptions from. Must be a resource\n                                     array argument if numDescs > 1.\n @param srcArrayOffset               Offset to the first resource description to get.\n @param pResourceDescs               Pointer to an array of <c><i>RpsResourceDesc</i></c> in which the numDescs\n                                     resource descriptions are returned. Must not be NULL if numDescs != 0.\n @param numDescs                     Number of resource descriptions to get. Requires srcArrayOffset + numDescs to\n                                     be less than the number of elements in the node argument.\n\n @returns                            Result code of the operation. See <c><i>RpsResult</i></c> for more info."]
    pub fn rpsCmdGetArgResourceDescArray(
        pContext: *const RpsCmdCallbackContext,
        argIndex: RpsParamId,
        srcArrayOffset: u32,
        pResourceDescs: *mut RpsResourceDesc,
        numDescs: u32,
    ) -> RpsResult;
}
extern "C" {
    #[doc = " @brief Gets the resource description from a node argument.\n\n @param pContext                             Pointer to the current command callback context. Must not be NULL.\n @param argIndex                             Index of the parameter in the current command node callback.\n @param pResourceDesc                        Pointer in which the resource description is returned. Must not be NULL.\n\n @returns                                    Result code of the operation. See <c><i>RpsResult</i></c> for more info."]
    pub fn rpsCmdGetArgResourceDesc(
        pContext: *const RpsCmdCallbackContext,
        argIndex: RpsParamId,
        pResourceDesc: *mut RpsResourceDesc,
    ) -> RpsResult;
}
extern "C" {
    #[doc = " @brief Gets an array of runtime resources from a resource node argument.\n\n @param pContext                     Callback context of the current command.\n @param argIndex                     Index of the argument to get the runtime resource from. Must be a resource array\n                                     argument if numResources > 1.\n @param srcArrayOffset               Offset to the first runtime resource to get.\n @param pRuntimeResources            Pointer to an array of <c><i>RpsRuntimeResource</i></c> in which the\n                                     numResources runtime resources are returned.\n                                     Must not be NULL if numResources != 0.\n @param numResources                 Number of runtime resources to get. Requires srcArrayOffset + numResources to\n                                     be less than the number of elements in the node argument.\n\n @returns                            Result code of the operation. See <c><i>RpsResult</i></c> for more info."]
    pub fn rpsCmdGetArgRuntimeResourceArray(
        pContext: *const RpsCmdCallbackContext,
        argIndex: RpsParamId,
        srcArrayOffset: u32,
        pRuntimeResources: *mut RpsRuntimeResource,
        numResources: u32,
    ) -> RpsResult;
}
extern "C" {
    #[doc = " @brief Gets the runtime resource from a resource node argument.\n\n @param pContext                             Pointer to the current command callback context. Must not be NULL.\n @param argIndex                             Index of the parameter in the current command node callback.\n @param pRuntimeResource                     Pointer in which the runtime resource is returned. Must not be NULL.\n\n @returns                                    Result code of the operation. See <c><i>RpsResult</i></c> for more info."]
    pub fn rpsCmdGetArgRuntimeResource(
        pContext: *const RpsCmdCallbackContext,
        argIndex: RpsParamId,
        pRuntimeResource: *mut RpsRuntimeResource,
    ) -> RpsResult;
}
extern "C" {
    #[doc = " @brief Gets an array of resource access infos from a resource node argument.\n\n @param pContext                     Callback context of the current command.\n @param argIndex                     Index of the argument to get the resource access infos from. Must be a resource\n                                     array argument if numAccessess > 1.\n @param srcArrayOffset               Offset to the first resource access info to get.\n @param pResourceAccessInfos         Pointer to an array of <c><i>RpsResourceAccessInfo</i></c> in which the\n                                     numAccessess resource access infos are returned.\n                                     Must not be NULL if numAccessess != 0.\n @param numAccessess                 Number of resource access infos to get. Requires srcArrayOffset +\n                                     to be less than the number of elements in the node argument.\n\n @returns                            Result code of the operation. See <c><i>RpsResult</i></c> for more info."]
    pub fn rpsCmdGetArgResourceAccessInfoArray(
        pContext: *const RpsCmdCallbackContext,
        argIndex: RpsParamId,
        srcArrayOffset: u32,
        pResourceAccessInfos: *mut RpsResourceAccessInfo,
        numAccessess: u32,
    ) -> RpsResult;
}
extern "C" {
    #[doc = " @brief Gets the resource access info from a resource node argument.\n\n @param pContext                             Pointer to the current command callback context. Must not be NULL.\n @param argIndex                             Index of the parameter in the current command node callback.\n @param pResourceAccessInfo                  Pointer in which the resource access info is returned. Must not be NULL.\n\n @returns                                    Result code of the operation. See <c><i>RpsResult</i></c> for more info."]
    pub fn rpsCmdGetArgResourceAccessInfo(
        pContext: *const RpsCmdCallbackContext,
        argIndex: RpsParamId,
        pResourceAccessInfo: *mut RpsResourceAccessInfo,
    ) -> RpsResult;
}
#[doc = " @brief Signature of functions for acquiring command buffers in a simplified execution mode.\n\n Reserved for future use."]
pub type PFN_rpsAcquireRuntimeCommandBuffer = ::std::option::Option<
    unsafe extern "C" fn(
        pUserContext: *mut ::std::os::raw::c_void,
        queueIndex: u32,
        numCmdBuffers: u32,
        pCmdBuffers: *mut RpsRuntimeCommandBuffer,
        pCmdBufferIdentifiers: *mut u32,
    ) -> RpsResult,
>;
#[doc = " @brief Signature of functions for submitting command buffers in a simplified execution mode.\n\n Reserved for future use."]
pub type PFN_rpsSubmitRuntimeCommandBuffer = ::std::option::Option<
    unsafe extern "C" fn(
        pUserContext: *mut ::std::os::raw::c_void,
        queueIndex: u32,
        pRuntimeCmdBufs: *const RpsRuntimeCommandBuffer,
        numRuntimeCmdBufs: u32,
        waitId: u32,
        signalId: u32,
    ) -> RpsResult,
>;
#[doc = " @brief Parameters for executing a render graph."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RpsRenderGraphExecuteInfo {
    #[doc = "< Pointer to a user defined context to be passed"]
    pub pUserContext: *mut ::std::os::raw::c_void,
    #[doc = "< Pointer to a function to acquire command"]
    pub pfnAcquireRuntimeCmdBufCb: PFN_rpsAcquireRuntimeCommandBuffer,
    #[doc = "< Pointer to a function to submit command"]
    pub pfnSubmitRuntimeCmdBufCb: PFN_rpsSubmitRuntimeCommandBuffer,
}
#[test]
fn bindgen_test_layout_RpsRenderGraphExecuteInfo() {
    const UNINIT: ::std::mem::MaybeUninit<RpsRenderGraphExecuteInfo> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<RpsRenderGraphExecuteInfo>(),
        24usize,
        concat!("Size of: ", stringify!(RpsRenderGraphExecuteInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<RpsRenderGraphExecuteInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(RpsRenderGraphExecuteInfo))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pUserContext) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RpsRenderGraphExecuteInfo),
            "::",
            stringify!(pUserContext)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pfnAcquireRuntimeCmdBufCb) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(RpsRenderGraphExecuteInfo),
            "::",
            stringify!(pfnAcquireRuntimeCmdBufCb)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pfnSubmitRuntimeCmdBufCb) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(RpsRenderGraphExecuteInfo),
            "::",
            stringify!(pfnSubmitRuntimeCmdBufCb)
        )
    );
}
extern "C" {
    #[doc = " @brief Executes a render graph.\n\n @param hRenderGraph                                 Handle to the render graph. Must not be RPS_NULL_HANDLE.\n @param pExecuteInfo                                 Pointer to render graph execution parameters. Must not be NULL.\n\n @returns                                            Result code of the operation. See <c><i>RpsResult</i></c> for\n                                                     more info."]
    pub fn rpsRenderGraphExecute(
        hRenderGraph: RpsRenderGraph,
        pExecuteInfo: *const RpsRenderGraphExecuteInfo,
    ) -> RpsResult;
}
pub type PFN_CreateCommandResources = ::std::option::Option<
    unsafe extern "C" fn(
        context: *const ::std::os::raw::c_void,
        user_data: *mut ::std::os::raw::c_void,
    ) -> RpsResult,
>;
extern "C" {
    pub fn addRuntime(
        pCreateInfo: *const RpsNullRuntimeDeviceCreateInfo,
        phDevice: *mut RpsDevice,
        cb: PFN_CreateCommandResources,
        user_data: *mut ::std::os::raw::c_void,
    ) -> RpsResult;
}
pub type __builtin_va_list = [__va_list_tag; 1usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __va_list_tag {
    pub gp_offset: ::std::os::raw::c_uint,
    pub fp_offset: ::std::os::raw::c_uint,
    pub overflow_arg_area: *mut ::std::os::raw::c_void,
    pub reg_save_area: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout___va_list_tag() {
    const UNINIT: ::std::mem::MaybeUninit<__va_list_tag> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__va_list_tag>(),
        24usize,
        concat!("Size of: ", stringify!(__va_list_tag))
    );
    assert_eq!(
        ::std::mem::align_of::<__va_list_tag>(),
        8usize,
        concat!("Alignment of ", stringify!(__va_list_tag))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gp_offset) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(gp_offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fp_offset) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(fp_offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).overflow_arg_area) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(overflow_arg_area)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reg_save_area) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(reg_save_area)
        )
    );
}
#[test]
fn __bindgen_test_layout_rps_Span_open0_rps_Edge_unsigned_int_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<rps_Span<::std::os::raw::c_uint>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(rps_Span<::std::os::raw::c_uint>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<rps_Span<::std::os::raw::c_uint>>(),
        4usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(rps_Span<::std::os::raw::c_uint>)
        )
    );
}
#[test]
fn __bindgen_test_layout_rps_Span_open0_rps_Edge_unsigned_int_close0_instantiation_1() {
    assert_eq!(
        ::std::mem::size_of::<rps_Span<::std::os::raw::c_uint>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(rps_Span<::std::os::raw::c_uint>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<rps_Span<::std::os::raw::c_uint>>(),
        4usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(rps_Span<::std::os::raw::c_uint>)
        )
    );
}
#[test]
fn __bindgen_test_layout_rps_Vector_open0_rps_Node_rps_ArenaAllocator_open1_rps_Node_close1_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<rps_Vector<rps_Node, rps_ArenaAllocator>>(),
        32usize,
        concat!(
            "Size of template specialization: ",
            stringify ! (rps_Vector < rps_Node , rps_ArenaAllocator >)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<rps_Vector<rps_Node, rps_ArenaAllocator>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify ! (rps_Vector < rps_Node , rps_ArenaAllocator >)
        )
    );
}
#[test]
fn __bindgen_test_layout_rps_ArenaAllocator_open0_rps_Node_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<rps_ArenaAllocator>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(rps_ArenaAllocator)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<rps_ArenaAllocator>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(rps_ArenaAllocator)
        )
    );
}
#[test]
fn __bindgen_test_layout_rps_Vector_open0_rps_Edge_rps_ArenaAllocator_open1_rps_Edge_close1_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<rps_Vector<rps_Edge, rps_ArenaAllocator>>(),
        32usize,
        concat!(
            "Size of template specialization: ",
            stringify ! (rps_Vector < rps_Edge , rps_ArenaAllocator >)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<rps_Vector<rps_Edge, rps_ArenaAllocator>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify ! (rps_Vector < rps_Edge , rps_ArenaAllocator >)
        )
    );
}
#[test]
fn __bindgen_test_layout_rps_ArenaAllocator_open0_rps_Edge_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<rps_ArenaAllocator>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(rps_ArenaAllocator)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<rps_ArenaAllocator>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(rps_ArenaAllocator)
        )
    );
}
#[test]
fn __bindgen_test_layout_rps_Vector_open0_rps_Subgraph_rps_ArenaAllocator_open1_rps_Subgraph_close1_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<rps_Vector<rps_Subgraph, rps_ArenaAllocator>>(),
        32usize,
        concat!(
            "Size of template specialization: ",
            stringify ! (rps_Vector < rps_Subgraph , rps_ArenaAllocator >)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<rps_Vector<rps_Subgraph, rps_ArenaAllocator>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify ! (rps_Vector < rps_Subgraph , rps_ArenaAllocator >)
        )
    );
}
#[test]
fn __bindgen_test_layout_rps_ArenaAllocator_open0_rps_Subgraph_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<rps_ArenaAllocator>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(rps_ArenaAllocator)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<rps_ArenaAllocator>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(rps_ArenaAllocator)
        )
    );
}
#[test]
fn __bindgen_test_layout_rps_Vector_open0_rps_Edge_rps_ArenaAllocator_open1_rps_Edge_close1_close0_instantiation_1(
) {
    assert_eq!(
        ::std::mem::size_of::<rps_Vector<rps_Edge, rps_ArenaAllocator>>(),
        32usize,
        concat!(
            "Size of template specialization: ",
            stringify ! (rps_Vector < rps_Edge , rps_ArenaAllocator >)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<rps_Vector<rps_Edge, rps_ArenaAllocator>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify ! (rps_Vector < rps_Edge , rps_ArenaAllocator >)
        )
    );
}
#[test]
fn __bindgen_test_layout_rps_ArenaAllocator_open0_rps_Edge_close0_instantiation_1() {
    assert_eq!(
        ::std::mem::size_of::<rps_ArenaAllocator>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(rps_ArenaAllocator)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<rps_ArenaAllocator>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(rps_ArenaAllocator)
        )
    );
}
#[test]
fn __bindgen_test_layout_rps_ArrayRef_open0_RpsVariable_unsigned_long_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<rps_ArrayRef<RpsVariable, ::std::os::raw::c_ulong>>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify ! (rps_ArrayRef < RpsVariable , :: std :: os :: raw :: c_ulong >)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<rps_ArrayRef<RpsVariable, ::std::os::raw::c_ulong>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify ! (rps_ArrayRef < RpsVariable , :: std :: os :: raw :: c_ulong >)
        )
    );
}
#[test]
fn __bindgen_test_layout_rps_Span_open0_RpsParamId_unsigned_int_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<rps_Span<::std::os::raw::c_uint>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(rps_Span<::std::os::raw::c_uint>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<rps_Span<::std::os::raw::c_uint>>(),
        4usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(rps_Span<::std::os::raw::c_uint>)
        )
    );
}
#[test]
fn __bindgen_test_layout_rps_ArrayRef_open0_rps_NodeParamDecl_unsigned_long_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<rps_ArrayRef<rps_NodeParamDecl, ::std::os::raw::c_ulong>>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify ! (rps_ArrayRef < rps_NodeParamDecl , :: std :: os :: raw :: c_ulong >)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<rps_ArrayRef<rps_NodeParamDecl, ::std::os::raw::c_ulong>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify ! (rps_ArrayRef < rps_NodeParamDecl , :: std :: os :: raw :: c_ulong >)
        )
    );
}
#[test]
fn __bindgen_test_layout_rps_ArrayRef_open0_rps_ParamSemanticsKindInfo_uint32_t_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<rps_ArrayRef<rps_ParamSemanticsKindInfo, u32>>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify ! (rps_ArrayRef < rps_ParamSemanticsKindInfo , u32 >)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<rps_ArrayRef<rps_ParamSemanticsKindInfo, u32>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify ! (rps_ArrayRef < rps_ParamSemanticsKindInfo , u32 >)
        )
    );
}
#[test]
fn __bindgen_test_layout_rps_ArrayRef_open0_RpsParamId_uint32_t_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<rps_ArrayRef<RpsParamId, u32>>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify ! (rps_ArrayRef < RpsParamId , u32 >)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<rps_ArrayRef<RpsParamId, u32>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify ! (rps_ArrayRef < RpsParamId , u32 >)
        )
    );
}
#[test]
fn __bindgen_test_layout_rps_Span_open0_rps_ParamSemanticsKindInfo_unsigned_int_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<rps_Span<::std::os::raw::c_uint>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(rps_Span<::std::os::raw::c_uint>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<rps_Span<::std::os::raw::c_uint>>(),
        4usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(rps_Span<::std::os::raw::c_uint>)
        )
    );
}
#[test]
fn __bindgen_test_layout_rps_Span_open0_rps_ParamSemanticsKindInfo_unsigned_int_close0_instantiation_1(
) {
    assert_eq!(
        ::std::mem::size_of::<rps_Span<::std::os::raw::c_uint>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(rps_Span<::std::os::raw::c_uint>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<rps_Span<::std::os::raw::c_uint>>(),
        4usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(rps_Span<::std::os::raw::c_uint>)
        )
    );
}
#[test]
fn __bindgen_test_layout_rps_GeneralAllocator_open0_rps_RenderGraphSignature_ParamSemanticKey_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<rps_GeneralAllocator>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(rps_GeneralAllocator)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<rps_GeneralAllocator>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(rps_GeneralAllocator)
        )
    );
}
#[test]
fn __bindgen_test_layout_rps_ArrayRef_open0_rps_NodeDeclInfo_unsigned_long_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<rps_ArrayRef<rps_NodeDeclInfo, ::std::os::raw::c_ulong>>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify ! (rps_ArrayRef < rps_NodeDeclInfo , :: std :: os :: raw :: c_ulong >)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<rps_ArrayRef<rps_NodeDeclInfo, ::std::os::raw::c_ulong>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify ! (rps_ArrayRef < rps_NodeDeclInfo , :: std :: os :: raw :: c_ulong >)
        )
    );
}
#[test]
fn __bindgen_test_layout_rps_ArrayRef_open0_rps_ParamDecl_unsigned_long_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<rps_ArrayRef<rps_ParamDecl, ::std::os::raw::c_ulong>>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify ! (rps_ArrayRef < rps_ParamDecl , :: std :: os :: raw :: c_ulong >)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<rps_ArrayRef<rps_ParamDecl, ::std::os::raw::c_ulong>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify ! (rps_ArrayRef < rps_ParamDecl , :: std :: os :: raw :: c_ulong >)
        )
    );
}
#[test]
fn __bindgen_test_layout_rps_ArrayRef_open0_RpsParamId_unsigned_long_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<rps_ArrayRef<RpsParamId, ::std::os::raw::c_ulong>>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify ! (rps_ArrayRef < RpsParamId , :: std :: os :: raw :: c_ulong >)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<rps_ArrayRef<RpsParamId, ::std::os::raw::c_ulong>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify ! (rps_ArrayRef < RpsParamId , :: std :: os :: raw :: c_ulong >)
        )
    );
}
#[test]
fn __bindgen_test_layout_rps_TResult_open0_RpsVariable_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<rps_TResult<RpsVariable>>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!(rps_TResult<RpsVariable>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<rps_TResult<RpsVariable>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(rps_TResult<RpsVariable>)
        )
    );
}
#[test]
fn __bindgen_test_layout_rps_ArrayRef_open0_RpsVariable_unsigned_long_close0_instantiation_1() {
    assert_eq!(
        ::std::mem::size_of::<rps_ArrayRef<RpsVariable, ::std::os::raw::c_ulong>>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify ! (rps_ArrayRef < RpsVariable , :: std :: os :: raw :: c_ulong >)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<rps_ArrayRef<RpsVariable, ::std::os::raw::c_ulong>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify ! (rps_ArrayRef < RpsVariable , :: std :: os :: raw :: c_ulong >)
        )
    );
}
#[test]
fn __bindgen_test_layout_rps_Span_open0_rps_ResourceDecl_unsigned_int_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<rps_Span<::std::os::raw::c_uint>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(rps_Span<::std::os::raw::c_uint>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<rps_Span<::std::os::raw::c_uint>>(),
        4usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(rps_Span<::std::os::raw::c_uint>)
        )
    );
}
#[test]
fn __bindgen_test_layout_rps_Span_open0_RpsResourceId_unsigned_int_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<rps_Span<::std::os::raw::c_uint>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(rps_Span<::std::os::raw::c_uint>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<rps_Span<::std::os::raw::c_uint>>(),
        4usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(rps_Span<::std::os::raw::c_uint>)
        )
    );
}
#[test]
fn __bindgen_test_layout_rps_ArrayRef_open0_rps_RenderGraphBuilder_RenderGraphArgInfo_unsigned_long_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<
            rps_ArrayRef<rps_RenderGraphBuilder_RenderGraphArgInfo, ::std::os::raw::c_ulong>,
        >(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify ! (rps_ArrayRef < rps_RenderGraphBuilder_RenderGraphArgInfo , :: std :: os :: raw :: c_ulong >)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<
            rps_ArrayRef<rps_RenderGraphBuilder_RenderGraphArgInfo, ::std::os::raw::c_ulong>,
        >(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify ! (rps_ArrayRef < rps_RenderGraphBuilder_RenderGraphArgInfo , :: std :: os :: raw :: c_ulong >)
        )
    );
}
#[test]
fn __bindgen_test_layout_rps_ArrayRef_open0_RpsResourceId_unsigned_long_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<rps_ArrayRef<RpsResourceId, ::std::os::raw::c_ulong>>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify ! (rps_ArrayRef < RpsResourceId , :: std :: os :: raw :: c_ulong >)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<rps_ArrayRef<RpsResourceId, ::std::os::raw::c_ulong>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify ! (rps_ArrayRef < RpsResourceId , :: std :: os :: raw :: c_ulong >)
        )
    );
}
#[test]
fn __bindgen_test_layout_rps_Vector_open0_rps_ResourceDecl_rps_ArenaAllocator_open1_rps_ResourceDecl_close1_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<rps_Vector<rps_ResourceDecl, rps_ArenaAllocator>>(),
        32usize,
        concat!(
            "Size of template specialization: ",
            stringify ! (rps_Vector < rps_ResourceDecl , rps_ArenaAllocator >)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<rps_Vector<rps_ResourceDecl, rps_ArenaAllocator>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify ! (rps_Vector < rps_ResourceDecl , rps_ArenaAllocator >)
        )
    );
}
#[test]
fn __bindgen_test_layout_rps_ArenaAllocator_open0_rps_ResourceDecl_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<rps_ArenaAllocator>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(rps_ArenaAllocator)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<rps_ArenaAllocator>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(rps_ArenaAllocator)
        )
    );
}
#[test]
fn __bindgen_test_layout_rps_Vector_open0_rps_NodeDependency_rps_ArenaAllocator_open1_rps_NodeDependency_close1_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<rps_Vector<rps_NodeDependency, rps_ArenaAllocator>>(),
        32usize,
        concat!(
            "Size of template specialization: ",
            stringify ! (rps_Vector < rps_NodeDependency , rps_ArenaAllocator >)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<rps_Vector<rps_NodeDependency, rps_ArenaAllocator>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify ! (rps_Vector < rps_NodeDependency , rps_ArenaAllocator >)
        )
    );
}
#[test]
fn __bindgen_test_layout_rps_ArenaAllocator_open0_rps_NodeDependency_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<rps_ArenaAllocator>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(rps_ArenaAllocator)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<rps_ArenaAllocator>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(rps_ArenaAllocator)
        )
    );
}
#[test]
fn __bindgen_test_layout_rps_Vector_open0_ptr_const_rps__NodeDeclInfo_rps_ArenaAllocator_open1_ptr_const_rps__NodeDeclInfo_close1_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<rps_Vector<*const rps_NodeDeclInfo, rps_ArenaAllocator>>(),
        32usize,
        concat!(
            "Size of template specialization: ",
            stringify!(rps_Vector<*const rps_NodeDeclInfo, rps_ArenaAllocator>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<rps_Vector<*const rps_NodeDeclInfo, rps_ArenaAllocator>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(rps_Vector<*const rps_NodeDeclInfo, rps_ArenaAllocator>)
        )
    );
}
#[test]
fn __bindgen_test_layout_rps_ArenaAllocator_open0_ptr_const_rps__NodeDeclInfo_close0_instantiation()
{
    assert_eq!(
        ::std::mem::size_of::<rps_ArenaAllocator>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(rps_ArenaAllocator)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<rps_ArenaAllocator>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(rps_ArenaAllocator)
        )
    );
}
#[test]
fn __bindgen_test_layout_rps_ArrayRef_open0_rps_Subprogram_RpslNodeImpl_unsigned_long_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<rps_ArrayRef<rps_Subprogram_RpslNodeImpl, ::std::os::raw::c_ulong>>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify ! (rps_ArrayRef < rps_Subprogram_RpslNodeImpl , :: std :: os :: raw :: c_ulong >)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<rps_ArrayRef<rps_Subprogram_RpslNodeImpl, ::std::os::raw::c_ulong>>(
        ),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify ! (rps_ArrayRef < rps_Subprogram_RpslNodeImpl , :: std :: os :: raw :: c_ulong >)
        )
    );
}
#[test]
fn __bindgen_test_layout_rps_Span_open0_rps_FinalAccessInfo_unsigned_int_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<rps_Span<::std::os::raw::c_uint>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(rps_Span<::std::os::raw::c_uint>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<rps_Span<::std::os::raw::c_uint>>(),
        4usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(rps_Span<::std::os::raw::c_uint>)
        )
    );
}
#[test]
fn __bindgen_test_layout_rps_Vector_open0_RpsResourceId_rps_ArenaAllocator_open1_unsigned_int_close1_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<rps_Vector<RpsResourceId, rps_ArenaAllocator>>(),
        32usize,
        concat!(
            "Size of template specialization: ",
            stringify ! (rps_Vector < RpsResourceId , rps_ArenaAllocator >)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<rps_Vector<RpsResourceId, rps_ArenaAllocator>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify ! (rps_Vector < RpsResourceId , rps_ArenaAllocator >)
        )
    );
}
#[test]
fn __bindgen_test_layout_rps_ArenaAllocator_open0_unsigned_int_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<rps_ArenaAllocator>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(rps_ArenaAllocator)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<rps_ArenaAllocator>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(rps_ArenaAllocator)
        )
    );
}
#[test]
fn __bindgen_test_layout_rps_Vector_open0_RpsNodeId_rps_ArenaAllocator_open1_unsigned_int_close1_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<rps_Vector<RpsNodeId, rps_ArenaAllocator>>(),
        32usize,
        concat!(
            "Size of template specialization: ",
            stringify ! (rps_Vector < RpsNodeId , rps_ArenaAllocator >)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<rps_Vector<RpsNodeId, rps_ArenaAllocator>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify ! (rps_Vector < RpsNodeId , rps_ArenaAllocator >)
        )
    );
}
#[test]
fn __bindgen_test_layout_rps_ArenaAllocator_open0_unsigned_int_close0_instantiation_1() {
    assert_eq!(
        ::std::mem::size_of::<rps_ArenaAllocator>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(rps_ArenaAllocator)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<rps_ArenaAllocator>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(rps_ArenaAllocator)
        )
    );
}
#[test]
fn __bindgen_test_layout_rps_Span_open0_rps_CmdAccessInfo_unsigned_int_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<rps_Span<::std::os::raw::c_uint>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(rps_Span<::std::os::raw::c_uint>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<rps_Span<::std::os::raw::c_uint>>(),
        4usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(rps_Span<::std::os::raw::c_uint>)
        )
    );
}
#[test]
fn __bindgen_test_layout_rps_Span_open0_rps_ResourceAliasingInfo_unsigned_int_close0_instantiation()
{
    assert_eq!(
        ::std::mem::size_of::<rps_Span<::std::os::raw::c_uint>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(rps_Span<::std::os::raw::c_uint>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<rps_Span<::std::os::raw::c_uint>>(),
        4usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(rps_Span<::std::os::raw::c_uint>)
        )
    );
}
#[test]
fn __bindgen_test_layout_rps_ArrayRef_open0_RpsMemoryTypeInfo_unsigned_long_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<rps_ArrayRef<RpsMemoryTypeInfo, ::std::os::raw::c_ulong>>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify ! (rps_ArrayRef < RpsMemoryTypeInfo , :: std :: os :: raw :: c_ulong >)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<rps_ArrayRef<RpsMemoryTypeInfo, ::std::os::raw::c_ulong>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify ! (rps_ArrayRef < RpsMemoryTypeInfo , :: std :: os :: raw :: c_ulong >)
        )
    );
}
#[test]
fn __bindgen_test_layout_rps_Vector_open0_ptr_IRenderGraphPhase_rps_ArenaAllocator_open1_ptr_IRenderGraphPhase_close1_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<rps_Vector<*mut rps_IRenderGraphPhase, rps_ArenaAllocator>>(),
        32usize,
        concat!(
            "Size of template specialization: ",
            stringify!(rps_Vector<*mut rps_IRenderGraphPhase, rps_ArenaAllocator>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<rps_Vector<*mut rps_IRenderGraphPhase, rps_ArenaAllocator>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(rps_Vector<*mut rps_IRenderGraphPhase, rps_ArenaAllocator>)
        )
    );
}
#[test]
fn __bindgen_test_layout_rps_ArenaAllocator_open0_ptr_IRenderGraphPhase_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<rps_ArenaAllocator>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(rps_ArenaAllocator)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<rps_ArenaAllocator>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(rps_ArenaAllocator)
        )
    );
}
#[test]
fn __bindgen_test_layout_rps_Vector_open0_rps_ResourceInstance_rps_ArenaAllocator_open1_rps_ResourceInstance_close1_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<rps_Vector<rps_ResourceInstance, rps_ArenaAllocator>>(),
        32usize,
        concat!(
            "Size of template specialization: ",
            stringify ! (rps_Vector < rps_ResourceInstance , rps_ArenaAllocator >)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<rps_Vector<rps_ResourceInstance, rps_ArenaAllocator>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify ! (rps_Vector < rps_ResourceInstance , rps_ArenaAllocator >)
        )
    );
}
#[test]
fn __bindgen_test_layout_rps_ArenaAllocator_open0_rps_ResourceInstance_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<rps_ArenaAllocator>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(rps_ArenaAllocator)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<rps_ArenaAllocator>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(rps_ArenaAllocator)
        )
    );
}
#[test]
fn __bindgen_test_layout_rps_Vector_open0_ptr_ProgramInstance_rps_ArenaAllocator_open1_ptr_ProgramInstance_close1_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<rps_Vector<*mut rps_ProgramInstance, rps_ArenaAllocator>>(),
        32usize,
        concat!(
            "Size of template specialization: ",
            stringify!(rps_Vector<*mut rps_ProgramInstance, rps_ArenaAllocator>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<rps_Vector<*mut rps_ProgramInstance, rps_ArenaAllocator>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(rps_Vector<*mut rps_ProgramInstance, rps_ArenaAllocator>)
        )
    );
}
#[test]
fn __bindgen_test_layout_rps_ArenaAllocator_open0_ptr_ProgramInstance_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<rps_ArenaAllocator>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(rps_ArenaAllocator)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<rps_ArenaAllocator>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(rps_ArenaAllocator)
        )
    );
}
#[test]
fn __bindgen_test_layout_rps_Vector_open0_rps_CmdInfo_rps_ArenaAllocator_open1_rps_CmdInfo_close1_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<rps_Vector<rps_CmdInfo, rps_ArenaAllocator>>(),
        32usize,
        concat!(
            "Size of template specialization: ",
            stringify ! (rps_Vector < rps_CmdInfo , rps_ArenaAllocator >)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<rps_Vector<rps_CmdInfo, rps_ArenaAllocator>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify ! (rps_Vector < rps_CmdInfo , rps_ArenaAllocator >)
        )
    );
}
#[test]
fn __bindgen_test_layout_rps_ArenaAllocator_open0_rps_CmdInfo_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<rps_ArenaAllocator>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(rps_ArenaAllocator)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<rps_ArenaAllocator>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(rps_ArenaAllocator)
        )
    );
}
#[test]
fn __bindgen_test_layout_rps_Vector_open0_rps_CmdAccessInfo_rps_ArenaAllocator_open1_rps_CmdAccessInfo_close1_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<rps_Vector<rps_CmdAccessInfo, rps_ArenaAllocator>>(),
        32usize,
        concat!(
            "Size of template specialization: ",
            stringify ! (rps_Vector < rps_CmdAccessInfo , rps_ArenaAllocator >)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<rps_Vector<rps_CmdAccessInfo, rps_ArenaAllocator>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify ! (rps_Vector < rps_CmdAccessInfo , rps_ArenaAllocator >)
        )
    );
}
#[test]
fn __bindgen_test_layout_rps_ArenaAllocator_open0_rps_CmdAccessInfo_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<rps_ArenaAllocator>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(rps_ArenaAllocator)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<rps_ArenaAllocator>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(rps_ArenaAllocator)
        )
    );
}
#[test]
fn __bindgen_test_layout_rps_Vector_open0_rps_TransitionInfo_rps_ArenaAllocator_open1_rps_TransitionInfo_close1_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<rps_Vector<rps_TransitionInfo, rps_ArenaAllocator>>(),
        32usize,
        concat!(
            "Size of template specialization: ",
            stringify ! (rps_Vector < rps_TransitionInfo , rps_ArenaAllocator >)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<rps_Vector<rps_TransitionInfo, rps_ArenaAllocator>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify ! (rps_Vector < rps_TransitionInfo , rps_ArenaAllocator >)
        )
    );
}
#[test]
fn __bindgen_test_layout_rps_ArenaAllocator_open0_rps_TransitionInfo_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<rps_ArenaAllocator>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(rps_ArenaAllocator)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<rps_ArenaAllocator>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(rps_ArenaAllocator)
        )
    );
}
#[test]
fn __bindgen_test_layout_rps_Vector_open0_rps_FinalAccessInfo_rps_ArenaAllocator_open1_rps_FinalAccessInfo_close1_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<rps_Vector<rps_FinalAccessInfo, rps_ArenaAllocator>>(),
        32usize,
        concat!(
            "Size of template specialization: ",
            stringify ! (rps_Vector < rps_FinalAccessInfo , rps_ArenaAllocator >)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<rps_Vector<rps_FinalAccessInfo, rps_ArenaAllocator>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify ! (rps_Vector < rps_FinalAccessInfo , rps_ArenaAllocator >)
        )
    );
}
#[test]
fn __bindgen_test_layout_rps_ArenaAllocator_open0_rps_FinalAccessInfo_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<rps_ArenaAllocator>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(rps_ArenaAllocator)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<rps_ArenaAllocator>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(rps_ArenaAllocator)
        )
    );
}
#[test]
fn __bindgen_test_layout_rps_Vector_open0_rps_RuntimeCmdInfo_rps_ArenaAllocator_open1_rps_RuntimeCmdInfo_close1_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<rps_Vector<rps_RuntimeCmdInfo, rps_ArenaAllocator>>(),
        32usize,
        concat!(
            "Size of template specialization: ",
            stringify ! (rps_Vector < rps_RuntimeCmdInfo , rps_ArenaAllocator >)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<rps_Vector<rps_RuntimeCmdInfo, rps_ArenaAllocator>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify ! (rps_Vector < rps_RuntimeCmdInfo , rps_ArenaAllocator >)
        )
    );
}
#[test]
fn __bindgen_test_layout_rps_ArenaAllocator_open0_rps_RuntimeCmdInfo_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<rps_ArenaAllocator>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(rps_ArenaAllocator)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<rps_ArenaAllocator>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(rps_ArenaAllocator)
        )
    );
}
#[test]
fn __bindgen_test_layout_rps_Vector_open0_RpsCommandBatch_rps_ArenaAllocator_open1_RpsCommandBatch_close1_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<rps_Vector<RpsCommandBatch, rps_ArenaAllocator>>(),
        32usize,
        concat!(
            "Size of template specialization: ",
            stringify ! (rps_Vector < RpsCommandBatch , rps_ArenaAllocator >)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<rps_Vector<RpsCommandBatch, rps_ArenaAllocator>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify ! (rps_Vector < RpsCommandBatch , rps_ArenaAllocator >)
        )
    );
}
#[test]
fn __bindgen_test_layout_rps_ArenaAllocator_open0_RpsCommandBatch_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<rps_ArenaAllocator>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(rps_ArenaAllocator)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<rps_ArenaAllocator>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(rps_ArenaAllocator)
        )
    );
}
#[test]
fn __bindgen_test_layout_rps_Vector_open0_uint32_t_rps_ArenaAllocator_open1_unsigned_int_close1_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<rps_Vector<u32, rps_ArenaAllocator>>(),
        32usize,
        concat!(
            "Size of template specialization: ",
            stringify ! (rps_Vector < u32 , rps_ArenaAllocator >)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<rps_Vector<u32, rps_ArenaAllocator>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify ! (rps_Vector < u32 , rps_ArenaAllocator >)
        )
    );
}
#[test]
fn __bindgen_test_layout_rps_ArenaAllocator_open0_unsigned_int_close0_instantiation_2() {
    assert_eq!(
        ::std::mem::size_of::<rps_ArenaAllocator>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(rps_ArenaAllocator)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<rps_ArenaAllocator>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(rps_ArenaAllocator)
        )
    );
}
#[test]
fn __bindgen_test_layout_rps_Vector_open0_rps_ResourceAliasingInfo_rps_ArenaAllocator_open1_rps_ResourceAliasingInfo_close1_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<rps_Vector<rps_ResourceAliasingInfo, rps_ArenaAllocator>>(),
        32usize,
        concat!(
            "Size of template specialization: ",
            stringify ! (rps_Vector < rps_ResourceAliasingInfo , rps_ArenaAllocator >)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<rps_Vector<rps_ResourceAliasingInfo, rps_ArenaAllocator>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify ! (rps_Vector < rps_ResourceAliasingInfo , rps_ArenaAllocator >)
        )
    );
}
#[test]
fn __bindgen_test_layout_rps_ArenaAllocator_open0_rps_ResourceAliasingInfo_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<rps_ArenaAllocator>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(rps_ArenaAllocator)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<rps_ArenaAllocator>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(rps_ArenaAllocator)
        )
    );
}
#[test]
fn __bindgen_test_layout_rps_Vector_open0_rps_HeapInfo_rps_ArenaAllocator_open1_rps_HeapInfo_close1_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<rps_Vector<rps_HeapInfo, rps_ArenaAllocator>>(),
        32usize,
        concat!(
            "Size of template specialization: ",
            stringify ! (rps_Vector < rps_HeapInfo , rps_ArenaAllocator >)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<rps_Vector<rps_HeapInfo, rps_ArenaAllocator>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify ! (rps_Vector < rps_HeapInfo , rps_ArenaAllocator >)
        )
    );
}
#[test]
fn __bindgen_test_layout_rps_ArenaAllocator_open0_rps_HeapInfo_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<rps_ArenaAllocator>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(rps_ArenaAllocator)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<rps_ArenaAllocator>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(rps_ArenaAllocator)
        )
    );
}
#[test]
fn __bindgen_test_layout_rps_Vector_open0_RpsResourceDiagnosticInfo_rps_ArenaAllocator_open1_RpsResourceDiagnosticInfo_close1_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<rps_Vector<RpsResourceDiagnosticInfo, rps_ArenaAllocator>>(),
        32usize,
        concat!(
            "Size of template specialization: ",
            stringify ! (rps_Vector < RpsResourceDiagnosticInfo , rps_ArenaAllocator >)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<rps_Vector<RpsResourceDiagnosticInfo, rps_ArenaAllocator>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify ! (rps_Vector < RpsResourceDiagnosticInfo , rps_ArenaAllocator >)
        )
    );
}
#[test]
fn __bindgen_test_layout_rps_ArenaAllocator_open0_RpsResourceDiagnosticInfo_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<rps_ArenaAllocator>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(rps_ArenaAllocator)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<rps_ArenaAllocator>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(rps_ArenaAllocator)
        )
    );
}
#[test]
fn __bindgen_test_layout_rps_Vector_open0_RpsCmdDiagnosticInfo_rps_ArenaAllocator_open1_RpsCmdDiagnosticInfo_close1_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<rps_Vector<RpsCmdDiagnosticInfo, rps_ArenaAllocator>>(),
        32usize,
        concat!(
            "Size of template specialization: ",
            stringify ! (rps_Vector < RpsCmdDiagnosticInfo , rps_ArenaAllocator >)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<rps_Vector<RpsCmdDiagnosticInfo, rps_ArenaAllocator>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify ! (rps_Vector < RpsCmdDiagnosticInfo , rps_ArenaAllocator >)
        )
    );
}
#[test]
fn __bindgen_test_layout_rps_ArenaAllocator_open0_RpsCmdDiagnosticInfo_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<rps_ArenaAllocator>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(rps_ArenaAllocator)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<rps_ArenaAllocator>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(rps_ArenaAllocator)
        )
    );
}
#[test]
fn __bindgen_test_layout_rps_Vector_open0_RpsHeapDiagnosticInfo_rps_ArenaAllocator_open1_RpsHeapDiagnosticInfo_close1_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<rps_Vector<RpsHeapDiagnosticInfo, rps_ArenaAllocator>>(),
        32usize,
        concat!(
            "Size of template specialization: ",
            stringify ! (rps_Vector < RpsHeapDiagnosticInfo , rps_ArenaAllocator >)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<rps_Vector<RpsHeapDiagnosticInfo, rps_ArenaAllocator>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify ! (rps_Vector < RpsHeapDiagnosticInfo , rps_ArenaAllocator >)
        )
    );
}
#[test]
fn __bindgen_test_layout_rps_ArenaAllocator_open0_RpsHeapDiagnosticInfo_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<rps_ArenaAllocator>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(rps_ArenaAllocator)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<rps_ArenaAllocator>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(rps_ArenaAllocator)
        )
    );
}
#[test]
fn __bindgen_test_layout_rps_ArrayRef_open0_rps_ResourceInstance_unsigned_long_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<rps_ArrayRef<rps_ResourceInstance, ::std::os::raw::c_ulong>>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify ! (rps_ArrayRef < rps_ResourceInstance , :: std :: os :: raw :: c_ulong >)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<rps_ArrayRef<rps_ResourceInstance, ::std::os::raw::c_ulong>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify ! (rps_ArrayRef < rps_ResourceInstance , :: std :: os :: raw :: c_ulong >)
        )
    );
}
#[test]
fn __bindgen_test_layout_rps_ArrayRef_open0_rps_ResourceInstance_unsigned_long_close0_instantiation_1(
) {
    assert_eq!(
        ::std::mem::size_of::<rps_ArrayRef<rps_ResourceInstance, ::std::os::raw::c_ulong>>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify ! (rps_ArrayRef < rps_ResourceInstance , :: std :: os :: raw :: c_ulong >)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<rps_ArrayRef<rps_ResourceInstance, ::std::os::raw::c_ulong>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify ! (rps_ArrayRef < rps_ResourceInstance , :: std :: os :: raw :: c_ulong >)
        )
    );
}
